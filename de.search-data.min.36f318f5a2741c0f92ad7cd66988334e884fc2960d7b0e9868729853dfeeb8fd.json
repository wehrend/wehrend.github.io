[{"id":0,"href":"/de/posts/web/26_get_the_nandlab_go_board_ready_on_debian/","title":"FPGA 101: Get the Nandland Go board ready on Debian Bullseye","section":"Web","content":" Hallo zusammen,\nendlich ist diese Woche das nandland go board angekommen, das ich vor einem Monat beim Entwickler Russell Merrick bestellt hatte. Es hat aufgrund einiger Versandprobleme einen Umweg genommen, aber darum geht es hier nicht. Ich musste mich mit einigen Hindernissen herumschlagen, um es auf meinem Debian Bullseye zum Laufen zu bringen.\nSerielle Verbindung über USB Zunächst einmal muss man, um sich über FTDI USB mit der Platine zu verbinden, wie es bei Debian Bullseye vorgeschlagen wird, zuerst seinen Benutzer zur Gruppe „dialout“ hinzufügen. Dies geschieht wie folgt:\nsu - usermod -aG dialout $user (in meinem Fall ist $user sven) exit\nund dann den Computer neu starten. Danach erneut verbinden (nur um sicherzugehen). Dann Putty starten und /dev/ttyUSB1 als den Port eingeben, den Sie verwenden möchten (/dev/ttyUSB0 funktioniert hier nicht), und wie vorgeschlagen baudrate 115200 eingeben. Jetzt können Sie Zeichen und Ziffern eingeben, die an das Gerät und zurück gesendet werden. Das funktioniert also jetzt.\nIcecube2 installieren Kommen wir zum nächsten Hindernis: Der iCEcube2-Installer (und die Software) benötigen die Bibliothek libpng12.so.0. Wie Sie mit der Datei\nfile ./iCEcube2setup_Dec_10_2020_2012\ndies gibt Folgendes aus ./iCEcube2setup_Dec_10_2020_2012: ELF 32-Bit LSB ausführbar, Intel 80386, Version 1 (SYSV), dynamisch verknüpft, Interpreter /lib/ld-linux.so.2, für GNU/Linux 2.2.5, nicht gestrippt , sodass Sie wissen, dass Sie dies für die i386-Architektur installieren müssen. Sie können dies über Folgendes tun:\nsu apt-get install libpng16-16:i386 ln -s /usr/lib/i386-linux-gnu/libpng16.so.16.37.0 libpng12.so.0\nJetzt sollte die Software wie erwartet starten.\nLizenz-/Netzwerkprobleme Als Nächstes benötigen Sie eine Node-Lizenz, die an Ihre Host-ID von Lattice gebunden ist. Sie finden sie über\nip addr show\nheraus. Nehmen Sie die Zeichenfolge „link/ether“ und kopieren Sie die physische MAC-Adresse (12-stelliger Hexadezimalwert) dahinter (ohne Doppelpunkte: \u0026#39;) in den Lizenzdateigenerator. Aktivieren Sie anschließend das Kontrollkästchen und klicken Sie auf „Lizenz generieren“. Senden. Sie sollten eine E-Mail mit der angehängten Lizenzdatei „license.dat“ erhalten. Legen Sie diese in das Verzeichnis Ihrer Softwareinstallation.\nexport LM_LICENSE_FILE=~/software/iCEcube2.2020.12/license/license.dat; (Machen Sie dies persistent, indem Sie es in Ihre bashrc einfügen, damit Sie dies nicht jedes Mal wiederholen müssen, wenn Sie die Software starten). Jetzt erhalten wir eine Fehlermeldung, die in etwa so lautet: „Ungültiger Host. Die Host-ID dieses Systems stimmt nicht mit der Host-ID überein (Fehlercode -9).“\nWie sich herausstellt, tritt dieser Fehler nur auf, weil Debian den Namen der Netzwerkschnittstelle in etwas anderes als „eth0“ ändert, der Lizenzserver jedoch erwartet, dass er an dieser Stelle steht. Er schreibt ihn sogar selbst auf die Support-Seite, wenn Sie Lizenzprobleme eingeben:\n\u0026#34;--Wenn Sie die Fehlermeldung ‚Ungültiger Host. Die Host-ID dieses Systems stimmt nicht mit der Host-ID überein (Fehlercode -9)‘ erhalten, da Lattice-Tools den fest codierten Netzwerkschnittstellennamen (eth0) verwenden und der aktive Netzwerkschnittstellenname auf dem System auf einen anderen als eth0 eingestellt ist, kann die Lizenzdatei nicht überprüft werden und der obige Fehler wird generiert. Um dies zu vermeiden, müssen Sie den aktiven Netzwerkschnittstellennamen wie folgt in eth0 umbenennen: 1). Führen Sie den folgenden Befehl mit Root-Rechten aus: a). cd /etc/udev/rules.d/ b). vi 70-persistent-net.rules In der Datei 70-persistent-net.rules sehen Sie einen Wert wie: NAME =„\u0026lt;active NIC name (for example p6p1,em1 etc)“ ändern Sie ihn in NAME=„eth0“ und speichern Sie die Datei 2). Starten Sie das System neu. --Bitte überprüfen Sie, ob die MAC-Adresse, die Sie auf unserer Website erhalten haben, die MAC-ID Ihrer Ethernet-LAN-Karte ist. --Bevor Sie den Fall einreichen, geben Sie uns bitte die Informationen zur Linux-Version, einen Screenshot der Fehlermeldung, einen Screenshot des Befehls „ifconfig -a“ und Ihre aktuelle Lizenz. \u0026#34; Um dieses Problem zu lösen, müssen Sie eine Datei wie unten erstellen. Öffnen Sie als root einen Texteditor:\nsu nano /etc/udev/rules.d/70-persistent-net.rules\nund geben Sie den folgenden Text ein – natürlich mit Ihrer physischen Mac-Adresse/Host-ID, wie in ip addr show angezeigt:\nSUBSYSTEM==„net“, ACTION==„add“, DRIVERS==„?*“, ATTR{address}==„\u0026lt;your-mac-address\u0026gt;“, ATTR{dev_id}==„0x0“, ATTR{type}==„1“, KERNEL==„enp11s*“, NAME=„eth0“ Schließen Sie dann die Datei und starten Sie den Computer neu. Beim nächsten Öffnen von icecube2 sollte es funktionieren und wie erwartet starten.\nIch hoffe, dass dieser Blogbeitrag Sie im richtigen Moment erreicht und Ihnen dabei hilft, schneller als ich zu sein, der einen ganzen Nachmittag damit verbracht hat, dieses Problem zu beheben.\n"},{"id":1,"href":"/de/posts/synth/25_build_your_own_modules/","title":"Build your own synthesizer modules","section":"Posts","content":" Einleitung Hallo, heute möchte ich Ihnen das Grundwissen über den Selbstbau Ihrer eigenen Synthesizermodule vermitteln – diese benötigen nicht den Eurorack-Standard, obwohl sie in meinem Fall dazugehören.\nWenn Sie mit eurorack format oder einem anderen modularen Synthesizer-Standard beginnen, insbesondere aber mit dem Eurorack-Standard, werden Sie höchstwahrscheinlich von die schiere Anzahl der Hersteller und verfügbaren Produkte überwältigt sein. Einen einfachen Überblick erhalten Sie hier auf ModularGrid. Sie brauchen ein paar Wochen oder sogar Monate, um sich durch einige Testberichte auf Amzona.de zu lesen oder Synthesizer-Läden wie SchneidersLaden besuchen, um sich einen groben Überblick über die Vielfalt des Marktes zu verschaffen.\nWarum Selbstbau? Aber warum in aller Welt sollte man sich für den Selbstbau entscheiden und Module selbst bauen, wenn es doch bereits so viele Optionen mit fertig montierten Modulen zu einem guten Preis gibt Module selbst zu bauen? Dafür kann es mehrere Gründe geben: - Selbstbau ist billiger als fertig erhältliche Module, obwohl dies debattierbar ist, da man hohe Anfangskosten für Werkzeuge und Material hat. - Selbermachen ist interessant, weil man viel darüber lernt, wie die Module funktionieren, wie Elektronik im Allgemeinen funktioniert, und mit der Zeit wird man schließlich besser darin, Fehler zu erkennen und zu beheben.\nEs lohnt sich auf jeden Fall, wenn man ein Hobby wie Elektronik in Betracht ziehen möchte, und ich persönlich denke, dass ein modularer Synthesizer der beste Weg ist, um als Hobby mit Elektronik und Audioschaltungen in Kontakt zu kommen.\nAls Nächstes werden wir kurz besprechen, welche Werkzeuge, Komponenten und Verbrauchsmaterialien Sie benötigen, um mit diesem Hobby zu beginnen. Nur kurz, da dies auf verschiedene Arten und Weisen im Internet unter NorthCoastSynthesis diskutiert wird. Außerdem werde ich den Umfang auf Module beschränken, nicht auf Gehäuse und Netzteile, da dies ein ganz anderes Thema ist, und außerdem sollten Sie niemals ein eigenes Netzteil bauen, wenn Sie nicht wissen, was Sie tun. Halten Sie sich vom Stromnetz fern!!\nAusrüstung Hier ist eine Liste der Werkzeuge, die Sie auf jeden Fall als Grundausstattung benötigen:\neine Lötstation und Lötmaterialien\nein Digitalmultimeter oder Multimeter zum Messen von Widerständen, Spannungen und Strömen\neine dritte Hand (die das Löten erleichtert)\nein Seitenschneider/Drahtschneider\neine Elektronikzange\nAls Lot für THT (Durchsteckmontage, womit Sie beginnen sollten) sollten Sie bleifreies Lot mit einem Durchmesser von 1 mm bestellen\nEinen gut beleuchteten Arbeitsplatz\nJe nach Werkbank eine Lötunterlage, um zu verhindern, dass Ihre Werkbank verbrannt wird!\nDies sind die absoluten Grundlagen (das Digitalmultimeter könnte man theoretisch weglassen, aber es nützt einem nichts, da es billig ist und man es für grundlegende Tests benötigt) Und ich wette, ich habe noch etwas vergessen.\nWenn Sie in die Welt der SMD-/SMT-Technologie einsteigen möchten (wir wollen hier nur die Größe 0805 verwenden/ beschreiben), benötigen Sie zusätzlich:\nals Lot für SMD-Löten bleifreies Lot mit einem Durchmesser von 0,3 mm\nPinzette\nund optional eine Lupe, aber wie gesagt, diese sind optional (z. B. habe ich sie noch nicht benötigt, da 0805 relativ groß ist)\nTesten des Moduls Das war es soweit zum Bau, aber man braucht auch etwas Ausrüstung zum Testen. Es ist sinnvoll, das Modul zunächst in einem separaten Rack mit separater Stromversorgung zu testen, bevor man es in das Eurorack-Gehäuse einbaut und im Falle einer Fehlfunktion andere Module beschädigt. Hier macht ein kleiner Pod absolut Sinn 4ms pod32.\nAußerdem benötigen Sie wahrscheinlich eine Eingangsquelle für Ihr Modul wie CV-, Audio- oder Gate-Signale. Verwenden Sie aus diesem Grund einen einfachen Oszillator (CV, Audio) oder Sequenzer (Gate): Hier kommen Erica Synth Pico VCO oder Erica Synth Pico VCO2 in den Sinn.\nAußerdem benötigen Sie ein Ausgangsmodul. Eigentlich können Sie mit diesem Bausatz wirklich anfangen, es ist ein einfacher Verstärker mit eingebautem Lautsprecher CLACKTRONICS - MINI SPEAKER KIT\nVerpolungsschutz In diesem Zusammenhang möchte ich Sie auch daran erinnern, bei Ihren Konstruktionen immer Verpolungsschutzdioden zu verwenden. Verwenden Sie hierfür 1N5817 (THT) oder MBR0540T1 (SMD). Ich konnte kein Bild finden, also habe ich es von einigen Befaco-Schaltplänen kopiert. Seien Sie also gnädig mit mir und ignorieren Sie die 100-nF-Kondensatoren.\nDieses Bild mag für Sie noch keinen Sinn ergeben, aber das wird sich ändern, sobald Sie lernen, Elektronikschaltpläne zu lesen (was Sie tun sollten, wenn Sie dieses Hobby in Betracht ziehen).\nEinige Hersteller und Module für den Anfang Kommen wir nun zum Kern dieses Blog-Beitrags: Welche Hersteller und Module sollten Sie als Anfänger in Betracht ziehen?\nIch persönlich habe meine Reise mit der gut dokumentierten erica synths edu series begonnen, dann ein paar befaco modules (auch gut dokumentiert, auch etwas billiger bei exploding shed, was die Versandkosten betrifft ) und dann Module von NonlinearCircuits (NLC) (ebenso gut dokumentiert), aber es gibt keinen besonderen Grund, sie in dieser Reihenfolge zu machen.\nFazit und Links Zusammenfassend lässt sich sagen, dass die Welt der Eurorack-Synthesizer und -Module ein lohnendes (wenn auch geldaufwendiges) Unterfangen ist, bei dem man unbedingt mitmachen sollte, wenn man das Bedürfnis oder den Drang dazu verspüren.\nZu guter Letzt noch ein paar Links, damit Sie wissen, wo Sie nach Inspiration und DIY-Kits suchen können:\nexploding Shed, ein Unternehmen mit Sitz in Leipzig, Deutschland\n3U Shop, mit Sitz in Petershagen bei Berlin, Deutschland\nSynthesizer – So funktioniert elektronische Klangerzeugung von Florian Anwander Das Buch, das mich zu diesem Hobby gebracht hat [Deutsch]\nMuffWiggler Ein sehr schönes Synthesizer-Forum\nAlso, verbreitet den Sound! (Noch zu tun: einige Bilder hinzufügen.)\n"},{"id":2,"href":"/de/posts/web/ltb162/25_ltb162/","title":"Ein Lieblingshobby von mir: Lustiges Taschenbuch Nr. 162","section":"Web","content":" Es ist an der Zeit, einen weiteren meiner Favoriten mit Ihnen zu teilen, und das ist Entenhausen und das Entenuniversum. Ich nehme das LTB (Lustiges Taschenbuch) Nr. 162 als Beispiel aus der goldenen Ära der Comic-Serie „Lustiges Taschenbuch“\nDer goldene Totempfahl (The golden totem pole) In der Geschichte „Der goldene Totempfahl“ (englisch: „The golden totem pole“) dreht Onkel Dagobert einen Film über sein Leben. Die Geschichte spielt in der Grafschaft Dawson, wo sie sich nach einem Sturm verirren. Sie treffen den Indianer „großer Elch“ „Big Moose“ und suchen nach den Goldnuggets, die Big Moose für Onkel Dagobert in der Vergangenheit aufbewahrt hat. Der Film endet damit, dass Big Moose als Filmstar endet.\nDer reichste Mann des Universums (The richest men in universe) In der Geschichte „Der reichste Mann des Universums“ (The richest men in universe) unternimmt Onkel Dagobert mit seinen Verwandten (Neffe Donald Duck und Großneffen Tick, Trick und Track) eine Weltraumtour. Sie nehmen an einem Wettbewerb der reichsten Männer im Universum mit einem anderen Typen im Weltraum, der eine Wunschmaschine hat…​ Durch die Anwesenheit von Onkel Dagobert wird das empfindliche Gleichgewicht des Ökosystems gestört…​ (die Geschichte muss man selbst lesen ;-) )\n"},{"id":3,"href":"/de/posts/web/24_fpga_beginners_de10_board/","title":"FPGA 101: DE10-nano board: Hallo Welt","section":"Web","content":" Heute möchte ich Ihnen zeigen, wie Sie eine Verbindung zum DE10-nano-Board herstellen, dem Nachfolger des DE0-nano-Boards. Es ist etwas größer, kostet fast 300 Dollar, unterstützt aber auch sofort einsatzbereites Linux. Auf der SD-Karte ist Angstrom Linux installiert. Um das Board über die UART-Schnittstelle anzuschließen, schalten Sie das Board mit dem Steckernetzteil ein, legen Sie die SD-Karte ein, um das Linux-Booten zu starten, und schließen Sie schließlich das Micro-USB-Kabel (wie unten gezeigt) an den PC an.\nGehen Sie dann zur Konsole und geben Sie (als root) Folgendes ein\n# dmesg | grep FTDI Wenn der Treiber idealerweise bereits installiert ist, sollten Sie Folgendes zurückerhalten:\n[ 6352.585966] usb 3-4: Hersteller: FTDI [ 6352.648922] usbserial: USB Serial support registered for FTDI USB Serial Device [ 6352.648961] ftdi_sio 3-4:1.0: FTDI USB Serial Device converter detected [ 6352.656051] usb 3-4: FTDI USB Serial Device converter now attached to ttyUSB0 Jetzt müssen Sie nur noch die Benutzerberechtigungen ändern, wieder als root (dies müssen Sie nach jedem Booten/jeder Verbindung tun):\n# chmod a+rw /dev/ttyUSB0 Schließlich müssen Sie noch putty installieren, was unter Linux genauso einfach ist wie unter Windows:\n# apt-get install -y putty Öffnen Sie dann putty\n$ putty Geben Sie das Gerät /dev/ttyUSB0 ein, wie in der ftdi-Ausgabe oben gezeigt, geben Sie die Baudrate von 115200 ein und speichern Sie die Konfiguration.\nDrücken Sie auf „Öffnen“ und im Idealfall sollte eine Verbindung zum Board hergestellt werden. Wenn keine Warnung angezeigt wird, drücken Sie die Eingabetaste und Sie erhalten das folgende Bild:\nGeben Sie root als Benutzernamen und als Passwort ein.\nFortsetzung folgt…​\n"},{"id":4,"href":"/de/posts/web/23_fpga_beginners_start_with_verilog/","title":"FPGA 101: Starte mit Quartus und Verilog","section":"Web","content":" Sie haben sich also entschieden, FPGA-Programmierung zu lernen, und haben die Voraussetzungen aus introduction 0 sowie simple logic circuit über die BDF-Dateien von Quartus erfüllt. Heute möchten wir Ihnen zeigen, wie Sie Quartus verstehen, indem wir ein weiteres Hardware-Äquivalent des in der Softwarewelt verwendeten Hallo-Welt-Programms erstellen – wir programmieren einen Binärzähler, der durch die LED-Reihe angezeigt wird, die auf unserer DE0-nano-Platine verfügbar ist. Dazu verwenden wir sowohl die Blockdiagrammdateien (bdf) von Quartus als auch die beliebte HDL (Hardware Description Language) Verilog.\nWir öffnen also zunächst Quartus über das Desktop-Symbol. Dann gehen wir zum Menü „Datei \u0026gt;\u0026gt; Assistent für neues Projekt“, wie unten dargestellt, und klicken darauf. Dann geben wir ihm den Namen „counter“, klicken uns schnell durch die Schritte des Assistenten, es gibt nichts weiter zu tun, klicken Sie einfach auf OK, bis der Assistent abgeschlossen ist . In diesem Tutorial erstellen wir die folgenden Dateien:\nbinarycounter.v - Das Verilog-Modul mit dem Binärzähler\nclock_divider.v - Ein Clock-Teiler, um den Systemtakt auf eine niedrige Frequenz zu verlangsamen, der das Auge noch folgen kann - counter.bdf - Eine Quartus-Schaltplan-Datei, um beide oben genannten Module zu verbinden und sie mit den Pins zu verbinden\nWir beginnen mit dem Binärzähler.\nBinärzähler in Verilog Zuerst definieren wir das Modul und geben ihm einen Namen sowie die in(s) und out(s), die es als Parameter trägt. Im Moment ist das sehr einfach: Wir haben clk, was kurz für clock als Eingang steht, und einen Ausgang namens out.\nmodule bin_counter(clk, out); Als Nächstes definieren wir die Eingänge bzw. Ausgänge. Der Taktgeber wird als Eingang von einem Draht definiert, da er in das Modul geht und nur ein einziges Signal, das hoch oder niedrig werden kann. Für den Ausgang definieren wir ein Register – es wird durch das Schlüsselwort reg definiert –, um die Werte zu speichern, gefolgt von eckigen Klammern, um zu definieren, dass der Ausgang ein Array von 8 Bits ist, [0:7] bedeutet, dass wir 8 Bits haben, beginnend mit Index 0 und endend mit Index 7.\nmodule bin_counter(clk, out); input wire clk; output reg [0:7] out; Dann definieren wir das wesentliche Modul, indem wir angeben, was zwischen der begin- und der end-Anweisung geschieht, bevor wir das Schlüsselwort always, gefolgt von einem \u0026#39;@\u0026#39;, und die Sensibilitätsliste in Klammern verwenden. Die Sensibilitätsliste listet den Taktgeber mit podsedge auf, d. h. er reagiert auf Übergänge von niedrig (0) zu hoch (1). Zwischen begin und end erhöhen wir einfach den Zähler des out-Signals.\nmodule bin_counter(clk, out); input wire clk; output reg [0:7] out; always @ (posedge clk) begin out \u0026lt;= out + 1; end Schließlich beenden wir die Modulbeschreibung mit der Anweisung „endmodule“.\n/binarycounter.v module bin_counter(clk, out); input wire clk; output reg [0:7] out; always @ (posedge clk) begin out \u0026lt;= out + 1; end endmodule Taktgeber-Teiler in Verilog Jetzt können wir unser Taktsignal von der FPGA-Platine mit dem Eingang unseres Binärzählers verbinden. Aber halt – es gibt ein Problem: Wenn Sie einen Blick in das Datenblatt oder das Benutzerhandbuch der Platine werfen, sehen Sie, dass der externe Taktgeber auf der DE0-nano-Platine eine Frequenz von 50 MHz hat. Wir müssen diese auf eine Frequenz von etwa 1 Hz herunterteilen, was einem Zyklus pro Sekunde entspricht. Dazu müssen wir das Signal durch etwa 50.000.000 teilen. Um zu berechnen, wie viel Bitbreite wir benötigen, müssen wir eine kleine Berechnung durchführen:\n\\[50.000.000 = 2^x\\]\n\\[x = log_{2}(50.000.000)= 25.575\\]\nDa wir das Ergebnis aufrunden müssen, benötigen wir eine Bitbreite von 26 Bit. Damit hätten wir eine Frequenz von (50 MHz / 2^26) = 0,745 Hz als Ergebnis. Das ist weniger als 1 Hz, aber damit können wir vorerst leben. Was nun folgt, ist die einfache Implementierung des Zählers:\n/clock_divider.v module clock_divider(clk,out); input wire clk; output reg [0:25] out = 0; always @ (posedge clk) begin out \u0026lt;= out + 1; end endmodule Zähler BDF Zuletzt erstellen wir die Datei counter.bdf, die alles zusammenhält, wie unten dargestellt.\nZuerst müssen wir die Datei binarycounter.v öffnen und auf File \u0026gt;\u0026gt; Create / Update \u0026gt;\u0026gt; Create Symbol Files for Current File klicken, wie in der folgenden Abbildung dargestellt. Wir öffnen die Datei/Registerkarte clock_divider.v und wiederholen den obigen Schritt.\nNach diesem Schritt finden wir die gerade neu erstellten Dateien in der Symbolbibliothek, öffnen die Symbolbibliothek (siehe Bild unten) und finden die Module im Verzeichnis project.\nAls Nächstes folgen Sie den verschiedenen Build-Schritten in der Schaltplan-Datei:\nBild:../quartus_counter_schematic_2.png[Quartus - Counter.bdf 2]\nBeachten Sie bei der Zuweisung der Busbreite unter „Eigenschaften“, dass die Syntax „..“ anstelle von „:“ (Semikolon) lautet!\nBild:../quartus_counter_schematic_3.png[Quartus - Counter.bdf 3]\nBild:../quartus_counter_schematic_4.png[Quartus - Counter.bdf 4]\nBild:../quartus_counter_schematic_5.png[Quartus - Counter.bdf 5]\nBild:../quartus_counter_schematic_6.png[Quartus - Counter.bdf 6]\nBild:../quartus_counter_schematic_7.png[Quartus - Counter.bdf 7]\nPin-Zuordnung Als Nächstes müssen wir die Design-Eingänge und -Ausgänge mit den physischen Pins verknüpfen. Unten sehen Sie das Bild des Clock-Pins. Vergessen Sie nicht, vorher die Synthese oder zumindest die Analyse durchzuführen.\nBild:../de0nano_clock.png[DE0-nano Clock]\nUnd das Bild der LED-Ausgänge.\nUnd hier das Bild des Pin-Planers\nFür die DE0-nano-Platine müssen wir die Pins also wie folgt zuweisen:\nclock50 | PIN_R8\nled1| PIN_A15\nled2| PIN_A13\nled3| PIN_B13\nled4| PIN_A11\nled5| PIN_D1\nled6| PIN_F3\nled7| PIN_B1\nled8| PIN_L3\nProgrammierung des Geräts Jetzt, da wir mit der ganzen Arbeit fertig sind, können wir die vollständige Synthese durchführen und unsere Platine programmieren. Gehen Sie zu „Tools“ \u0026gt;\u0026gt; „Programmer“ oder klicken Sie einfach auf das Programmierersymbol und verbinden Sie Ihr schönes FPGA-Board über USB mit dem Computer. Die Hardware sollte erkannt und angezeigt werden, ebenso die ausgewählte Sof-Software-Datei.\nSchließlich sollten Sie sehen, wie die LEDs auf der Platine mit einer Frequenz von 0,745 Hz zählen.\nHier sind auch die Projektdateien: Link:../counter.tar.gz[Counter-Projektdateien]\nHinweis: Ich habe dieses Tutorial von hier gestohlen, aber meine eigenen Bilder und meinen eigenen Stil hinzugefügt.\n"},{"id":5,"href":"/de/posts/web/22_fpga_beginners_1/","title":"FPGA 101: Starte mit Quartus","section":"Web","content":" Sie haben sich also entschieden, FPGA-Programmierung zu lernen, und die Voraussetzungen aus dem letzten Blogbeitrag erfüllt. Heute möchten wir Ihnen zeigen, wie Sie Quartus verstehen lernen, indem Sie ein Hardware-Äquivalent des in der Software- welt verwendeten Hello-World-Programms erstellen – wir nennen es AndGate , weil es einfach das ist – ein UND-Gatter, das über zwei Taster als Eingang und eine Status-LED als Ausgang gespeist wird. Auf diese Weise verwenden wir die Blockdiagrammdateien (bdf) von Quartus.\nWir öffnen Quartus einfach über das Desktop-Symbol. Dann gehen wir zum Menü „Datei \u0026gt;\u0026gt; Assistent für neues Projekt“, wie unten dargestellt, und klicken darauf.\nIch habe dieses Tutorial von hier gestohlen, aber meine eigenen Bilder und meinen eigenen Stil hinzugefügt.\nSetup the project Als Nächstes sehen wir ein Einführungsfenster, wie unten dargestellt. Wir klicken auf „Weiter“, um zum nächsten Fenster zu gelangen, in dem wir das Projekt benennen.\nGeben Sie ihm einen passenden Namen wie AndGate oder HelloWorld, ganz wie Sie möchten…​\nAls Nächstes wählen wir auf der Seite „Project Type“ die Option „Empty Project“ aus\nWir überspringen die nächste Seite „Dateien hinzufügen“ und gehen zu „Familien-, Geräte- und Board-Einstellungen“.\nBild: ../quartus_choose_device.png[Quartus - Gerät auswählen]\nHier wählen wir die Familie Cyclone IV E und das Gerät mit dem Namen „EP4CE22F17C6“ gemäß dem beiliegenden Datenblatt des DE0-nano-Boards aus. Wir klicken auf „Weiter“ und überspringen vorerst den Schritt „EDA-Tool-Einstellungen“. Schließlich gelangen wir zur Zusammenfassung des Projektassistenten.\nNachdem Sie bestätigt haben, dass alles so ist, wie es sein sollte, klicken Sie auf „Fertigstellen“, um den Projekt- assistenten zu beenden.\nErstellen der Logik Wie oben beschrieben, werden wir die Grundfunktionen von Quartus verwenden, um unsere eigene Logik auf grafische Weise ohne HDL (Hardware Description) wie VHDL oder Verilog zu erstellen.\nEs erscheint eine Registerkarte AndGate.bdf mit einer leeren Leinwand, auf der wir unsere Schaltkreise/Logikgatter „zeichnen“ können. Wenn wir möchten, können wir unseren aktuellen Status speichern, indem wir zu „Datei \u0026gt;\u0026gt; Speichern unter …​“ gehen und einen Namen und Gate.bdf sowie einen geeigneten Pfad eingeben.\nBild: ../quartus_bdf_canvas.png [Quartus - BDF-Zeichenfläche]\nKlicken Sie nun auf das Symbol-Werkzeug-Symbol, wie in der Abbildung unten gezeigt, um die Symbolbibliothek zu öffnen.\nBild: ../quartus_symbol_tool.png [Quartus - Symbol-Werkzeug]\nEs öffnet sich ein neues Fenster, das die Bibliothek mit den drei Hauptordnern „Megafunction“, „other“ und „primitives“ anzeigt …​\nWir suchen nach einem Gatter mit zwei Eingängen, also gehen Sie zu „Primitives“, „logic“, „and2“, bestätigen Sie mit „ok“…​\nKlicken Sie nun in die Mitte der Raster-Zeichenfläche, um das Symbol einzugeben, und klicken Sie dann auf „Esc“, um den Bibliotheksmodus zu verlassen.\nHinzufügen von Pins Als Nächstes fügen wir einige Pins zur Designdatei hinzu. Diese Pins definieren die Schnittstelle zwischen unserem Design und den physischen I/O-Pins. Später in der Pin-Zuweisung werden wir die Pins mit den physischen Pins des Geräts verknüpfen.\nDas Pin-Werkzeug-Symbol befindet sich direkt neben dem Symbol-Werkzeug-Symbol. Klicken Sie auf den Pfeil, um das Auswahl- menü zu öffnen.\nWählen Sie „Ausgabe“ aus und ziehen Sie das Symbol irgendwo neben die Ausgabe des „and gate“. Zeichnen Sie dann eine Leitung zwischen dem Gate-Ausgang und dem Pin, indem Sie an einem der Punkte beginnen, die Maustaste gedrückt halten und eine Leitung zum anderen Punkt ziehen. Dann haben wir eine Verbindung.\nJetzt machen wir dasselbe für die Eingangspins…​\nZuletzt benennen wir die Pins um, damit sie besser passen. Doppelklicken Sie auf den Pin und benennen Sie ihn um. Eine andere Möglichkeit ist, darauf zu klicken und im Kontextmenü Eigenschaften auszuwählen. Wir benennen die Eingänge in „in1“, „in2“ und den Ausgang in „out1“ um, damit wir die Pins später im Pin-Zuweisungs- werkzeug richtig benennen können.\nPhysische Pins / Pin-Zuweisung Um die benötigten E/A-Pins zu überprüfen, sehen wir uns das Benutzerhandbuch des DE0-nano-Boards an.\nHier – im obigen Bild – sehen wir die beiden Taster des Nano-Boards, die über den SN74AUC17 gepuffert werden, um eine Entprellung zu erreichen.\nUnd unten sehen wir ein (stark vereinfachtes) Schaltbild der LEDs im Ausgang, bei dem die Vorwiderstände fehlen.\nJetzt haben wir alle physischen Pins, die wir brauchen:\nPin E1 - erster Taster\nPin J15 - zweiter Taster\nPin A15 - Status-LED\nUm nun das Design mit den physischen Pins zu verknüpfen, verwenden wir in Quartus das Tool „Pin Planner“.\nDieses Tool stellt uns eine Karte der verfügbaren Pins und Funktionen zur Verfügung und ermöglicht es uns, Teile des Designs den gewünschten Pins zuzuordnen.\nDamit Quartus versteht, welche Teile unseres Designs zugeordnet werden können, müssen wir zunächst eine Teilkompilierung des Designs mit dem Namen „analysis and elaboration“ durchführen.\nAnalyse und Ausarbeitung Es sind verschiedene Verarbeitungsschritte erforderlich, um unser Design in etwas umzuwandeln, das auf das FPGA geladen werden kann.\nAnalyse – in diesem Teil des Prozesses überprüft Quartus das Design auf Fehler wie Syntax- oder semantische Fehler. Ausarbeitung – In der ersten Phase der Kompilierung ordnet Quartus das Design in RTL-Blöcken an. Dies sind die Bausteine innerhalb des FPGA, die grundlegende Funktionen wie Speicher, Logikgatter und Register ausführen. Synthese – In der letzten Phase der Kompilierung synthetisiert Quartus ein Design auf Logikebene und wandelt das RTL-Design in ein Gatter-Design um.\nDamit unsere Pins im Pin-Planer angezeigt werden, könnten wir eine vollständige Kompilierung durchführen. Dies ist jedoch nicht notwendig, da wir nur die Analyse- und Ausarbeitungsphase durchlaufen müssen.\nQuartus stellt uns drei Kompilierungstools zur Verfügung, mit denen wir verschiedene Kompilierungsebenen durchlaufen können. Wir werden uns diese Schritte und ihre Funktion in einem zukünftigen Blogbeitrag genauer ansehen. Da die vollständige Kompilierung einige Zeit in Anspruch nehmen kann, ist es sinnvoll, nur den erforderlichen Prozess auszuführen. Führen Sie die Analyse und Ausarbeitung mit dem Tool aus, das Sie in der Menüleiste oben auf dem Bildschirm finden.\nPin-Zuweisung Nach Abschluss des Vorgangs erhalten Sie einen Kompilierungsbericht und neben dem Analyse- und Ausarbeitungsprozess im Menü auf der linken Seite wird ein grünes Häkchen angezeigt.\nJetzt können wir den Pin-Planer öffnen, indem wir im Menü oben auf dem Bildschirm auf „Assignments \u0026gt; Pin Planner“ klicken.\nDer Pin-Planer ist auf den ersten Blick etwas komplex, aber recht einfach zu bedienen.\nSie sehen eine Karte des FPGA mit allen physischen Pins und ihren Funktionen.\nWir interessieren uns für die Liste der Pins unten. Wenn Sie den vorherigen Schritt erfolgreich abgeschlossen haben, sollten die Pins aufgelistet werden. Geben Sie Ihre Schalter- und LED-Pins in das Feld „Location“ ein.\nDie Eingangspins sollten den physischen Pins entsprechen, die Sie mit den Drucktasten verbunden haben, und der Ausgangs- pin sollte dem Ausgangspin mit der angeschlossenen LED entsprechen. Wenn Sie fertig sind, können Sie den Pin-Planer schließen.\nSie sollten feststellen, dass Quartus die Pins mit den physischen Ausgängen beschriftet hat, die wir gerade zugewiesen haben. Beachten Sie, dass ich das Design-Fenster abgetrennt habe, um einen größeren Arbeitsbereich zu ermöglichen.\nSie können ein Fenster abtrennen, indem Sie mit der rechten Maustaste auf die Registerkarte oben im Arbeitsbereich klicken und „abtrennen“ auswählen. Sie können Fenster auch über das Fenstermenü in der oberen Menüleiste anhängen und abtrennen.\nHardware-Kompilierung/Synthese Nachdem wir unsere Pins zugewiesen haben, können wir den Kompilierungsprozess in der Hardware-Welt namens Synthese aus- führen, durch den das Design in eine binäre SRAM-Objektdatei (sof) umgewandelt wird. Das bedeutet, dass es nur im flüchtigen statischen RAM läuft, nicht persistent ist und nach dem Abschalten der Stromversorgung weg ist.\nimage: ../quartus_synthesis.png [Quartus - Synthesis]\nProgrammierung Nach Abschluss der Synthese können wir den Programmierer ausführen, um dieses kompilierte Programm in unser FPGA zu laden. Wir können den Programmierer über „Tools \u0026gt;\u0026gt; Programmer“ oder über das unten gezeigte Symbol öffnen\nBild: ../quartus_programmer.png [Quartus - Programmer]\nNachdem Sie das Nano-Board mit dem USB-Kabel verbunden haben, klicken Sie im Programmiergerät auf „Hardware Setup“. In der Liste des sich öffnenden Fensters sollte das Gerät als „USB-Blaster“ angezeigt werden. Wählen Sie es aus und klicken Sie auf „OK“. Nun müssen wir „Auto-detect“ auswählen, um die JTAG-Kette zu scannen und nach dem FPGA-Gerät EP4CE22 zu suchen. Vergewissern Sie sich außerdem, dass die SOF-Datei generiert wurde. Wenn nichts angezeigt wird und Sie Zweifel haben, führen Sie einfach alle Schritte einschließlich der Timing-Analyse manuell aus.\nWenn die SOF-Datei vorhanden ist und die Hardware angezeigt wird, klicken Sie einfach auf die Schaltfläche „Start“. Dann erledigt der Programmierer seine Aufgabe.\nJetzt sollte die LED aufleuchten, wenn Sie beide Tasten gleichzeitig drücken. Wenn wir jedoch die Hardware testen, werden wir hier ein anderes Verhalten feststellen: Wir haben nicht überprüft, ob das Datenblatt einen hohen Pegel für die Drucktasten angibt, wenn sie nicht gedrückt werden, also müssen wir das Design ändern. Zum besseren Vergleich fügen wir außerdem ein Oder-Gatter hinzu und verbinden es mit LED 1.\nIch überlasse es dem Leser, herauszufinden, wie der Schaltkreis wie abgebildet entworfen werden kann. Wenn dies nicht gelingt (oder zu faul ist), kann die BDF-Datei hier gefunden werden (Link unten).\nLink:../andGate.bdf[erweiterter Schaltkreis BDF]\nUnd vergessen Sie nicht, den Pin vom Ausgang des Oder-Gatters mit dem dedizierten Pin von LED 1 (PIN_A13) zu verbinden, wie unten dargestellt\nFühren Sie den Syntheseprozess aus und programmieren Sie die Platine und testen Sie sie.\nWenn wir nun das Verhalten testen, werden wir sehen, dass es sich jetzt wie vorgeschlagen korrekt verhält.\n"},{"id":6,"href":"/de/posts/web/21_fpga_beginners_0/","title":"FPGA 101: Beginne mit HDLs","section":"Web","content":" Heute möchte ich eine Blogpost-Serie über Hardware-Programmierung starten. Wir beginnen mit einer Einführung in die Hardware-Programmierung mit dem FPGA-Board DE0 Nano von der ehemaligen Firma Altera, jetzt Intel. Unten sehen Sie ein Bild des kleinen Boards. Es scheint, dass man dieses Board noch bestellen kann, aber ich habe es nicht getestet.\nWir zeigen, wie die Umgebung eingerichtet wird. Im ersten Schritt zeigen wir, wie man Quartus auf einer Debian-Distribution herunterlädt und installiert und den Programmierer konfiguriert. Im zweiten Schritt installieren wir die Simulationssoftware Modelsim.\nQuartus IDE Das Installationsprogramm finden Sie unter hier. Nach dem Akzeptieren der Lizenzvereinbarung wird das 60 MB große Quartus-Installationsprogramm heruntergeladen. Wechseln Sie in der Shell-Konsole zu Downloads und ändern Sie die Berechtigungen, um die Datei ausführbar zu machen, und führen Sie sie aus\n$ cd ~/Downloads $ chmod +x ./qinst-lite-linux-23.1std-991.run $ ./qinst-lite-linux-23.1std-991.run Die grafische Benutzeroberfläche des Installationsprogramms wird geöffnet und Sie können die entsprechenden Pakete auswählen. Wählen Sie die Pakete wie unten gezeigt aus (auf diesem System sind sie bereits installiert): Bitte überprüfen Sie, ob auf der Partition, auf der Sie die Software installieren möchten, etwa 20 GB Speicherplatz frei sind. Die Downloadgröße beträgt etwa 4,4 bis 5,0 GB.\nKlicken Sie dann auf den Download. Der Download und die Installation nehmen etwas Zeit in Anspruch, holen Sie sich also zwischendurch eine Tasse Kaffee. Nach Abschluss der Installation in Ihrer Konsole gehen Sie zur Installation – Sie haben sie wahrscheinlich in Ihrem Home-Verzeichnis oder unter /opt installiert – und führen den Shell-Befehl aus, um Quartus zu starten – oder klicken Sie einfach auf das Desktop-Symbol.\n$ cd intelFPGA_lite/23.1std/quartus/bin/ $ ./quartus Jetzt ist es an der Zeit, die CD aus dem DE-0-Nano-Board zu nehmen und ihren Inhalt auf Ihren Computer zu kopieren …​ Oder laden Sie sie einfach von hier herunter. (Sie müssen sich registrieren).\nNach dem Kopieren öffnen Sie das Projekt my_first_fpga. Sie sehen die verschiedenen Code-Teile in der Projektansicht links.\nDieses Tutorial ist im De0-Nano-Benutzerhandbuch auf den Seiten 40 bis 80 ausführlich dokumentiert DE0-nano-Benutzerhandbuch\nZitat aus dem Benutzerhandbuch (S. 44): Erstellen Sie ein Design, das die LEDs auf der Entwicklungsplatine mit zwei unterschiedlichen Frequenzen blinken lässt. Dieses Design ist einfach zu erstellen und gibt Ihnen visuelles Feedback, dass das Design funktioniert. Natürlich können Sie Ihr DE0-Nano-Board auch für andere Designs verwenden. Für das LED-Design schreiben Sie Verilog-HDL-Code für einen einfachen 32-Bit-Zähler, fügen eine PLL-Megafunktion (Phase-Locked Loop) als Taktquelle hinzu und fügen eine 2-Input-Multiplexer-Megafunktion hinzu. Wenn das Design auf dem Board läuft, können Sie einen Eingangsschalter drücken, um die Zählerbits zu multiplexen, die die Ausgangs-LEDs steuern.\nDie Ansicht unten zeigt die Quartus-Block-Designdatei (bdf) für das einfache Projekt my_first_fpga. Sie zeigt eine PLL-Megafunktion und eine (Bus-) Multiplexer-Megafunktion, die IP (=Intellectual Property von Altera/Intel) ist. Und dann gibt es eine Verilog-Datei, die unsere benutzerdefinierte Zählerlogik enthält, wie unten dargestellt.\n./simple_counter.v //It has a single clock input and a 32-bit output port module simple_counter ( CLOCK_50, counter_out ); input CLOCK_50 ; Ausgang [31:0] counter_out; reg [31:0] counter_out; always @ (posedge CLOCK_50) // bei positiver Taktflanke begin counter_out \u0026lt;= #1 counter_out + 1;// Zähler inkrementieren end endmodule // Ende des Moduls counter Und um die Pin-Zuordnung zu überprüfen, öffnen wir „Assignments \u0026gt;\u0026gt; Pin Planner“ image:../quartus_pin_assignment.png [Quartus Pin Assignment]\nJetzt können wir den Compiler ausführen – der sich bei der Hardware-Programmierung etwas von Software-Compilern unterscheidet –, aber darauf gehen wir in einem anderen Blogbeitrag ein.\nimage:../quartus_compile_report.png [Quartus Compile Report]\nAus dem Kompilierungsbericht geht hervor, dass eine von insgesamt vier PLLs verwendet wird. Ansonsten verbrauchen wir weniger als 1 Prozent der Ressourcen.\nBevor wir die Platine programmieren können, müssen wir zunächst die USB-Einstellungen unserer Distribution konfigurieren, wie unter hier\nGemäß „Driver Setup on RedHat Linux Enterprise 5 and Above“, das auch für Debian Buster/Bullseye gilt, erstellen wir als Root-Benutzer eine neue Datei /etc/udev/rules.d/51-usbblaster.rules\n# Intel FPGA Download Cable SUBSYSTEM==„usb“, ATTR{idVendor}==„09fb“, ATTR{idProduct}==„6001“, MODE=„0666“ SUBSYSTEM==„usb“, ATTR{idVendor}==„09fb“, ATTR{idProduct}==„6002“, MODE=„0666“ SUBSYSTEM==„usb“, ATTR{idVendor}==„09fb“, ATTR{idProduct}==„6003“, MODE=„0666“ # Intel FPGA Download Cable II SUBSYSTEM==„usb“, ATTR{idVendor}==„09fb“, ATTR{idProduct}==„6010“, MODE=„0666“ SUBSYSTEM==„usb“, ATTR{idVendor}==„09fb“, ATTR{idProduct}==„6810“, MODE=„0666“ Dann müssen wir Quartus beenden und den Computer neu starten, das USB-Kabel von Terasic einstecken und es mit Ihrer Platine verbinden.\nFühren Sie dann die folgenden Schritte aus, wie unter https://www.intel.com/content/www/us/en/support/programmable/support-resources/download/dri-quartus.html beschrieben.\nStarten Sie die Quartus® II-Software.\nWählen Sie im Menü „Tools“ die Option „Programmer“ aus. Das Fenster „Programmer“ wird geöffnet.\nKlicken Sie auf die Schaltfläche „Hardware Setup…​“, um das Fenster „Hardware Setup“ zu öffnen. Die ausgewählte Programmierhardware wird als „Aktuell ausgewählte Hardware“ angezeigt. Bereits eingerichtete Programmierhardware wird im Fenster „Verfügbare Hardwareelemente“ angezeigt. Klicken Sie auf die Schaltfläche „Hardware hinzufügen“, um das Fenster „Hardware hinzufügen“ zu öffnen, wenn die gewünschte Programmierhardware nicht im Fenster „Verfügbare Hardwareelemente“ aufgeführt ist. Wählen Sie das entsprechende Programmierkabel oder die entsprechende Programmierhardware aus der Liste „Hardwaretyp“ aus. Wählen Sie bei Bedarf den entsprechenden Port und die Baudrate aus. Klicken Sie auf „OK“. Wählen Sie die Programmierhardware, die Sie verwenden möchten, in der Liste „Verfügbare Hardwareelemente“ aus. Klicken Sie auf „Schließen“. Ihre Programmierhardware wurde eingerichtet. (Detaillierte Informationen zur Programmierung von Intel FPGA-Geräten finden Sie in der Quartus II-Hilfe.)\nJetzt können Sie die Platine mit der angegebenen sof (sram-Objektdatei) programmieren. Wie der Titel sram andeutet, handelt es sich hierbei um eine flüchtige Programmierung, die nach dem Ausschalten der Stromversorgung verloren geht.\nUns fehlt noch ein wichtiges Stück Software, nämlich die Simulationssoftware Modelsim. Wir zeigen dies in Zukunft\nModelsim Der Download-Link für Modelsim für Quartus ist hier angegeben.\nUm Modelsim auf einem Debian-System zu installieren, müssen einige 32-Bit-Bibliotheken installiert werden.\nFür Ubuntu und Debian lauten die Befehle wie folgt:\n$ sudo dpkg --add-architecture i386 $ sudo apt-get update $ sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32ncurses6 libxft2 libxft2:i386 libxext6 libxext6:i386 Anschließend muss die heruntergeladene Binärdatei ausführbar gemacht und ausgeführt werden\n$ cd ~/Downloads $ chmod +x ModelSimSetup-20.1.1.720-linux.run $ ./ModelSimSetup-20.1.1.720-linux.run Jetzt kann es verwendet werden (hauptsächlich müssen wir noch einige Dinge konfigurieren, damit es von Quartus aus gestartet werden kann). Als Nächstes erstellen wir einen einfachen Schaltkreis mit Testbench, damit der Simulator getestet werden kann.\nDer Simulator wird durch Ausführen von qhsim im Binärordner gestartet\n$ cd ../intelFPGA/20.1/modelsim_ase/bin $ ./qhsim Fortsetzung folgt…​\n"},{"id":7,"href":"/de/posts/web/19_rare_earth_elements/","title":"Die Geheimnisse der Seltenerdmetalle lüften: Der bemerkenswerte Fall von Neodym (de)","section":"Web","content":" Einführung Seltene Erden, die oft von Geheimnissen umwoben sind, spielen in unserer modernen Welt eine entscheidende Rolle. Von Smartphones über Elektrofahrzeuge und Technologien für erneuerbare Energien bis hin zu Verteidigungssystemen sind diese Elemente die unbesungenen Helden, die unser tägliches Leben nachhaltiger, effizienter und vernetzter machen. In diesem Artikel tauchen wir in die faszinierende Welt der Seltenen Erden ein, wobei der Schwerpunkt auf dem vielseitigen Element Neodym liegt.\nSeltene Erden: Ein Überblick Seltene Erden (SE) sind eine Gruppe von siebzehn chemischen Elementen, die zusammen mit Scandium und Yttrium die Lanthanidenreihe des Periodensystems bilden. Trotz ihres Namens sind sie nicht unbedingt selten, aber sie kommen typischerweise in geringen Konzentrationen vor, was ihre Gewinnung und Reinigung schwierig und kostspielig macht.\nDie Bedeutung der Seltenerdelemente liegt in ihren einzigartigen Eigenschaften, die sie für verschiedene High-Tech-Anwendungen unverzichtbar machen. Zu diesen Eigenschaften gehören magnetisches Verhalten, Lumineszenz und katalytische Aktivität, wodurch die Seltenerdelemente für die Entwicklung modernster Technologien unverzichtbar sind.\nLernen Sie Neodym kennen: Ein Star unter den Seltenerdelementen Neodym, mit der Ordnungszahl 60 und dem chemischen Symbol Nd, ist eines der herausragenden Mitglieder der Seltenerdfamilie. Es hat sich seinen Platz im Rampenlicht aufgrund seiner bemerkenswerten magnetischen Eigenschaften verdient. Neodym-Magnete, auch als NdFeB-Magnete (Neodym, Eisen und Bor) bekannt, gehören zu den stärksten und kommerziell bedeutendsten Permanentmagneten . Diese kleinen, aber leistungsstarken Magnete werden in einer Vielzahl von alltäglichen Anwendungen eingesetzt.\nAnwendungen von Neodym-Magneten. Elektronik: Neodym-Magnete sind die treibende Kraft hinter vielen elektronischen Geräten. Sie werden in Festplatten, Kopfhörern und Lautsprechern verwendet und sorgen für klare und beeindruckende Klangerlebnisse. Elektrofahrzeuge: Elektromotoren in Fahrzeugen werden oft von Neodym-Magneten angetrieben. Diese Magnete machen Elektrofahrzeuge effizienter und nachhaltiger, indem sie die Motorleistung steigern und gleichzeitig den Energieverbrauch senken..\nErneuerbare Energien: Windturbinen sind auf Neodym-Magnete angewiesen, um effizient Strom zu erzeugen. Die leichten und leistungsstarken Neodym-Magnete ermöglichen kleinere, energieeffizientere Turbinen, die die Windkraft effektiv nutzen. Medizinische Geräte: Neodym-Magnete werden aufgrund ihrer starken magnetischen Eigenschaften in verschiedenen medizinischen Geräten, einschließlich MRT-Geräten und zahnmedizinischen Geräten, eingesetzt .\nGrüne Technologien: Neodym spielt eine entscheidende Rolle bei der Entwicklung grüner Technologien, wie z. B. energieeffizienter Beleuchtung und regenerativer Bremssysteme in Hybrid- und Elektroautos.\nDie Herausforderungen der Neodym-Produktion Neodym ist für unsere moderne Welt zwar unverzichtbar, seine Gewinnung ist jedoch mit ökologischen und geopolitischen Herausforderungen verbunden. Der Großteil des Neodym-Angebots weltweit stammt aus China, was zu Bedenken hinsichtlich der Sicherheit der Lieferkette und der Umweltauswirkungen von Bergbau und Verarbeitung führen kann.\nUmweltbedenken ergeben sich aus dem Abbau, bei dem schädliche Chemikalien und Abfallstoffe anfallen. Dies erfordert nachhaltigere Verfahren und die Entwicklung von Recyclingmethoden, um unsere Abhängigkeit vom Neodym-Abbau zu verringern.\nFazit Seltene Erden, darunter Neodym, sind die stillen Helden, die unsere Hightech-Welt antreiben. Von den Bildschirmen unserer Smartphones bis hin zum leisen Summen von Elektrofahrzeugen – diese Elemente machen unser Leben effizienter und umweltfreundlicher . Da wir weiterhin auf Neodym und andere Seltenerdelemente angewiesen sind, ist es unerlässlich, nachhaltige Produktions- und Recyclingmethoden zu erforschen, um ihre Verfügbarkeit für zukünftige Generationen sicherzustellen. Neodym mit seinen bemerkenswerten magnetischen Eigenschaften ist ein Beweis für das immense Potenzial von Seltenerdelementen bei der Gestaltung unserer modernen Welt.\n(Verfasst in Englisch von chatgpt 3.5, Korrekturgelesen: Sven Wehrend, Autor der Website, Übersetzung Deepl)\n"},{"id":8,"href":"/de/posts/web/20_reducing_rare_earth_elements/","title":"Verringerung der Abhängigkeit von seltenen Erden: Die Suche nach alternativen magnetischen Materialien (de)","section":"Web","content":" Einleitung Seltene Erden sind seit langem das Rückgrat von High-Tech-Magneten, wobei Metalle wie Neodym und Dysprosium in verschiedenen Branchen eine entscheidende Rolle spielen. Die Knappheit und die steigende Nachfrage nach diesen wertvollen Ressourcen haben jedoch Forscher dazu veranlasst, nach alternativen Lösungen zu suchen. Um unsere Abhängigkeit von Seltenerdmagneten zu verringern, erforschen Wissenschaftler innovative Materialien und Legierungskombinationen. Zu den vielversprechenden Kandidaten gehört Cer, ein reichlich vorhandenes und leicht zugängliches Seltenerdelement, das das Potenzial hat, Neodym-Magnete zu ersetzen oder zu ergänzen. In diesem Artikel befassen wir uns mit der bahnbrechenden Forschung von Thomas Lograsso und seinem Team am Ames Laboratory des US-Energieministeriums.\nDie Herausforderung der Seltenen Erden Die steigende Nachfrage nach Seltenerdelementen in Verbindung mit der begrenzten Anzahl zuverlässiger Lieferanten hat zu Bedenken hinsichtlich zukünftiger Engpässe geführt. Geopolitische Faktoren, darunter die Dominanz Chinas auf dem Seltenerdmarkt, haben zusätzliche Herausforderungen mit sich gebracht. Um diese Probleme anzugehen, haben sich Forscher auf die Suche nach alternativen Materialien für starke Dauermagnete gemacht, die unsere Abhängigkeit von Neodym und anderen Seltenerdelementen verringern könnten.\nCer: Eine vielversprechende Alternative Forscher haben ihr Augenmerk auf Cer gerichtet, ein Seltenerdelement, das häufiger vorkommt und wirtschaftlich erschwinglicher ist. Um Cer in einen leistungsstarken Magneten zu verwandeln, begannen die Wissenschaftler mit der Erforschung paramagnetischer Materialien. Diese Substanzen werden schwach von Magnetfeldern angezogen, sind aber nicht permanent magnetisiert.\nThomas Lograsso erklärt: „Wir können solche Systeme im Wesentlichen rehabilitieren und sie durch Zugabe bestimmter Materialien in Magnete verwandeln .“ Dazu werden zunächst Legierungen oder Verbindungen verwendet, die die richtigen Eigenschaften besitzen, um bei Raumtemperatur ferromagnetisch zu werden. Aber welche Materialien erfüllen diese Anforderungen?\nIdentifizierung vielversprechender Kandidaten Um vielversprechende Kandidaten zu identifizieren, verwendeten Lograsso und sein Team einen computerbasierten Ansatz. Mit dieser Methode konnten sie das magnetische Verhalten einer Vielzahl von Materialien vorhersagen und ihre Eignung für Festkörpermagnete bestimmen. Die Ergebnisse dieses Ansatzes waren vielversprechend und zeigten das Potenzial, mit Materialien wie Cer-Kobalt (CeCo₃) durch Zugabe von Zusatzstoffen wie Magnesium leistungsstarke Magnete herzustellen. Nachfolgende Experimente bestätigten die Theorie und bewiesen die Umwandlung von Cer-Kobalt in einen Ferromagneten.\nEin weiterer vielversprechender Kandidat, der im Rahmen dieser Forschung identifiziert wurde, ist CeCo₅, ein Material, das bereits ein starker Ferromagnet ist. Berechnungen und Experimente haben jedoch gezeigt, dass die Zugabe von Kupfer und Eisen seine magnetischen Eigenschaften weiter optimieren könnte .\nEine nachhaltige und wirtschaftliche Lösung Diese Zusätze könnten den Weg für ceriumbasierte Materialien ebnen, die möglicherweise Seltenerdmagnete wie Neodym und Dysprosium ersetzen könnten. Der Vorteil besteht darin, dass Cer zur Familie der Seltenen Erden gehört, wodurch es leichter verfügbar und einfacher zu beschaffen ist als seine Pendants.\nLograsso betont: „Die Möglichkeit, die stark nachgefragten und knappen Seltenerdmetalle zu ersetzen, ist sowohl wirtschaftlich als auch ökologisch sinnvoll.“ Die modifizierten Cer-Kobalt-Verbindungen erreichen zwar noch nicht die Stärke der leistungsstärksten Seltenerdmagnete, könnten aber dennoch wertvolle Alternativen für bestimmte Anwendungen bieten.\nJenseits von Cer: Weitere Alternativen erforschen Die Forschung beschränkt sich nicht auf Lösungen auf Cer-Basis. Lograsso und sein Team experimentieren bereits mit alternativen Materialien, die nicht auf Cer oder anderen Seltenerdmetallen basieren. So arbeiten sie beispielsweise mit Kobalt, um Eisen-Germanium (Fe₃Ge) zu magnetisieren und das Potenzial dieser Materialien für Hochleistungsanwendungen zu erforschen.\nAngesichts der Herausforderungen durch die Knappheit der Seltenen Erden und die steigende Nachfrage wird die Suche nach alternativen Materialien wichtiger denn je. Die bahnbrechende Arbeit von Forschern wie Thomas Lograsso und seinem Team gibt Hoffnung, dass wir unsere Abhängigkeit von Seltenerdelementen verringern können, indem wir nachhaltigere und zugänglichere Lösungen für die Technologien bereitstellen, die unsere moderne Welt antreiben.\n(Verfasst von chatgpt 3.5, Korrekturlesen: Sven Wehrend, Quelle: https://www.scinexx.de/news/technik/alternative-magnete-gegen-den-rohstoffmangel/)\n"},{"id":9,"href":"/de/posts/web/18_op-amps_introduction/","title":"Operationsverstärker Einführung (de)","section":"Web","content":" OP-Amp Heute möchte ich über Operationsverstärker sprechen. Diese wunderbaren, aber geheimnisvollen Komponenten tauchen sehr häufig in Schaltplänen von analogen oder analog/digitalen Hybridschaltungen auf. Wir wollen diese Komponenten entmystifizieren.\nEs gibt zwei grundlegende Faustregeln für den Umgang mit idealen Operationsverstärkerschaltungen. (Reale Operationsverstärkerschaltungen sind etwas komplizierter, aber darauf kommen wir später zu sprechen).\nDie erste Faustregel besagt, dass Vout im Wesentlichen die Differenz der Spannungswerte an den beiden Eingängen ist, multipliziert mit einem beliebigen, aber hohen Verstärkungsfaktor A. \\[ V_{out} = A (V_{in+} - V_{in-}) = \\] kurz gesagt, dies führt zu\n\\[ V_{in+} = V_{in-}\\]\n2. Die zweite Faustregel besagt, dass es keinen Eingangsstrom gibt. Der nichtinvertierende Verstärker Der nichtinvertierende Verstärker ist einfach und leicht zu berechnen: Die Verstärkung A ist die Ausgangsspannung geteilt durch die Eingangsspannung, die wie folgt berechnet werden kann:\n\\[ A = \\frac{U_{out}}{U_{in}} = \\frac{R1 + R2}{R1}=1 + \\frac{R2}{R1}\\]\n\\[U_{in}= 5V; R_{1} = 100 k\\Omega; R_{2} = 100 k\\Omega \\]\n\\[ \\frac{U_{out}}{U_{in}} = 1 + \\frac{R2}{R1}\\]\n\\[ U_{out} = ( 1 + \\frac{R2}{R1}) \\cdot U_{in} = ( 1 + \\frac{100k\\Omega}{100k\\Omega}) \\cdot 5V = (1 + 1) \\cdot 5V = 10V\\]\n\\[ A = 2 \\]\nDer Spannungsfolger Ein Sonderfall des nichtinvertierenden Verstärkers ist der Spannungsfolger. Ein Spannungsfolger, auch Impedanzwandler genannt, wird verwendet, um eine Stufe von ihrer vorherigen Stufe zu puffern und zu entkoppeln. Er hat eine niedrige Impedanz am Eingang, aber eine hohe Impedanz am Ausgang. Dies wird verwendet, damit spätere Stufen die vorherigen Stufen nicht in Bezug auf die Spannung belasten.\nBild:../voltage-follower.svg[voltage-follower,width=„400px“]\nDer (invertierende) Gleichrichter Ein weiteres Beispiel für eine kleine Schaltung ist der Wechselrichter. Er lässt nur die negative Halbwelle eines sinusförmigen Wechselstroms durch.\nBild:../inverting_rectifier.png[inverting-rectifier,width=„800px“]\nBild:../inverting_rectifier_signal.png[inverting-rectifier-signal,width=„800px“]\nFortsetzung folgt…​\n"},{"id":10,"href":"/de/posts/web/17_analog_computers_101/","title":"Analoge Rechner Grundlagen (de)","section":"Web","content":" Analogrechner Heute möchte ich über Analogrechner sprechen. In der heutigen Zeit führen analoge Computer ein Schattendasein, verglichen mit ihren digitalen Gegenstücken. Aber sie sind wunderbare kleine Maschinen. Und diese Maschinen meine ich wortlich, denn es gibt analoge mechanische Computer, die Modelle aus der Welt sind und verwendet werden zur Berechnung und Vorhersage von Gezeiten in bestimmten Gebieten der Welt. Auch das Gehirn ist ein riesiger analoger Computer mit einem vergleichsweise sehr kleinen Energiebudget. Es braucht nur 12 Watt. 12 Watt, das ist nicht einmal ein Viertel des Stromverbrauchs eines Laptops von 65 Watt. Und man kann mit dem Gehirn sehr viel anstellen, aber zurück zum Thema. Ich möchte hauptsächlich über analoge elektronische Computer sprechen, die während des Zweiten Weltkriegs zur Berechnung von ballistischen Kurven verwendet wurden. Analogrechner können also summieren, multiplizieren, dividieren, integrieren und differenzieren wie ihre digitalen Gegenstücke.\nAufsummieren Um verschiedene Signale zu summieren, können wir einen Operationsverstärker in einer invertierten Schaltung verwenden, der die Signale an seinen Eingängen einfach aufsummiert. Da er invertiert ist, brauchen wir einen zweiten Operationsverstärker, der hinterher addiert, um das richtige Signal zu erhalten. um am Ende das richtige Signal zu erhalten. Die gleiche Schaltung wird als Mischschaltung für Audiosignale verwendet, von der ich auch das das Foto.\nMultiplizieren Um einen analogen Multiplizierer zu erstellen, wenden wir hier einen Trick an, indem wir die Eingangssignale in den logarithmischen Raum transformieren das Ergebnis aufsummieren und wieder in den linearen Raum zurücktransformieren. Mathematisch gesehen tun wir Folgendes\n\\[c= a*b = alog( \\log(a) + \\log(b))\\]\nUnten sehen Sie den entsprechenden Schaltplan: Die erste Stufe an den Eingängen sind beide logarithmische Verstärker, man sieht die Rückkopplungsdiode zwischen Ausgang und nicht-invertierendem Eingang. Dann sehen wir eine einfache Addierschaltung (ein invertierender Verstärker, mit einem Summenknoten davor). Und schließlich haben wir einen antilogarithmischen Verstärker, der die Signale in den linearen Raum zurückführt. Beachten Sie, dass der Ausgang tatsächlich invertiert ist und wir einen zusätzlichen invertierenden Verstärker benötigen, um das resultierende Signal zu korrigieren.\nBild:../analog_multiplier.png[analoger Vervielfacher]\nFortsetzung folgt…​\n"},{"id":11,"href":"/de/posts/synth/16_noise_floor/","title":"Eurorack Synthesizer - Noise Floor","section":"Posts","content":" On my mobile setup, the NiftyVCase I have collected my diy modules (with excepition to the Doepfer A-124, I had to include for its great sound). It features a kick-drum from erica synths, an even VCO, Sampling Modulator, A*B+C and Rampage from Befaco. As well as the Divebomb III for some delay. Last but not least a Zlon skew lfo and a BCM086 Diode Ladder High pass filter.\nnoise floor Audio\n"},{"id":12,"href":"/de/posts/synth/15_jam_session/","title":"Eurorack Synthesizer - Jam Session","section":"Posts","content":" This time, we have a convoluted patch, featuring a new member, the random sequencer from rat-king, which,as the name suggests, delivers nice randomly sequences. Also we have a new mixer module, self-build. We also utilize both VCOs and both LFO modules…​\njam session Audio\n"},{"id":13,"href":"/de/posts/synth/14_another_small_patch/","title":"Eurorack Synthesizer - Another small patch","section":"Posts","content":" So here is another small patch idea for the Doepfer A-100 system, this time featuring the SEM filter from Oberheim, incarnated in the Doepfer modul A-106-5. We also utilize two LFO modules…​\nLFO SEM Patch Audio\nLFO SEM Patch Audio 2\nLFO SEM Patch Audio 3\nTo this day I did not find the right audio recorder,and I am recording with my smartphone, so the sound quality is rather bad. I am still searching for the ideal recording hardware.\n"},{"id":14,"href":"/de/pages/short-introduction-to-electronics-102/","title":"Prequel: Introduction to electronics - 102","section":"Pages","content":" Elektronik 102 Zeitempfindliche Komponenten Nachdem wir im ersten Teil das wichtigste Bauteil, den Widerstand, betrachtet und ausführlich beschrieben haben Widerstand, im ersten Teil ausführlich beschrieben wurde, wollen wir uns nun das nächste wichtige Bauteil, den Kondensator, werfen. Kondensatoren sind ebenfalls passive Bauelemente, das heißt sie verstärken ein Signal nicht.\nElektrostatisches Feld Nimmt man zwei Metallflächen und stellt sie nebeneinander, mit einer kleinen dünnen Schicht einer nichtleitenden Substanz dazwischen, entsteht ein elektrostatisches Feld.\nDer Aufbau des elektrostatischen Feldes erfolgt über eine Gleichstromquelle, im Bild unten dargestellt durch den Generator G. Die Quellenspannung des Generators verschiebt die Elektronen, die sich im Draht und in den Metallplatten befinden. Auf diese Weise entsteht auf der rechten Platte ein Überfluss an Elektronen (-Q), während auf der anderen Platte ein Mangel der gleichen Menge, +Q, entsteht.\nFür kurze Zeit fließt ein Ladestrom mit dem Momentanwert i, der in umgekehrter Richtung eine Strommenge +Q fördert, eine Strommenge +Q fördert. Der Ladestrom i wird Null, wenn sich die Strommenge +Q und die -Q erzeugte Spannung gleich groß ist.\nDas elektrostatische Feld bleibt auch nach dem Trennen von der Gleichstromquelle bestehen, was sich mit einem einem Voltmeter mit hoher Impedanz überprüft werden kann: Das elektrostatische Feld entsteht durch die getrennten Ladungen +Q, -Q. Die vorhandene Spannung zeigt, dass in dem Feld Energie gespeichert ist. Diese Anordnung wird als Plattenkondensator bezeichnet.\nBild:../images/electronic_basics/electrostatic_field.svg[width=300]\nReferenz: Dieter Zastrow, Elektrotechnik,16.Auflage, S. 120. Es ist ein weiteres elektronisches Grundelement, das häufig in elektronischen Geräten verwendet wird. Die dazwischen liegende Substanz wird als Dielektrikum bezeichnet.\nKapazität Die Grundgleichung zur Berechnung der Kapazität, der Eigenschaft Nr. 1 eines Kondensators, lautet wie folgt. Die Kapazität C des Kondensators gibt das interessante Verhältnis zwischen der gespeicherten Ladungsmenge Q und der Ladespannung spannung U_c .\n\\[C= \\frac{Q}{U_c}\\]\nParallel- und Reihenschaltung Bei der Parallelschaltung von Kondensatoren addieren sich die Kapazitäten zur Gesamtkapazität.\n\\[C= C_{1} + C_{2} + …​ \\]\nBei der Reihenschaltung ist der Kehrwert der Gesamtkapazität gleich der der Summe der Kehrwerte der Einzelkapazitäten.\n\\[ \\frac{1}{C}= \\frac{1}{C_{1}} + \\frac{1}{C_{2}} + …​ \\]\nDer Kondensator und die Spulen Die nun vorgestellten Elemente haben einen Bezug zur Statik des (ohmschen) Widerstandes. Nun rückt auch die Zeit in den Fokus, denn sowohl Kondensator als auch Spulen sind in gewissem Sinne zeitempfindliche Elemente sind. Normalerweise würden wir also mit der Einführung des Kondensators mit all seinen Implikationen beginnen, und dann zu den Spulen übergehen, die die dann anschließend eingeführt werden. Stattdessen zeigen wir in diesem Beitrag beide in einer Gegenüberstellung da sie komplementäre Eigenschaften haben.\nLeiter\nSpule\nSchaltsymbol eines Kondensators\nSchaltsymbol einer Spule\nBild:../images/electronic_basics/capacitor.jpg[width=„300px“]\nBild:../images/electronic_basics/coil.jpg[width=„300px“]\nspeichert Energie in einem elektrischen Feld\nspeichert Energie in einem magnetischen Feld\nführt in Phase\nverzögert in Phase\nblockiert im Gleichstrombetrieb\nim Gleichstrombetrieb wächst der Strom, während die Spannung mit der gleichen Geschwindigkeit abgenommen wird\nFrequenzabhängige Netzwerke (Filter) Eine häufige und sehr beliebte Anwendung von Kondensatoren sind Filter, Einfache Filter erster Ordnung, wie hier gezeigt, werden aus einem Widerstand und einem Kondensator aufgebaut. Als nächstes wollen wir den Frequenzgang eines Filters berechnen Frequenzgang eines Filters berechnen, indem wir die Frequenzgangfunktion ermitteln, das ist die Ausgangsspannung geteilt durch die Eingangsspannung - Dies wird anhand der folgenden Beispiele deutlicher.\nTiefpassfilter Tiefpass 1. Ordnung\nFrequenzgang\n\\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{(1/j\\omega C)}{(R+ 1/j \\omega C)} = \\frac{(1/j\\omega C)\\cdot j \\omega C}{(R+ 1/j \\omega C) \\cdot j \\omega C } = \\frac{1}{1+ j\\omega RC } = \\frac{1}{1+ j \\omega/ \\omega_g}\\]\nGrenzfrequenz (mit Beispielwerten von R=1kOhm, C= 1µF)\n\\[ \\omega_g = \\frac{1}{RC} = \\frac{1}{1 \\cdot 10^3 \\cdot 1 \\cdot 10^6}= 10^3= 1000 \\cdot 1/s\\]\nUm das Bode-Diagramm für den oben gezeigten Tiefpass zu erzeugen, brauchen wir eine Hilfe, Dazu installieren Sie bitte matplotlib mit dem folgenden Befehl: \u0026#39;\u0026#39;\u0026#39; pip install matplotlib\nund führen sie folgendes Skript aus:\nimport matplotlib.pyplot as plt import numpy as np # Define the transfer function of a first-order low-pass filter def lowpass_first_order(frequency, cutoff_frequency): return 1 / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequency range for the Bode diagram (logarithmic scale) frequency = np.logspace(0, 6, 1000) # From 10^0 to 10^6 Hertz # Cutoff frequency of the low-pass filter cutoff_frequency = 1000 # Example value - You can set your own value here # Calculate the gain in decibels (20 * log10(Amplitude)) gain_db = 20 * np.log10(lowpass_first_order(frequency, cutoff_frequency)) # Calculate the phase response in degrees (angle) phase_deg = np.degrees(np.arctan(-frequency / cutoff_frequency)) # Create the Bode diagram with both gain and phase plt.figure(figsize=(10, 6)) # Gain plot (magnitude) plt.subplot(2, 1, 1) plt.semilogx(frequency, gain_db, label=\u0026#39;Gain (dB)\u0026#39;) plt.ylabel(\u0026#39;Gain (dB)\u0026#39;) plt.title(\u0026#39;Bode Diagram of a First-Order Low-Pass Filter\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phase plot plt.subplot(2, 1, 2) plt.semilogx(frequency, phase_deg, label=\u0026#39;Phase (degrees)\u0026#39;) plt.xlabel(\u0026#39;Frequency (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (degrees)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Save the Bode diagram as an SVG file plt.savefig(\u0026#39;lowpass_bode_phase.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optionally, display the Bode diagram plt.show() Hochpass-Filter Hochpass-Filter erster Ordnung\nFrequenzantwort\n\\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{R}{R+ 1/j\\omega C} = \\frac{j \\omega C}{1+ j \\omega RC} = \\frac{j\\omega / \\omega_g}{1+ j\\omega/ \\omega_g}\\]\nCutoff Frequenz (mit Beispiel Werten R=1kOhm, C= 1µF)\nUnd hier wieder ein Python Skript, diesmal für den Hochpass:\nimport matplotlib.pyplot as plt import numpy as np # Define the transfer function of a first-order high-pass filter def highpass_first_order(frequency, cutoff_frequency): return frequency / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequency range for the Bode diagram (logarithmic scale) frequency = np.logspace(0, 6, 1000) # From 10^0 to 10^6 Hertz # Cutoff frequency of the high-pass filter cutoff_frequency = 1000 # Example value - You can set your own value here # Calculate the gain in decibels (20 * log10(Amplitude)) gain_db = 20 * np.log10(highpass_first_order(frequency, cutoff_frequency)) # Calculate the phase response in degrees (angle) phase_deg = np.degrees(np.arctan(frequency / cutoff_frequency)) # Create the Bode diagram with both gain and phase plt.figure(figsize=(10, 6)) # Gain plot (magnitude) plt.subplot(2, 1, 1) plt.semilogx(frequency, gain_db, label=\u0026#39;Gain (dB)\u0026#39;) plt.ylabel(\u0026#39;Gain (dB)\u0026#39;) plt.title(\u0026#39;Bode Diagram of a First-Order High-Pass Filter\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phase plot plt.subplot(2, 1, 2) plt.semilogx(frequency, phase_deg, label=\u0026#39;Phase (degrees)\u0026#39;) plt.xlabel(\u0026#39;Frequency (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (degrees)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Save the Bode diagram as an SVG file plt.savefig(\u0026#39;highpass_bode_diagram.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optionally, display the Bode diagram plt.show() "},{"id":15,"href":"/de/posts/synth/13_another_simple_patch/","title":"Eurorack Synthesizer - Another simple patch","section":"Posts","content":" So here is another simple patch idea for the Doepfer A-100 system, this time featuring the SEM filter from Oberheim, incarnated in the Doepfer modul A-106-5. We also utilize two A-110 oscillator modules (one standard, one basic), and the LFO.\nSEM Patch Audio\nTo this day I did not find the right audio recorder,and I am recording with my smartphone, so the sound quality is rather bad. I am still searching for the ideal recording hardware.\n"},{"id":16,"href":"/de/posts/synth/11_more_patch_ideas/","title":"Eurorack Synthesizer - More patch ideas","section":"Posts","content":" So here is another patch idea for the Doepfer A-100 system. The results of the Doepfer oscillators are pithlily \u0026#34;knarzig-kernige\u0026#34; sounds. We utilize two A-110 oscillator modules (one standard, one basic), a ring-modulator (A-114) and a wasp-filter (A-124), together with some utility modules like a sequencer and an LFO.\npithily…​ Audio\n"},{"id":17,"href":"/de/posts/web/12_caches_and_caching/","title":"Zwischenspeicher und Zwischenspeichern (Caching)","section":"Web","content":" Wenn Sie Ihren Browser starten, um eine Website zu besuchen, haben Sie höchstwahrscheinlich einen sehr wichtigen Mechanismus nicht bemerkt, der dem Browser zugrunde liegt und im Hintergrund arbeitet. Caching. Caches werden überall eingesetzt, um Zugriffszeiten und damit die Gesamtleistung (einer Website) zu optimieren und zu verbessern. Caching im Browser bedeutet beispielsweise, dass im Idealfall nur die Teile der Website, die geändert wurden, aus dem Internet geladen werden. Alles andere wurde bereits zuvor geladen und hat sich nicht geändert, sodass kein erneutes Laden erforderlich ist. Nicht mehr aktuelle Teile werden ungültig (auch als Cache-Ungültigmachung bezeichnet) und erneut von der Quelle geladen. Es gibt zwei Arten von sehr unterschiedlichen Caches im Computer.\nHardware-Caches, echte physische Teile aus Silizium, die sich in der Nähe der CPU befinden, Software-Caches, die in der Anwendung bzw. den zugrunde liegenden Bibliotheken implementiert sind Die Art von Caches, die wir hier besprechen wollen, sind die letzteren.\nEs gibt mehrere verschiedene Caching-Strategien, siehe auch hier, aber wir wollen uns hier auf die Caching-Strategie „Last-recently-Used (LRU)“ konzentrieren. Die Python-Bibliothek „functools“ bietet einen Dekorator @lru_cache für diese Caching-Strategie. Bevor Sie den Dekorator @lru_cache jedoch gedankenlos verwenden, sollten Sie über das Problem selbst nachdenken, wie bereits erwähnt.\nEinfaches Beispiel aus der Python-Dokumentation:\nfrom functools import lru_cache @lru_cache(maxsize=None) def fib(n): if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) \u0026gt;\u0026gt;\u0026gt; [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] \u0026gt;\u0026gt;\u0026gt; fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) "},{"id":18,"href":"/de/posts/synth/09_eurorack_modular/","title":"Pocket Operator Modular 400 in eurorack","section":"Posts","content":" So I bought a low cost eurorack case from doepfer and a set of frontpanels plus power adapter for the pocket operator modular 400 from Oddvolt to put the said machine into a eurorack modular system. I also bought a small, but decent sequencer, since the one from teenage engineering is not very handy to use. I have two further modules on my list, the Doepfer A-119, an input module, as well as the Doepfer A-124, a wasp filter, to complete the setup.\nEurorack Modular…​ Video\n"},{"id":19,"href":"/de/posts/web/10_wishlist/","title":"Topics to write about - Wunschliste","section":"Web","content":" Dies ist eine kleine, unvollständige Liste von Themen, über die ich in der mittleren bis fernen Zukunft schreiben möchte.\nCaches\nInterrupts\nOut-of-Order execution\nRAW-, WAR- und WAW-Konflikte\nFilter (analog und digital)\nAnalogrechner\nneuronale Netze\ndas Makrobiom\n"},{"id":20,"href":"/de/posts/web/08_religion_spirituality/","title":"Religion vs. Spiritualität – warum ich Letztere bevorzuge","section":"Web","content":" Was ich in den letzten Jahren und Jahrzehnten über Religionen und Spiritualität gelernt habe, lässt sich auf eine einfache Aussage reduzieren: Bei Religion geht es um richtig und falsch und alte, überholte Dogmen, während Spiritualität einfach sagt: „Es ist, wie es ist“. Für Spiritualität gibt es kein richtig oder falsch, sondern nur den einen Moment in der Gegenwart, in dem wir verweilen. Ich finde diese Sichtweise ziemlich erstaunlich. Meiner Erfahrung nach führt sie zu einem wacheren Zustand.\n"},{"id":21,"href":"/de/posts/web/07_serial_interfaces/","title":"Warum gibt es überall serielle Schnittstellen – statt paralleler?","section":"Web","content":" USB, SPI, I²C, Sata – all diese Schnittstellen haben gemeinsam, dass es sich um serielle Schnittstellen handelt. Serielle Schnittstellen sind heutzutage weit verbreitet. Aber warum ist das so, insbesondere bei der Hochgeschwindigkeits- kommunikation? Es klingt einfach unlogisch: Parallele Drähte können theoretisch mehr Bits pro Zeit senden als ein einzelner Draht. Die Antwort auf diese Frage ist komplex und vielschichtig. Es gibt mehrere verschiedene Gründe, warum serielle Schnittstellen gegenüber parallelen Schnittstellen bevorzugt werden. Beginnen wir mit den offensichtlichen Gründen: Die Verdrahtung von Bussen mit einer Breite von 8, 16, 32 oder sogar 64 Bit auf Leiterplatten wird immer komplexer . Das zweite damit zusammenhängende Problem besteht darin, dass die Signalflanke gleichzeitig für alle parallelen Leitungen (Drähte) übertragen werden muss, was zu einer komplexeren Verlegung führt, da die Kanten in der Streifenleitung ausgeglichen werden müssen. Einfach ausgedrückt ist die zusätzliche Logik, die in Chips implementiert ist, um das serielle Signal wieder in ein paralleles umzuwandeln (Deserializer) und umgekehrt (Serializer), viel billiger als die Kosten für komplexe Verlegungen.\n"},{"id":22,"href":"/de/pages/overview2/","title":"How does a CPU work 2? Overview","section":"Pages","content":" Wie funktioniert eine CPU 2 - Inhaltsverzeichnis Von kombinatorischer zu sequentieller Logik - Einführung Einführung in sequentielle Logik\nWir gelangen von rein kombinatorischen Logikschaltungen ohne jegliche Form von Speicher zu sequentiellen Logikschaltungen mit irgendeiner Art von Speicher (meistens Flipflops)\nUhren, Flipflops und Register Uhren, Flipflops und Register\nWir machen einen Sprung in den Bereich der sequentiellen Logik und führen einige für die sequentielle Logik wichtige Konzepte ein, wie Uhr, Flipflops und Register\nAutomaten Automaten\nWir stellen die zwei (drei) verschiedenen Automaten Mealy, Moore (und Medwedjew) vor. Diese können synchron oder asynchron sein.\nCPU-Steuerung CPU-Steuerung\nHier sezieren wir das Gehirn einer CPU, die Steuereinheit, die alle Aktionen einer CPU handhabt und steuert.\nProgrammierbare Logik Programmierbare Logik\nWir stellen das Konzept der programmierbaren Logik sowohl für kombinatorische als auch sequentielle Logik vor.\nGründlich testen Testable Logic\nJede eingebettete Schaltung oder Logik benötigt eine Infrastruktur zum Testen. Hier stellen wir JTAG- und Boundary-Scan-Tests vor.\nHDLs VHDL und Verilog\nWir stellen das Konzept einer Hardwarebeschreibungssprache (HDL) wie VHDL und Verilog vor.\nExtra Register-Transfer-Level Register-Transfer-Level\nIn dieser Lektion stellen wir das Konzept des Register-Transfer-Levels vor.\n"},{"id":23,"href":"/de/posts/synth/06_pocket_operator_modular_400/","title":"The Pocket Operator Modular 400 patch ideas (II)","section":"Posts","content":" Plong…​ Video\nWith the random module we can sample \u0026amp; hold a signal from the input. Its companionship is the noise module. We feed the saw output to the input of the rand module.\nBeep,bleep…​ Video\nsine output → speaker right\nenvelope output → sine key\nLFO square → envelope trig\nLFO square → sine fm\nsweeping sinus…​ Video\nWe can expand the setup by using the sequencer and utilize the filter. Because the nice thing about modular synthesizers is, that the filter can be used not only in signal paths but also in control paths ;-) .\nfilter output → sine control\nsequencer output → filter input ---\n"},{"id":24,"href":"/de/docs/digital_logic_2/10_sequential_logic/","title":"10_sequential_logic (de)","section":"Digital Logic 2","content":" Sequentielle Logik Ergänzend zur kombinatorischen Logik enthält die sequentielle Logik eine Art Speicher, der das Verhalten zustandsabhängig macht. Wir müssen ihr ein Taktsignal zuführen.\nMealy- und Moore-Automaten (synchron) In der digitalen Logik gibt es zwei verschiedene Arten von endlichen Automaten. Diese sind:\nDer Mealy-Automat, der von der Eingabe und dem Zustand abhängig ist. Der Moore-Automat, der nur vom Zustand abhängig ist\nSynchrone und asynchrone sequentielle Logik Es gibt zwei verschiedene Arten sequentieller Logik: die synchrone sequentielle Logik mit einem zentralen Taktgeber sowie die asnychrone Logik mit mehreren Taktgeber-Domänen.\nWenn wir unserem oben gezeigten Automaten eine Taktgeberfunktion hinzufügen, wird der synchrone Automat zum asynchronen Automaten.\n(translation: 2024-12-29)\n"},{"id":25,"href":"/de/posts/synth/05_pocket_operator_modular_400/","title":"The Pocket Operator Modular 400 patch ideas","section":"Posts","content":" Ein analoger modularer Synthesizer war schon immer mein Traum, letzte Woche habe ich mir diesen Traum erfüllt und den Pocket Operator Modular 400 von der schwedischen Firma Teenage Engineering bestellt. Wie bei den Möbeln der anderen beliebten schwedischen Firma muss man ihn erst selbst zusammenbauen, bevor man damit einen Ton erzeugen kann. Das hat etwa 3 bis 4 Stunden gedauert. Aber es hat sich gelohnt.\nHier sind einige Patch-Ideen. Im ersten Beispiel mischen wir einfach die Ausgänge aller 3 Oszillatoren zusammen und steuern den Sinusoszillator mit dem Dreieckausgang des LFO und die Impulsbreite des Rechteckoszillators mit dem LFO-Rechteck.\nMixer-Ausgang → Lautsprecher rechts.\nSinus-Ausgang → Mixer 3.\nSägezahn-Ausgang → Mixer 2.\nRechteck-Ausgang → Mixer 1.\nSinus-Ausgang → Sägezahn FM.\nLFO Dreieck → Sinus-Steuerung.\nLFO Rechteck → Rechteck-PWM\nPOM 400 Video\nLink:../song_from_tibet.mp4[Song from Tibet Video]\nPlong…​ Video\n(Ich entschuldige mich für die schlechte Video- und Tonqualität, die Einrichtung wird verbessert.) Das Schöne an modularen Synthesizern ist, dass sie den traditionellen Signalweg von spannungsgesteuertem Oszillator (VCO), spannungsgesteuertem Filter (VCF) und spannungsgesteuertem Verstärker (VCA) durchbrechen und es ermöglichen, dass die gesamte Kreativität in experimentellen Setups gipfelt.\nMit dem Zufallsmodul können wir ein Signal vom Eingang abtasten und halten. Sein Begleiter ist das Rauschmodul. Wir speisen den Sägezahnausgang in den Eingang des Zufallsmoduls ein.\nBeep,bleep…​ Video\n\u0026#39;\u0026#39;\u0026#39;.\nSinus-Ausgang -\u0026gt; Lautsprecher rechts. Hüllkurvenausgang -\u0026gt; Sinustaste. LFO-Rechteck -\u0026gt; Hüllkurven-Trigger. LFO-Rechteck -\u0026gt; Sinus fm Sweeping Sinus…​ Video\nWir können das Setup erweitern, indem wir den Sequenzer verwenden und den Filter nutzen. Denn das Schöne an modularen Synthesizern ist, dass der Filter nicht nur in Signalpfaden, sondern auch in Steuerpfaden verwendet werden kann ;-) ..\nFilterausgang -\u0026gt; Sinussteuerung. Sequenzerausgang -\u0026gt; Filtereingang "},{"id":26,"href":"/de/posts/web/04_odoo_hacks/","title":"Odoo hacks: Entfernr Sperr-Button aus Odoo v12","section":"Web","content":" Heute möchte ich eine Lösung für ein Usability-Problem vorstellen, das ich kürzlich in Odoo hatte. In Odoo 12 gibt es neben der Schaltfläche „Bearbeiten/Speichern“ eine Schaltfläche zum Sperren, und Sie müssen auf beide klicken, um (1) die Seite zu entsperren und (2) sie bearbeitbar zu machen. Dies sollte in einem Schritt erfolgen, wodurch der Sperrmechanismus, der in den Lieferaufträgen (Klasse StockPicking) und Fertigungsaufträge (Klasse MrpProduction) verwendet wird. Die Lösung erfordert eine XML- und eine JavaScript-Datei sowie einen dedizierten Web-Controller. Die Lösung wird unten vorgestellt.\n/static/src/xml/trigger_toggle.xml \u0026lt;?xml version=„1.0“ encoding=„UTF-8“?\u0026gt; \u0026lt;openerp\u0026gt; \u0026lt;data\u0026gt; \u0026lt;template id=„assets_backend“ name=„trigger_toggle assets“ inherit_id=„web.assets_backend“\u0026gt; \u0026lt;xpath expr=„.“ position=„inside“\u0026gt; \u0026lt;script type=„text/javascript“ src=„/nm_data_stock/static/src/js/trigger_toggle.js“/\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/openerp\u0026gt; Der Code ist ziemlich selbsterklärend. Wir verwenden die XML-Datei, um das Skript hinzuzufügen. Vergessen Sie nicht, es in der Manifest-Datei hinzuzufügen. Die JavaScript-Funktionen _onEdit und _onSave sind Funktionen des Kern-Webclients (genauer gesagt web.FormController), und wir fügen beiden Funktionen eine einfache URL-Analyse und einen AJAX-RPC-Aufruf hinzu.\nstatic/src/js/trigger_toggle.js odoo.define(\u0026#39;nm_data_stock.trigger_toggle\u0026#39;, function(require){ \u0026#39;use strict\u0026#39;; var ajax = require(\u0026#39;web.ajax\u0026#39;) var FormController = require(\u0026#39;web.FormController\u0026#39;); var triggerButton = FormController.include({ _onEdit: function () { // wait for potential pending changes to be saved (done with widgets // allowing to edit in readonly) this.mutex.getUnlockedDef().then(this._setMode.bind(this, \u0026#39;edit\u0026#39;)); const url = new URL(this.$el.context.baseURI) const parsedHash = new URLSearchParams(url.hash.substring(1)) const id = parsedHash.get(\u0026#39;id\u0026#39;) const model = parsedHash.get(\u0026#39;model\u0026#39;) if (model.toString() == \u0026#39;mrp.production\u0026#39; || model.toString() == \u0026#39;stock.picking\u0026#39;) { console.log(\u0026#39;OnEdit \u0026#39;+ id + \u0026#39; \u0026#39;+ model); ajax.jsonRpc(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, \u0026#39;call\u0026#39;, {\u0026#39;id\u0026#39;: id,\u0026#39;model\u0026#39;: model,\u0026#39;button_state\u0026#39;: \u0026#39;edit\u0026#39;} ) } }, _onSave: function (ev) { ev.stopPropagation(); // Verhindern, dass x2m-Zeilen automatisch gespeichert werden var self = this; this._disableButtons(); const url = new URL(this.$el.context.baseURI) const parsedHash = new URLSearchParams(url.hash.substring(1)) const id = parsedHash.get(\u0026#39;id\u0026#39;) const model = parsedHash.get(\u0026#39;model\u0026#39;) if (model.toString() == \u0026#39;mrp.production\u0026#39; || model.toString() == \u0026#39;stock.picking\u0026#39;) { console.log(\u0026#39;OnSave \u0026#39;+ id + \u0026#39; \u0026#39;+ model); ajax.jsonRpc(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, \u0026#39;call\u0026#39;, {\u0026#39;id\u0026#39;: id, \u0026#39;model\u0026#39;: model,\u0026#39;button_state\u0026#39;: \u0026#39;save\u0026#39;} ) } this.saveRecord().always(function () { self._enableButtons(); }); }, }) }) Unten sehen Sie den Webcontroller als Endpunkt für den oben gezeigten AJAX-RPC-Aufruf…​\ncontrollers/main.py\nfrom odoo import http from odoo import api,fields from urllib import parse class ToggleController(http.Controller): @http.route(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, type=\u0026#39;json\u0026#39;, auth=„none“) def trigger_toggle(self, **kw): id = kw.get(\u0026#39;id\u0026#39;) model = kw.get(\u0026#39;model\u0026#39;) if model and id: print(model) obj = http.request.env[model].browse(int(id)) return obj.sudo().trigger_toggle(kw.get(\u0026#39;button_state\u0026#39;)) Zu guter Letzt die Implementierung in den beiden Klassen.\nmodels/stock.py\nclass StockPicking(models.Model): \u0026#34;\u0026#34;\u0026#34; Inherit class StockPicking from module stock. \u0026#34;\u0026#34;\u0026#34; def trigger_toggle(self, state): if state==\u0026#39;edit\u0026#39;: self.is_locked = False if state==\u0026#39;save\u0026#39;: self.is_locked = True class MrpProduction(models.Model): \u0026#34;\u0026#34;\u0026#34; Inherit class MrpProduction \u0026#34;\u0026#34;\u0026#34; def trigger_toggle(self, state): if state==\u0026#39;edit\u0026#39;: self.is_locked = False if state==\u0026#39;save\u0026#39;: self.is_locked = True "},{"id":27,"href":"/de/docs/digital_logic_x/x2_cordic/","title":"X2_cordic (de)","section":"Digital Logic X","content":" Der CORDIC-Algorithmus und die direkte digitale Synthese (DDS) Der CORDIC-Algorithmus (Abkürzung für „Coordinate Rotation Digital Computer“) wurde 1956 von Jack.E. Volder entwickelt, um die analogen Drehmelder, die für die Navigation von Raketen verwendet wurden, durch digitale Berechnungen auf einem Digitalcomputer zu ersetzen. Der Algorithmus erwies sich als sehr erfolgreich und ist heute in jedem Taschenrechner zu finden, wo er Berechnung der trigonometrischen Funktionen Sinus, Kosinus und Tangens. Der Algorithmus ist jedoch nicht darauf beschränkt, sondern kann nach den erforderlichen Änderungen auch logarithmische und exponentielle Funktionen berechnen.\nDer CORDIC-Algorithmus In der folgenden Abbildung zeigt V0 den Startvektor\n\\[v_{0}=\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\] die wir nun durch Multiplikation mit der unten angegebenen Rotationsmatrix iterieren:\n\\[v_{i+1}= R_i v_i\\]\n\\[ R_i = \\begin{bmatrix} cos(\\theta) \u0026amp; -sin(\\theta) \\\\ sin(\\theta) \u0026amp; cos(\\theta) \\end{bmatrix} \\] Wir verwenden die folgenden zwei trigonometrischen Identitäten:\n\\[ cos(\\theta) = \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\]\n\\[ sin(\\theta) = \\frac{tan(\\theta)}{\\sqrt{1+tan^2(\\theta)}} \\]\nwird die Rotationsmatrix zu\n\\[ R_i = \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\begin{bmatrix} 1 \u0026amp; -tan(\\theta) \\\\ tan(\\theta) \u0026amp; 1 \\end{bmatrix} \\]\nDann wird der Rotationsvektor $v_{i+1}= R_i v_i$ zu:\n\\[ \\begin{bmatrix} x_{i+1} \\\\ y_{i+1} \\\\ \\end{bmatrix} = \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\begin{bmatrix} 1 \u0026amp; -tan(\\theta) \\\\ tan(\\theta) \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} x_{i} \\\\ y_{i} \\\\ \\end{bmatrix} \\]\nWir ersetzen die Tangensfunktion durch einen einfacheren Ausdruck, was zu einer Bitverschiebung führt.\n\\[ \\begin{bmatrix} x_{i+1} \\\\ y_{i+1} \\\\ \\end{bmatrix} = K_{i} \\begin{bmatrix} 1 \u0026amp; -\\sigma 2^{-i} \\\\ \\sigma 2^{-i} \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} x_{i} \\\\ y_{i} \\\\ \\end{bmatrix} \\] wo\n(role=„image“,„../images/vector_rotation_Ki.svg“,imgfmt=„svg“, width=„70%“] \\[ K_{i} = \\frac{1}{\\sqrt{1+2^{-2i}}} ]\nund $\\sigma_i$ wird verwendet, um die Richtung der Drehung zu bestimmen. Wenn der Winkel $\\theta_{i}$ positiv ist, ist $\\sigma{i}$ +1, andernfalls -1.\nDer Faktor Ki kann für den iterativen Prozess vollständig faktorisiert werden.\n\\[ K(n) = \\prod_{i=0}^{n-1}K_{i} = \\prod_{i=0}^{n-1} \\frac{1}{\\sqrt{1+2^{-2i}}} \\]\n\\[ K = lim_{n→ \\infty} K \\approx 0,60725293500888 ]\n"},{"id":28,"href":"/de/posts/web/03_separate_form_and_content/","title":"Separiere Blog und Inhalt (de)","section":"Web","content":" Als der Blog immer größer wurde und nach dem Umzug zu Hugo, bemerkte ich eine Lücke im Workflow, da ein Blog und sein Inhalt selbst unterschiedliche Einheiten sind. Ich wollte sie als solche behandeln, was mich zu einer Bereinigung des ursprünglichen Quellcodes für den Blog führte, bei der ich den Inhaltsordner in ein anderes Repo namens hugo_content verschob, das frühere Repo nannte ich hugo_blog. ---\nIn meinem Fall bedeutet dies, dass Sie zuerst das Repo hugo_blog klonen müssen, in das neue Verzeichnis wechseln (cd hugo), seinen Zweig „hugo“ auschecken und dann einen Klon des Repos hugo_content erstellen.\nEdit / Update vom 31.12.2024: Idealerweise kann auch die config.toml in das Inhaltsverzeichnis gelegt und über hugo serve -c ../content/config.toml aufgerufen werden, aber das habe ich noch nicht gemacht …​\n"},{"id":29,"href":"/de/docs/digital_logic_x/x0_multiplication/","title":"X0_multiplication (de)","section":"Digital Logic X","content":" Multiplikation und Division Multiplikationsoperationen können auf sehr unterschiedliche Weise implementiert werden : Langsam, als serielle Operation, gesteuert durch ein Mikroprogramm oder schnell in dedizierter Hardware.\nDie Division ist eine komplexere Operation und wird daher in einem anderen Beitrag behandelt. Auch für die Multiplikation legen wir den Umfang auf vorzeichenlose Ganzzahlen fest.\nLinks- und Rechtsverschiebung Für Multiplikatoren, die Zweierpotenzen sind, ist die Operation sehr einfach und kann durch eine Linksverschiebung implementiert werden.\nEine Linksverschiebung um ein Bit entspricht einer Multiplikation mit 2, da eine Linksverschiebung um n Bits einer Multiplikation mit 2^n entspricht.\nEine Rechtsverschiebung ist eine Division durch 2, eine Rechtsverschiebung um n Bits ist eine Division durch 2^n\nDer Multiplikationsalgorithmus Natürlich sind wir nicht nur an dem Spezialfall von Multiplizierern zur Basis 2 interessiert, sondern wollen, dass die Multiplikationsoperation auf alle oben definierten Zahlen anwendbar ist. Wir beginnen mit einer seriellen Multiplikationsimplementierung.\nZunächst analysieren wir die Schritte einer binären Multiplikation, die sich offen gesagt nicht wesentlich von einer Multiplikation im Dezimalsystem unterscheidet und sogar noch einfacher ist. Wir multiplizieren 7 mal 6 im Binärsystem, was 42 ergibt.\nMultiplikand x Multiplikator = Produkt\n\\[ \\begin{aligned} 0111_2 \\times 0110_2 \\\\ \\hline 0000 \\\\ 011110 \\\\ 011100 \\\\ 0111000 \\\\ \\hline 0101010 \\\\ \\end{aligned} \\]\nWie wir anhand dieses Beispiels sehen können, ist die Multiplikation eine Abfolge von Verschiebung und Addition. Daraus können wir nun die Multiplikation zerlegen und daraus einen Algorithmus ableiten.\nFür Details verweisen wir auf die Originalquelle: Rechnerentwurf: Rechenwerke, Mikroprogrammierung, RISC von R. Hoffman, dritte Auflage, Oldenbourg Verlag.\nWir haben einen Multiplikator von X[n] und einen Multiplikator von Y[m], dann ergibt das Produkt der Multiplikationsoperation P[n+m], was bedeutet, dass die Größe der Operation logischerweise die Addition der Größe des Multiplikators und des Multiplikators ist.\nBooth-Algorithmus Der Booth-Algorithmus ist einer der effizientesten Algorithmen, da er, wie oben erwähnt, wiederum aus einer Reihe von Verschiebungen und Additionen besteht. Hier müssen jedoch die drei folgenden Regeln beachtet werden (siehe hier als Referenz): 1. Der Multiplikand wird vom Teilprodukt abgezogen, sobald die erste niedrigstwertige 1 in einer Folge von 1en im Multiplikator auftritt 2. Der Multiplikand wird zum Teilprodukt addiert, sobald die erste 0 (vorausgesetzt, es gab eine vorherige „1“) in einer Folge von 0en im Multiplikator auftritt. 3. Das Teilprodukt ändert sich nicht, wenn das Multiplikatorbit mit dem vorherigen Multiplikatorbit identisch ist.\nDer angewandte Booth-Algorithmus kann unter hier eingesehen werden: Implementierung der Hardware des Booth-Algorithmus und Flussdiagramm Der unten dargestellte Booth-Multiplikator besteht aus den Registern A, B für den Multiplikator und den Multiplikanden und Q für das Ergebnis. Das Register AC ist der Akkumulator, das Bitregister BR und das Register QR. Ein zusätzliches Flipflop Qn+1 wird zur Überprüfung des Multiplikators verwendet. Das Flussdiagramm ist unten dargestellt. Zunächst werden der Akkumulator und das Flipflop Qn+1 gelöscht und auf Null zurückgesetzt. Der Sequenzzähler SC wird auf die Anzahl der Bits n des Multiplikators gesetzt. Dann werden die beiden Bits in Qn und Qn+1 überprüft. Wenn diese 10 sind , wird der Multiplikand vom Teilprodukt im Akkumulator AC subtrahiert. Sind sie 01, wird der Multiplikand zum Teilprodukt im Akkumulator AC addiert. Sind die beiden Bits gleich (00,11), bleibt das Teilprodukt unverändert. Da die Subtraktion und Addition abwechselnd erfolgen, kann kein Überlauf auftreten. Im nächsten Schritt werden das Teilprodukt und der Multiplikator (plus Qn+1) nach rechts verschoben. Dies ist eine arithmetische Verschiebung (ashr), die AC und QR nach rechts verschiebt, sodass das Vorzeichenbit in AC unverändert bleibt. Der Sequenzzähler wird dekrementiert und die Berechnungsschleife wird n-mal wiederholt. Bei der Multiplikation negativer Zahlen müssen wir das 2er-Komplement finden, da es einfacher ist, zu addieren, als eine binäre Subtraktion durchzuführen.\n(translation 2024-12-31)\n"},{"id":30,"href":"/de/docs/digital_logic/00_combinatorial_logic/","title":"00_combinatorial_logic (de)","section":"Digital Logic","content":" (translation 2024-12-29)\nDieser Kurs über digitale Logik ist in zwei große Abschnitte unterteilt:\nKombinatorische Schaltkreise (ohne Speicherelemente)\nSequentielle Schaltkreise (mit Speicherelementen)\nWährend kombinatorische Schaltkreise aus booleschen Gattern bestehen, die ohne Rückkopplungsfunktion miteinander verbunden sind, besitzen sequentielle Gatter eine Speicherfunktion, die es ihnen ermöglicht, in einen anderen Zustand überzugehen.\nEin kombinatorischer Schaltkreis kann einen Vektor von Eingängen mit einer Breite von n und einen Vektor von Ausgängen mit einer Breite von m haben.\nKombinatorische Schaltkreise können auf verschiedene Weise beschrieben werden: als Formel, als Schaltkreis, als Wahrheitstabelle oder als Karnaugh-Diagramm. Alle diese Beschreibungen sind ineinander überführbar.\nBeginnen wir also mit den grundlegenden Logikgattern und der booleschen Algebra im nächsten Beitrag.\n"},{"id":31,"href":"/de/posts/web/02_moving-to-hugo/","title":"Umziehen zu Hugo (de)","section":"Web","content":" Seit einer Woche basiert mein Blog auf dem Static-Site-Generator Hugo. Ich wollte schon viel früher zu Hugo wechseln, da es eine große Auswahl an Themes gibt. Dies erforderte jedoch den Wechsel von Asciidoc zu Asciidoctor, und ich hatte einige Probleme mit der Integration von Asciidoctor in meinen bestehenden Arbeitsablauf. Da der Ansatz, die Latex-Gleichungen in den Asciidoc-Dokumenten darzustellen, nicht mehr funktionierte, entschied ich mich, auf die clientbasierte Darstellung von Formeln umzusteigen, wie sie in KaTex und Mathjax verwendet wird.\nUm Hugo, Asciidoctor und seine Abhängigkeiten ohne Kopfschmerzen zu installieren, nutzen wir wieder Docker und sein riesiges Ökosystem: Jemand hat bereits Docker-Images für Hugo mit integriertem Asciidoctor erstellt, sodass wir nicht die manchmal umständliche Einrichtung von Asciidoctor und seinen Abhängigkeiten durchlaufen müssen.\nWenn Docker installiert ist, führen wir in der Shell (für Linux und Mac OS, für Windows die Powershell) den folgenden Befehl aus:\ndocker pull klakegg/hugo:edge-asciidoctor Dies zieht ein Image mit der neuesten Hugo-Version und integriertem Asciidoctor aus dem Docker-Repo klakegg.\nWir navigieren zum übergeordneten Verzeichnis unseres Blogs und führen den folgenden Befehl aus:\ndocker run -it -v $(pwd):/src klakegg/hugo:edge-asciidoctor new site hugo/blog Dadurch wird das Grundgerüst unserer neuen Website erstellt, das wie folgt aussieht:\nold-blog hugo └── blog ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── static └── themes Wir haben noch kein Theme installiert, also gehen wir zu themes und wählen unser Lieblings-Theme aus, meines ist Book. Wir installieren es per einfachem Download oder über git:\ncd hugo/themes git clone https://github.com/alex-shpak/hugo-book und fügen die folgende Zeile hinzu:\ntheme = \u0026#34;hugo-book\u0026#34; zu unserer config.toml. Da wir gerade dabei sind, fügen wir auch die folgende Richtlinie, die seit Hugo-Version 0.91 erforderlich ist, zu unserer config.toml hinzu.\nBeispiel config.toml block\n[security] enableInlineShortcodes = false [security.exec] allow = [\u0026#39;^dart-sass-embedded$\u0026#39;, \u0026#39;^go$\u0026#39;, \u0026#39;^npx$\u0026#39;, \u0026#39;^postcss$\u0026#39;, \u0026#39;^asciidoctor$\u0026#39;] osEnv = [\u0026#39;(?i)^(PATH|PATHEXT|APPDATA|TMP|TEMP|TERM)$\u0026#39;] Jetzt müssen wir den Inhalt vom alten Blog in den neuen verschieben. Wir machen etwas Ähnliches wie hier:\ncp ../old_blog/pages ../hugo/content/docs cp ../old_blog/posts ../hugo/content/posts cp ../old_blog/images ../hugo/content/docs/images Jetzt müssen wir die adoc-Kopfzeilen in das Hugo-Frontmatter-Format konvertieren und auch die Asciidoc-Syntax an das neue Format anpassen. Damit unser neuer Blog die in Latex geschriebenen Gleichungen und Formeln verarbeiten kann, müssen wir das Skript für KaTex/Mathjax in eine Layout-Datei im Design unserer Wahl einfügen: KaTex integrieren\nUm zu sehen, was wir ändern müssen, führen wir den Hugo-Server aus und gehen im Browser zur angegebenen Adresse:\nhttp://localhost:1313\ndocker run -it -v $(pwd):/src -p 1313:1313 swehrend/hugo-ext-asciidoctor:edge-ext-debian server --renderToDisk Dies führt zu einem Ergebnis, das in etwa so aussieht:\nWenn wir mit dem Ergebnis zufrieden sind, können wir unsere Website mit einem rsync auf unserem Webspace bereitstellen, etwa mit dem folgenden Befehl:\nrsync -rav public/ wehrend@giclas.uberspace.de:/var/www/virtual/wehrend/html "},{"id":32,"href":"/de/docs/digital_logic/07_risc_v/","title":"07_RISC-V (de)","section":"Digital Logic","content":" Digitales Design trifft auf Computerarchitektur RISC vs. CISC und die RISC-V-Architektur Bestehende Prozessortypen können nach ihrem Befehlssatz klassifiziert werden: Computer mit reduziertem Befehlssatz (RISC), Computer mit komplexem Befehlssatz (CISC) und Mischformen. Während Miniprozessoren wie ARM für eingebettete Systeme meist reduzierte Befehlssätze verwenden , sind heutige Workstation- und Server-Architekturen (x86, x86_64) Mischformen aus RISC und CISC. Die Idee eines reduzierten Befehlssatzes besteht darin, große komplexe Anweisungen und mehrere unterschiedliche Adressierungsmodi (wie sie typischerweise in x86-Architekturen verwendet werden) zu vermeiden. Zu den Vorteilen einer RISC-Architektur gehören kürzere Pipelines, die eine schnellere Taktung ermöglichen. RISC-Architekturen folgen einem einfachen Schema: „Abrufen → Dekodieren → Operanden abrufen → Ausführen → Zurückschreiben“ Außerdem haben Anweisungen eine konstante Länge, Speicheroperationen sind von arithmetischen Operationen getrennt, was als Load/Store-Architektur bekannt ist. RISC-V ist ein offener Standard für die Befehlssatzarchitektur (ISA). Der größte Teil dieses Beitrags bezieht sich auf das beliebte Buch „Computer Organization and Design (RISC-V) Edition“ von Hennessey und Patterson.\nRISC-V Assembler Hier stellen wir den RISC-V Assembler vor. Die hier gezeigte Teilmenge ist etwas größer als die, die wir später implementieren werden. Zum Beispiel werden auch unmittelbare Anweisungen wie „addi“ angezeigt, die notwendig sind, um Konstanten in Register zu laden. Das unten gezeigte Beispielprogramm zählt von 0 bis 10 und verwendet dabei eine Schleife.\nADDI x2, x0, 1 ADDI x3, x0, 10 loop: ADD x1, x1, x2 SW x1, 4(x0) BNE x3, x1, loop HLT Registertyp: Anweisung [Zielreg] [Reg1] [Reg2]\nLade-/Speichertyp: Anweisung [Zielreg] [Byte-Offset(Reg1)]\nVerzweigungstyp: Anweisung [Zielreg] [Reg1] [Zielmarke]\nBei den Lade-/Speicheranweisungen enthält reg1 die Startadresse, während der Byte-Offset die Größe des in das Register geladenen Wertes (normalerweise 4) bzw. des in den Speicher geschriebenen Wertes enthält .\nNachfolgend finden Sie eine Übersicht über die Befehlsformate der verschiedenen Typen:\nEine minimale Implementierung Die minimal funktionierende Teilmenge einer RISC-V-Implementierung enthält die folgenden Anweisungen:\nArithmetisch-logische Anweisungen \u0026#39;add\u0026#39;, \u0026#39;sub\u0026#39;, \u0026#39;and\u0026#39; und \u0026#39;or\u0026#39; [Registertyp-Anweisungen]\nSpeicherreferenzanweisungen wie load word (lw) und store word (sw) [Speichertyp-Anweisungen]\nBedingte Sprungbefehle wie „Branch-if-equal (beq)“ [Verzweigungsbefehle]\nWir werden sehen, wie sich die gewählte Befehlssatzarchitektur auf leistungsbezogene Schlüsselaspekte wie Taktrate und Zyklen pro Befehl (CPI) auswirkt. Wir werden auch sehen, dass sich die verschiedenen Befehlstypen erst in den späteren Phasen des Fetch→Decode→ Execute-Zyklus unterscheiden\nDie ersten beiden Schritte sind bei jeder Anweisung identisch:\nDer Programmzähler (PC) zeigt auf den aktuellen Code, der ausgeführt wird. Die Adresse wird an den Speicher gesendet, um die aktuelle Anweisung aus dem Speicher abzurufen.\nLesen von zwei (eine für die lw-Anweisung) Registern, die Anweisungsfelder enthalten die Registernummern.\nDie nächsten Schritte hängen vom Befehlstyp ab, nutzen jedoch weiterhin dieselben Ressourcen. Beispielsweise wird die ALU von Register-Befehlen zur Datenberechnung verwendet, während sie auch von Speicher-Befehlen zur Adressberechnung und von Verzweigungsbefehlen für den Gleichheitstest verwendet wird. Erst nach dieser ALU unterscheiden sich die verschiedenen Befehlstypen wirklich.\nimage:../images/how_does_cpu/cpu_structure.svg\nWie wir sehen werden, erklärt das unten gezeigte abstrakte Schema nicht alle Fälle. Wir benötigen ein weiteres erweitertes Schema, das auch die Steuerteile zeigt.\nDer Fetch-Decode-Execute-Zyklus für die verschiedenen Befehlstypen Wir beginnen mit dem üblichen Fetch-Decode-Execute-Zyklus eines gewöhnlichen RISC-Prozessors und zeigen dessen Funktionsweise für typische Befehle.\nDer vollständige Zyklus ist: Fetch → Decode → Fetch Operands → Execute → Write Back\nTyp\nBeispielanweisung\nFetch\nDecode\nFetch Operands\nExecute\nWrite Back\nRegister\nadd, sub,and,or\nfetch instruction, increase PC by 4\nDecode instruction\nFetch operands from registers\nExecute calculation in ALU\nWrite value back to data memory.\nSpeichern\nlw,sw\nAbrufanweisung, PC um 4 erhöhen\nDekodieranweisung\nOperand\nAdresse berechnen\nDaten aus dem Speicher lesen/in den Speicher schreiben\nVerzweigung\nbeq\nAbrufanweisung, PC auf Zieladresse setzen\nDekodieranweisung\nOperanden aus Registern abrufen\nGleichheitstest (für beq)\nMultiplexer für Adressberechnung auf zweiten Addierer umschalten\nDer Anweisungsteil Um eine CPU auf dieser abstrakten Ebene zu erklären, müssen wir einige weitere Konzepte einführen, z. B. dass eine Anweisung, die im Speicher gespeichert ist, unter einer bestimmten Adresse zugänglich ist. Eine Adresse in RISC-V-Standards ist ein 32 Bit langer Wert, der auf eine bestimmte Zelle in einem Speicher-Array Der Program Counter (PC) ist ein Register, das auf eine bestimmte Adresse im Speicher/in der Registerdatei zeigt. Der Programmzähler ist mit dem ersten Adressaddierer mit einem konstanten Integer von 4 (dem Adressoffset, 4 * 1 Byte = 32 Bit) verbunden.\nWenn die Anweisung im Speicher eine adressmodifizierende Anweisung ist, wird der angegebene Wert vom zweiten Adressaddierer hinzugefügt. Auf diese Weise können wir Anweisungen zum Springen generieren.\nDer Datenpfad Der Datenpfad zeigt einige Elemente, mit denen wir bereits vertraut sind – die ALU – sowie Elemente, mit denen wir noch nicht vertraut sind – die Speicherblöcke – rechts die sogenannte Registerdatei und links der Datenspeicher. Beide Eingänge der ALU sind mit einem (anderen) Register verbunden.\nDer Steuerteil Der Steuerteil ist das Element mit der größten Blackbox. Wir wissen bereits, wie die Multiplexer funktionieren, und wir sehen bereits eine Rückkopplungsleitung für die Verzweigungssteuerung. Die meisten Elemente in dieser abstrakten Ansicht bleiben dem Leser jedoch unbekannt. Dies wollen wir ändern, indem wir uns das Ganze genauer ansehen.\n(translation: 2024-12-29)\n"},{"id":33,"href":"/de/docs/digital_logic/06_memory/","title":"06_Memory (de)","section":"Digital Logic","content":" Speicherorganisation In diesem Blogbeitrag stellt der Autor die verschiedenen Arten von Halbleiterspeichern vor. Dies ist ein weites Feld, daher besteht das Ziel hier darin, sich auf die wichtigsten zu konzentrieren und die Unterschiede zwischen den verschiedenen Arten herauszuarbeiten.\nDie Speicherhierarchie Da es bei der Datenverarbeitung immer um Leistung geht, werfen wir zunächst einen Blick auf die Speicherhierarchie. Wie Sie in der untenstehenden Pyramide sehen können, ist der Speicher in Schichten angeordnet. Die langsamsten Elemente – auch die mit der höchsten Latenz – befinden sich am unteren Ende dieser Pyramide, während die schnellsten an der Spitze dargestellt werden. Stellen Sie sich vor, Ihr Schreibtisch ist die eigentliche CPU, mit einem aufgeschlagenen Buch vor Ihren Augen. Dies ist das Register. Nun lesen Sie in diesem Buch einen Verweis auf ein anderes Buch in Ihrem Bücherregal. Ihr Bücherregal ist hier der Cache. Der Cache selbst ist wiederum in Schichten unterteilt. Nehmen wir an, L1-Cache ist das Bücherregal in Ihrem Zimmer, L2-Cache das Bücherregal in einem anderen Zimmer und L3-Cache Bücher, die in einer Kiste im selben Zimmer aufbewahrt werden. Wenn Sie nun eine Referenz in Ihrem aktuellen Buch (dem auf Ihrem Schreibtisch) haben, die auf ein Buch verweist, das Sie nicht besitzen, müssen Sie in die öffentliche Bibliothek gehen. Die öffentliche Bibliothek ist Ihr RAM. Die Zugriffszeiten sind sehr hoch. Und nehmen wir an, das Buch, das Sie benötigen, ist auch dort nicht verfügbar und muss aus einer Bibliothek in einer anderen Stadt bestellt werden. Dann kommen Sie auf die unterste Ebene, die Festplattenspeichereinheit.\nGanz unten befindet sich auch der günstigste Speicher (pro Byte). Je höher man in der Hierarchie steigt, desto teurer wird der Speicher. In diesem Artikel werden wir unser Wissen über den RAM erweitern. Caches sind komplexer und werden eventuell in einem zukünftigen Artikel behandelt .\nRAM und ROM Das folgende Bild zeigt die Gesamtorganisation einer RAM-Schaltung. RAM steht für Random Access Memory, also einen Speicher mit beliebigem Zugriff. Einfach ausgedrückt: Sie geben eine Adresse ein und erhalten die Daten, die unter der angegebenen Adresse gespeichert sind. Das hier gezeigte Schema gilt auch für den Nur-Lese-Speicher (ROM). Im Gegensatz zum ROM, das persistent ist, ist der RAM flüchtig. Er benötigt also eine kontinuierliche Stromversorgung, da er sonst seine gespeicherten Daten verliert.\nWie zu sehen ist, sind die Hauptbestandteile neben dem Speicher selbst der Spalten- und Zeilendecoder sowie der Lese-/Schreibverstärker. Der Adressdecoder besteht lediglich aus bekannter kombinatorischer Logik, während die Verstärker etwas komplexer sind. Die blauen Punkte an den Schnittpunkten von Zeilen und Spalten markieren die Positionen der Speicherzellen, die je nach Speichertyp unterschiedlich sind und im nächsten Abschnitt erläutert werden.\nDie verschiedenen Speicherzellen statischer RAM (SRAM)\ndynamischer RAM (DRAM)\nTransistor Nr. 4\nTransistor Nr. 1\nTransistor Nr. 6\nSRAM vs. DRAM Die statische RAM-Zelle (SRAM) hat den Vorteil, dass der gespeicherte Wert erhalten bleibt, solange die Stromversorgung nicht unterbrochen wird. Ihr klarer Nachteil ist der Schaltungsaufwand von mindestens 4 Transistoren (für ein nmos-Design), aber in der Regel 6 für ein cmos-Design. Das macht sie ideal für kleine Speicherbereiche wie Register und Cache, die sich in der Nähe der CPU befinden. Ergänzend dazu benötigt die dynamische RAM-Zelle (DRAM) nur einen Transistor und einen Kondensator, um den gespeicherten Wert zu halten, muss aber regelmäßig aufgefrischt werden.\nDie Registerdatei An dieser Stelle möchte der Autor die sogenannte Registerdatei vorstellen. Dabei handelt es sich um einen Speichertyp, der über mehrere Leseports verfügen kann. Dies ist nützlich als Eingabe für die ALU, die wir im letzten Blogbeitrag vorgestellt haben. Während die Anzahl der Leseports theoretisch unbegrenzt ist, beträgt die Anzahl der Schreibports in der Regel eins. Der Grund dafür ist, wie sich der aufmerksame Leser vorstellen kann, die Minderung von Gefahren, die bei mehreren Schreibports schwer zu handhaben sind.\n(translation: 2024-12-29)\n"},{"id":34,"href":"/de/docs/digital_logic_2/11_clocks_and_registers/","title":"11_Clocks_flipflops_and_registers (de)","section":"Digital Logic 2","content":" Taktgeber, Flipflops und Register In diesem Blogbeitrag stellt der Autor mehrere Elemente vor, die zu einem späteren Zeitpunkt benötigt werden .\nRegister-Transfer-Level benötigt eine Taktquelle Bisher haben wir nur die kombinatorische Logik kennengelernt, die ohne Taktquelle auskommt – jedes Signal wird nur um die Zeit verzögert, die es für die Übertragung durch den Schaltkreis benötigt. Dies wird als asynchron bezeichnet. Für anspruchsvollere Aufgaben, wie sequentielle Schaltkreise, sind jedoch Register erforderlich, die die Eingangs- und Ausgangssignale speichern, um korrekte Ergebnisse zu erzielen. Dies wird als synchron bezeichnet. Die meisten, wenn nicht sogar alle heutzutage verwendeten Designs sind synchron, da diese weniger komplex sind.\nRegister-Transfer-Level\nDie blauen Teile im Bild oben zeigen Register, in denen die Werte gespeichert werden. Wir werden später sehen, wie diese implementiert werden. Schauen wir uns zunächst die benötigte Taktquelle an.\nEs gibt verschiedene Möglichkeiten, eine Taktquelle zu erzeugen:\nEin Quarzoszillator\nEin Ringoszillator\nErsterer ist die klassische, letzterer eine modernere Variante.\nQuarzoszillator\nRingoszillator\ntypischer Frequenzbereich: 1Mhz..100Mhz\ntypischer Frequenzbereich: 1Hz..15Mhz(diskretes Layout)\nFrequenz wird durch Kristallgeometrie bestimmt\nFrequenz wird durch Laufzeit und Anzahl der Gates bestimmt\nGenauigkeit hängt hauptsächlich von der Temperatur ab; für präzise Anwendungen werden Kristallöfen verwendet\nGenauigkeit hängt hauptsächlich von der Stabilität der Stromversorgung ab\nDer Kristalloszillator Der Kristalloszillator ist eine Taktquelle, die auf einem Quarzkristall basiert. Die Frequenz hängt von der Geometrie des Quarzes ab. Quarzoszillatoren sind in einem Metallgehäuse mit zusätzlicher Verdrahtung erhältlich, wobei der Quarz das Herzstück des Schaltkreises bildet. Der Schaltkreis basiert in der Regel auf dem Pierce-Oszillator.\nIhre Genauigkeit hängt hauptsächlich von der Temperatur ab. Für Anwendungen mit hohen Genauigkeitsanforderungen werden sie daher in einem Quarzofen untergebracht, der den Quarz auf einer konstanten Temperatur hält. Eine interessante Zerlegung eines solchen Oszillators ist auf http://www.righto.com/2021/02/teardown-of-quartz-crystal-oscillator.html [Ken Shirriffs Blog] verfügbar.\nDer Ringoszillator Eine weitere gängige Taktgeberquelle ist der Ringoszillator. Der Trick besteht darin, eine ungerade Anzahl von Inverter-Gates zu verketten und den Ausgang des letzten Inverters als Eingang für den ersten Inverter zu verwenden. Auf diese Weise entsteht ein Schwingkreis.\nDie Frequenz hängt von der Anzahl der Inverter sowie von der Laufzeit Tp ab (siehe Gleichung unten). Die Zeit, die das Signal benötigt, um durch das Gate zu laufen, wird als Laufzeit Tp bezeichnet.\n\\[f_{ro} = \\frac{1}{2nT_{p}}\\]\nHier hängt die Genauigkeit hauptsächlich von der Stabilität der Stromversorgung ab. Ein Anwendungsbeispiel – z. B. die 8087, die Gleitkommaeinheit von Intel® – wird erneut von Ken Shirriffs Blog. Wie dort gezeigt, kann die Frequenz durch Hinzufügen eines RC-Netzwerks zwischen den Invertern verringert werden.\nDas klassische RS-Flipflop Das klassische Flipflop besteht aus zwei NAND-Gattern, deren Ausgänge an das komplementäre Gatter rückgekoppelt werden, wie in der folgenden Tabelle zu sehen ist. Unterhalb der Schaltung ist die Wahrheitstabelle angegeben. Wie zu sehen ist, sperrt das Flipflop den Ausgang auf einen Zustand, „1“ oder „0“. Wenn beide Eingänge auf „niedrig“ gesetzt sind, ist der Ausgang undefiniert (und entspricht der bevorzugten Position).\nRS-Flipflop-Struktur\nRS-Flipflop-Symbol\n̅R\n̅S\nQ\n̅Q\ncomments\n0\n0\n1\n1\ninvalid\n0\n1\n1\n0\nReset\n1\n0\n0\n1\nSetzen\n1\n1\nQ\nEine Anwendung des klassischen RS-Flipflops ist die Entprellung von Schaltern.\nFür die meisten Anwendungen ist jedoch ein weiterentwickeltes Flipflop erforderlich. Sehen wir uns das (D)ata-Flipflop an.\nDas D-Flipflop Beim D-Flipflop wird der Schaltung des RS-Flipflops zwei NAND-Gatter vorgeschaltet, die durch einen Taktimpuls gesteuert werden. Nur wenn der Takt hoch ist (d. h. „1“), ist das am (D)ata-Eingang anliegende Datum gültig und wird im RS-Flipflop gespeichert. Andernfalls ist das anliegende Datum ungültig.\nD-Flipflop-Struktur\nD-Flipflop-Symbol\nClock\nD\nQ\n̅Q\ncomments\n🠓 \u0026gt;\u0026gt;0\nx\nQ\n₯Q\nkeine Änderung\n🠓 \u0026gt;\u0026gt;0\n1\n1\n0\nZurücksetzen\n🠑 \u0026gt;\u0026gt;1\n0\n0\n1\nSetzen\n🠑 \u0026gt;\u0026gt;1\n1\nQ\n₯Q\n-\nEin Binärzähler Mit dem D-Flipflop, das wir im letzten Abschnitt kennengelernt haben, können wir einen (asynchronen) Binärzähler konstruieren. Dieser Ausgang kann als Adresse für eine ROM-Tabelle verwendet werden, wie wir in einem anderen Blogbeitrag sehen werden.\nAsynchroner Binärzähler mit D-Flipflops\nWenn man die Ausgänge unabhängig voneinander betrachtet, kann man sehen, dass der Zähler auch als Frequenzteiler funktioniert: Bei jedem Ausgang wird die Frequenz im Verhältnis zu der vorherigen durch zwei geteilt.\nRegister Was sind Register? Register werden verwendet, um Werte zu halten bzw. zu speichern. Jede heutzutage etwas komplexere CPU verfügt über eine große Anzahl von Registern. Die Registergrößen variieren stark je nach Anwendung. Sie reichen von Statusregistern, die nur ein Bit enthalten, über Register mit mehr als 32 und 64 Bit für reguläre Register bis hin zu Vektorregistern mit einer Größe von 64 Byte (= 512 Bit). Diese Register werden nach einem bestimmten Schema benannt Schema benannt, in einigen Architekturen mit Zahlen (z. B. MIPS und ARM), in anderen Fällen mit einem komplexeren Schema aus alphabetischen Zahlen (wie in x86-Architekturen).\nIn den vorherigen Abschnitten haben wir etwas über das Flipflop gelernt. Dies sind die Bausteine der Register. Wie im Bild oben zu sehen ist, wird jedes Flipflop mit demselben Signal getaktet. Wir werden auch oft den Begriff Akkumulator verwenden. Akkumulatoren sind Register, die gleichzeitig Quell- und Zielregister sind. So speichern sie z. B. bei einer Addition einen Eingabewert und halten das Ergebnis nach der Operation im selben Register.\n(translation: 2024-12-29)\n"},{"id":35,"href":"/de/docs/digital_logic/05_alu/","title":"05_ALU (de)","section":"Digital Logic","content":" Die ALU, das Schweizer Taschenmesser jeder CPU Heute möchte der Autor einen wichtigen Teil jeder CPU vorstellen: Die Arithmetisch-Logische-Einheit (ALU), von der wir bereits einige Funktionen kennen, die in den vorherigen Blog-Beiträgen vorgestellt wurden. In diesem Beitrag wollen wir die Lücken systematisch schließen. Zeit für eine kurze Zusammenfassung: Die Logikfunktionen \u0026#39;und\u0026#39;, \u0026#39;oder\u0026#39;, \u0026#39;nicht\u0026#39; und \u0026#39;xor\u0026#39; wurden vorgestellt, ebenso wie die arithmetischen Funktionen „add“ und „sub“ für ganze Zahlen. Nun wollen wir die meisten dieser Funktionen in einer Einheit zusammenfassen, der 1-Bit-ALU-Zelle.\nBild:../images/how_does_cpu/alu_symbol.svg[width=500]\nFunktion\nBeschreibung\nAinvert\nBinvert\nOperation\nund\na \u0026amp; b\n0\n0\n00\noder\na | b\n0\n0\n01\nadd\na + b\n0\n0\n10\nsub\na - b\n0\n1\n10\nslt\na \u0026lt; b\n0\n1\n11\nnor\na nor b\n1\n1\n00\nnand\na nand b\n1\n1\n01\nEine 1-Bit-ALU-Zelle Um die Dinge einfach zu halten, implementieren wir eine ALU für 1 Bit, die dann einfach durch Wiederholung an jede Bitbreite angepasst werden kann. Wir führen eine Implementierung ein, die von Hennessey und Peterson entworfen wurde und aus dem beliebten Buch „Computer Organization and Design (RISC-V) Edition“ von Hennessey und Patterson stammt.\nDie Implementierung unterstützt die grundlegenden Operationen „und“, „oder“, „addieren“ und „subtrahieren“. Wie wir bereits gelernt haben, kann die Subtraktion als Zweierkomplement realisiert werden: Invertieren des Eingangs B und Setzen des Übertragseingangs auf Eins.\nAufbau einer n-Bit-ALU Die 1-Bit-ALU-Zelle, die wir im ersten Abschnitt erstellt haben, kann mit einer n-Bit-ALU verkettet werden. Die letzte ALU-Zelle in der Kette unterscheidet sich ein wenig von der regulären Zelle, da sie auch einen Überlauferkennungsschaltkreis enthält. Wir werden später in diesem Artikel darauf zurückkommen.\nSet-less-than Wir wollen, dass die komplette ALU einen weiteren grundlegenden Befehl unterstützt: set-less-than (slt), der notwendig ist, um später Verzweigungsoperationen zu ermöglichen. Für diese Operation ist der zusätzliche Eingang „less“ vorgesehen. Die ALU unterstützt also eine Anweisung, die in C wie folgt aussieht:\n(a \u0026lt; b)? 1 : 0\nDies kann einfach durch Subtrahieren von b von a und Testen, ob der Wert kleiner als Null ist, implementiert werden. Bei der Implementierung erhält jede ALU-Zelle in der Kette mit Ausnahme des niedrigstwertigen Bits eine Null am Eingang „less“. Die erste ALU-Zelle erhält das Ergebnis der letzten Zelle, die das höchstwertige Bit darstellt. Da das höchstwertige Bit auch das Vorzeichenbit darstellt, können wir einfach eine Eingabe an das niedrigstwertige Bit weiterleiten und sind fertig. Dies ist jedoch nicht der Fall, falls die Subtraktion zu einem Überlauf führen könnte.\nAußerdem fügen wir ein NOR-Gatter mit Eingaben von allen Ergebnisbits hinzu, um eine Null zu erkennen.\nÜberlauferkennung Die letzte 1-Bit-ALU-Zelle in der Kette hat einen weiteren Ausgang „Überlauf“, um einen Überlauf bei der Addition von zwei Ganzzahlwerten anzuzeigen. Dies ermutigt den geneigten Leser, die Wahrheitstabelle und die Schaltung als Übung abzuleiten.\nBei einer Zweierkomplement-Interpretation tritt ein Überlauf in zwei Fällen auf:\nZwei positive Zahlen werden addiert, das Ergebnis wird negativ\nZwei negative Zahlen werden addiert, das Ergebnis wird positiv\nDie Wahrheitstabelle für den Überlauf sieht wie folgt aus (die Originalquelle finden Sie unter hier)\nBinv\na(n-1)\nb(n-1)\nc(n-1)\nOF\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n0\n1\n0\n0\n0\n0\n1\n1\n0\n0\n1\n0\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n0\n1\n0\n1\n1\n1\n0\n1\n0\n0\n0\n0\n1\n0\n0\n1\n0\n1\n0\n1\n0\n0\n1\n0\n1\n1\n1\n1\n1\n0\n0\n1\n1\n1\n0\n1\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n0\nDer von Logisim erzeugte Schaltkreis sieht dementsprechend aus wie folgt:\nMultiplexer und Demultiplexer\nUm eine Leitung aus mehreren Quellen auszuwählen, benötigen wir eine weitere Schlüsselkomponente, den Multiplexer. Multiplexer kommen an mehreren Stellen vor, in einer ALU werden sie jedoch zur Auswahl einer der logischen oder arithmetischen Operationen verwendet, wie wir später sehen werden.\nDer Demultiplexer – wie der Name schon sagt – hat die genau entgegengesetzte Aufgabe und verteilt das Signal auf einer Leitung (Eingang) auf einen von mehreren Ausgängen, je nach Auswahlbit(s).\nMultiplexer in komplementärer Pass-Transistor-Logik Wir zeigen und implementieren den Multiplexer in Pass-Transistor-Logik, da dies das ressourceneffizienteste Design ist…​\n"},{"id":36,"href":"/de/docs/digital_logic/04_signs/","title":"04_Signs (de)","section":"Digital Logic","content":" Erweiterung des Binärsystems Während wir im vorherigen Blogbeitrag über Addition die Binärzahlen nur eine Interpretation hatten, erweitern wir das System hier um negative (ganze) Zahlen.\nDer einfachste Ansatz, den wir uns vorstellen können, ist die Verwendung des höchstwertigen Bits (MSB) als Vorzeichenbit, wobei „0“ als Vorzeichen „+“ und „1“ als Vorzeichen „-“ interpretiert wird. Wie wir jedoch in der folgenden Berechnung sehen, funktioniert dies nicht wie erwartet:\nEinerkomplement Da der vorherige Ansatz die Anforderungen nicht erfüllt, wollen wir hier das Einerkomplement und das Zweikomplement einführen. Das Einerkomplement ist einfach eine Inversion jedes Bits, unabhängig von seiner Bedeutung.\n\\[ \\begin{array}{l} 00000011_{2} = +3_{10} \\\\ 11111100_{2} = -3_{10} \\end{array} \\]\nZweierkomplement Wie jedoch in der folgenden Tabelle zu sehen ist, gibt es bei der Addition immer noch eine Abweichung. Daher wird in einem zweiten Schritt die invertierte Zahl um eins erhöht. Dies führt uns zum sogenannten Zweierkomplement, wie unten dargestellt.\n\\[ \\begin{array}{l} 00000011_{2} = +3_{10} \\\\ 11111101_{2} = -3_{10} \\end{array} \\]\nWie in den folgenden Berechnungen zu sehen ist, erhalten wir mit dem Zweierkomplement die richtigen Ergebnisse.\nÜberlauf Wie in beiden Fällen zu sehen ist, wird sowohl beim Ein- als auch beim Zweierkomplement ein arithmetischer Überlauf erzeugt. Es hängt sehr stark von der CPU-Architektur ab, wie diese gehandhabt werden, aber in jedem Fall erhält man die Information als Flag (v).\nImplementierung der Subtraktion in einem Volladdierer Um den Volladdierer um die Logik für die Subtraktion zu erweitern, müssen wir nicht alles von Grund auf neu entwerfen. Die Eigenschaften des XOR-Gatters erlauben den ersten Schritt des Zweierkomplements, die Invertierung jedes Bits, während wir für den zweiten Schritt, die Inkrementierung, einfach die \u0026#39;1\u0026#39; des Subtraktionsschalters als Übertragseingang für die erste Volladdierer-Stufe verwenden.\nÜbersichtstabelle für den Zahlenbereich -7..+7 dezimal\nbinär\nein Komplement\nzwei Komplemente\n+7\n0111\n0111\n0111\n+6\n0110\n0110\n0110\n+5\n0101\n0101\n0101\n+4\n0100\n0100\n0100\n+3\n0011\n0011\n0011\n+2\n0010\n0010\n0010\n+1\n0001\n0001\n0001\n+0\n0000\n0000\n0000\n-0\n1000\n1111\n-\n-1\n1001\n1110\n1111\n- 2\n1010\n1101\n1110\n-3\n1011\n1100\n1101\n-4\n1100\n1011\n1100\n-5\n1101\n1010\n1011\n-6\n1110\n1001\n1010\n-7\n1111\n1000\n1001\n(translation 2024-12-29)\n"},{"id":37,"href":"/de/docs/digital_logic/03_binary_system/","title":"03_binary_system (de)","section":"Digital Logic","content":" Das Binärsystem Alle Computer, mit denen wir täglich arbeiten, wissen nichts von dem Dezimalsystem, das wir verwenden, basierend auf den zehn Ziffern, die uns zur Verfügung stehen. Alles, was sie wissen, sind die Zustände „an“ und „aus“. Wir bauen einen imaginären Schaltkreis mit einer Stromquelle, einer Kontrollleuchte – hier eine LED (Light Emitting Diode) – und einem Schalter, die Verbindung geschlossen wird, lässt das Licht blinken. Ein ausgeschaltetes Licht zählt als Null und ein eingeschaltetes Licht zählt als Eins. So einfach ist das. Wir schalten das Licht ein und erhalten eine Eins.\nJetzt erweitern wir diese Installation um eine zweite Lampe und schalten auf die aktuelle Lampe links um. Wir schalten die linke Lampe ein und die rechte ein. Als Ergebnis erhalten wir eine „2“. Wenn wir die rechte Lampe wieder einschalten, erhalten wir eine 3. Wie in unserem Dezimalsystem ist die Wertigkeit der linken Lampe höher (zumindest in unserem Beispiel), nur der Faktor unterscheidet sich, statt 10 ist der Faktor 2. Wir bezeichnen die Wertigkeit mit 2^n, wobei n die Position der Lampe ist. Jeder Schalter ist ein Bit – genauer gesagt ist der Schalter der Eingang und die LED der Ausgang. Mit vier Schaltern – einem halben Byte, auch Nibble genannt – können wir also von 0 bis 15 zählen, während wir mit acht Schaltern – einem Byte – von 0 bis 255 zählen können. Dieses Schema kann nach Bedarf erweitert werden.\nBinär\nHex\nohne Vorzeichen Interpretation\n0000\n00\n0\n0001\n01\n1\n0010\n02\n2\n0011\n03\n3\n0100\n04\n4\n0101\n05\n5\n0110\n06\n6\n0111\n07\n7\n1000\n08\n8\n1001\n09\n9\n1010\n0A\n10\n1011\n0B\n11\n1100\n0C\n12\n1101\n0D\n13\n1110\n0E\n14\n1111\n0F\n15\nEin einfacher Ripple-Carry-Addierer Lassen Sie uns einige einfache Berechnungen durchführen, um die notwendige Logik für eine Addierereinheit abzuleiten. Die Addition erfolgt wie in der Grundschule gelernt, nur dass wir diesmal Binärzahlen addieren. Das erste Beispiel funktioniert, während das zweite Beispiel neben dem (falschen) Ergebnis ein Übertrag-Flag erzeugt.\nSchema für kombinatorische Schaltkreise Wir entwickeln den RC-Addierer-Schaltkreis nach folgendem Schema, das zur Bewertung kombinatorischer Schaltkreise angewendet wird.\nEingänge und Ausgänge definieren . Wahrheitstabelle erstellen . Boolesche Gleichungen auswerten/vereinfachen . Optimierten kombinatorischen Schaltkreis zeichnen Wahrheitstabelle für Volladdiererzelle\nVolladdiererzelle\n[width=„100%“,cols=„3,3,3,0,3,3“,options=„header“] !=== ! c_in ! A ! B !! c_out ! sum ! 0 ! 0 ! 0 !! 0 ! 0 ! 0 ! 0 ! 1 !! 0 ! 1 ! 0 ! 1 ! 0 !! 0 ! 1 ! 0 ! 1 ! 1 !! 1 ! 0 ! 1 ! 0 ! 0 !! 0 ! 1 ! 1 ! 0 ! 1 !! 1 ! 0 ! 1 ! 1 ! 0 !! 1 ! 0 ! 1 ! 1 ! 1 !! 1 ! 1 !===\n\\[ \\begin{aligned} s \u0026amp; = (\\overline{c_{in}} \\land \\overline{A} \\land B) \\lor (\\overline{c_{in}} \\land A \\land {\\overline{B}}) \\lor (c_{in} \\land \\overline{A} \\land \\overline{B}) \\lor (c_{in} \\land A \\land B) \\\\ \u0026amp; = \\overline{c_{in}}(\\overline{A} \\land \\overline{B}) \\lor (A \\land \\overline{B}) \\lor c_{in}\\overline{A} \\land \\overline{B}) \\lor (A \\land B \\\\ \u0026amp; = \\overline{c_{in}}(A \\oplus B) \\lor c_{in}(\\overline{A \\oplus B}) \\\\ \u0026amp; = A \\oplus B \\oplus c_{in} \\end{aligned} \\]\n\\[ \\begin{aligned} c_{out} \u0026amp; = \\overline{c_{in}}(A \\land B) \\lor c_{in}(\\overline{A} \\land B) \\lor c_{in}(A \\land \\overline{B}) \\lor c_{in}(A \\land B) \\\\ \u0026amp; = \\overline{c_{in}}(\\overline{A} \\land \\overline{B}) \\lor (A \\land \\overline{B}) \\lor c_{in}\\overline{A} \\land \\overline{B}) \\lor (A \\land B \\\\ \u0026amp; = \\overline{c_{in}}(A \\land B) \\lor c_{in}[(\\overline{A} \\land B) \\lor (A\\land \\overline{B}) \\lor A \\land B] \\\\ \u0026amp; = \\overline{c_{in}}AB \\lor c_{in}(A \\oplus B) \\lor c_{in}AB \\\\ \u0026amp; = (\\overline{c_{in}} \\lor c_{in})AB \\lor c_{in}(A\\oplus B) \\\\ \u0026amp; = AB \\lor c_{in}A \\oplus B \\end{aligned} \\]\nEin einfacherer Ansatz Anstelle der Schaltung einer Volladdierer-Zelle, bei der nur die beiden Eingangssignale ohne den Übertrag berücksichtigt werden, bewerten wir die Halbaddierer-Zelle.\nA\nB\nc_out\nsum\n0\n0\n0\n0\n0\n1\n0\n1\n1\n0\n0\n1\n1\n1\n1\n0\nWie wir sehen können, besteht der Halbaddierer nur aus den beiden Gattern \u0026#39;AND\u0026#39; und \u0026#39;XOR\u0026#39;. Zwei Halbaddierer und ein separates \u0026#39;OR\u0026#39;-Gatter für das Übertragssignal ergeben einen Volladdierer.\n\\[ \\begin{array}{c} c = x \\land y \\\\ s = x \\oplus y \\end{array} \\]\nCarry-Lookahead-Addierer Um die lange Verzögerung des Carry-Signals im RC-Addierer zu vermeiden, wurde der Carry-Lookahead entwickelt. Die Signale (g)enerate und (p)ropagate sind wie folgt definiert (wobei i der Index der Signifikanz ist):\n\\[ \\begin{array}{c} g_{i} = a_{i} \\land b_{i} \\\\ p_{i} = a_{i} \\lor b_{i} \\end{array} \\]\nAus diesen Hilfssignalen wird der nächste Übertrag berechnet:\n\\[ c_{i+1} = g_{i} \\lor c_{i} \\land p_{i} \\]\n\\[ \\begin{aligned} c_{1} \u0026amp; = g_{0} \\lor c_{0}p_{0} \\\\ c_{2} \u0026amp; = g_{1} \\lor (g_{0} \\lor c_{0}p_{0})p_{1} = g_{1} \\lor g_{0}p_{1} \\lor c_{0}p_{0})p_{1} \\\\ c_{3} \u0026amp; = g_{2} \\lor c_{2}p_{2} = g_{2} \\lor (g_{1} \\lor g_{0}p_{1} \\lor c_{0}p_{0}p_{1})p_{2} \\\\ \u0026amp; = g_{2} \\lor g_{1}p_{2} \\lor g_{0}p_{1}p_{2} \\lor c_{0}p_{0}p_{1}p_{2} \\\\ c_{4} \u0026amp; = g_{3} \\lor c_{3}p_{3} = g_{3} \\lor (g_{2} \\lor g_{1}p_{2} \\lor g_{0}p_{1}p_{2} \\lor c_{0}p_{0}p_{1}p_{2})p_{3} \\\\ \u0026amp; = g_{3} \\lor g_{2}p_{3} \\lor g_{1}p_{2}p_{3} \\lor g_{0}p_{1}p_{2}p_{3} \\lor c_{0}p_{0}p_{1}p_{2}p_{3} \\\\ \\end{aligned} \\]\nCarry-Lookahead-Addierer-Schaltung\nWie man sieht, steigt die Komplexität der Schaltung mit der Signifikanz. Die folgende Tabelle zeigt die Gesamtansicht dieser verschiedenen Addierer-Implementierungen. Natürlich ist das Thema Addierer viel umfassender als hier dargestellt, wir haben nur die Konzepte vorgestellt.\nRipple-Carry-Addierer\niamge:../images/how_does_cpu/fulladder_array.svg[width=„120%“]\nCarry-Lookahead Adder\nIm nächsten Blogbeitrag werden wir sehen, wie man den Zahlenbereich auf den negativen Bereich ausdehnt.\n"},{"id":38,"href":"/de/docs/digital_logic/02_xor/","title":"02_XOR (de)","section":"Digital Logic","content":" (translation 2024-12-29)\nXOR Da es viele wichtige Anwendungen für die Exklusiv-Oder-Operation (XOR) gibt, ist ihr ein eigener Blog-Beitrag gewidmet. Zwei der wichtigsten sind:\nXOR-Operationen werden häufig in einem Linear Feedback Shift Register (LFSR) verwendet. LFSR sind ein entscheidender Schritt in Scrambler/Descrambler, die in Sendern/Empfängern verwendet werden\nTeil eines Verschlüsselungsalgorithmus\nNicht zuletzt ein wichtiger Bestandteil eines Halbaddierers.\nDie Exklusiv-Oder-Operation xor, die auch als Antivalenz bezeichnet wird, wird als A ⊕ B = Q bezeichnet. Ihre Wahrheitstabelle ist unten dargestellt\nA\nB\nQ\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n0\nCMOS XOR\n# transistor: 12\nEinige Anwendungen Lineares Rückkopplungs-Schieberegister (LSFR) Wie oben beschrieben werden XOR-Gatter in linearen Rückkopplungs-Schieberegistern (LFSR) verwendet. LFSR werden häufig zur Testmustererzeugung verwendet. Der Autor hat ein einfaches Beispiel eines 3-Bit-LFSR ausgewählt, das in einem Whitepaper von Texas Instruments erwähnt wird.\nFür dieses Beispiel müssen wir einen großen Sprung machen und in den Bereich der sequenziellen Schaltkreise einsteigen. Dies sind Schaltkreise, die Rückkopplung nutzen. Das gewählte Beispiel erzeugt Testmuster nach dem Zufallsprinzip gemäß der folgenden Tabelle. Die Register werden mit dem Startwert 111 gespeist, nach 8 Taktzyklen wiederholen sich die Muster erneut. Echte Testmustergeneratoren haben natürlich eine viel höhere Bitbreite.\nCLK\nFF1\nFF2\nFF3\n0\n1\n1\n1\n1\n0\n1\n1\n2\n0\n0\n1\n3\n1\n0\n0\n4\n1\n0\n0\n5\n0\n1\n0\n6\n1\n0\n0\n7\n1\n1\n0\n8\n1\n1\n1\nHalbaddierer Im nächsten Blogbeitrag werden wir uns eingehender mit der Halbaddierer-Anwendung befassen. Der Halbaddierer besteht im Wesentlichen aus den beiden folgenden Gleichungen für die Summe (unter Verwendung des XOR) und den Übertrag (unter Verwendung eines einfachen UND).\n\\[ \\begin{array}{c} c = x \\land y \\\\ s = x \\oplus y \\end{array} \\]\n"},{"id":39,"href":"/de/pages/prequel-short-introduction-to-electronics/","title":"Prequel: Einführung in die Elektronik","section":"Pages","content":" Als ich gerade dabei war, den Implementierungsteil der Booleschen Algebra zu schreiben, die grundlegenden logischen Gatter, lief der Schreibprozess schnell aus dem Ruder und ich ertappte mich dabei, dass ich mehr über weniger zusammenhängende Themen schrieb Themen zu schreiben, wie z.B. die Erläuterung grundlegender elektronischer Komponenten und deren Implementierung auf Silizium, als über den eigentlichen Inhalt, hier soll der Platz für diese Ausflüge sein. Dies soll kein vollständiges Nachschlagewerk sein, eher eine Ergänzung zu bestehenden Literatur. \u0026#39;\u0026#39;\u0026#39;\nFreie Elektronen und elektrischer Strom Was ist Elektrizität? Grob gesagt ist es der Fluss von Elektronen in einem Leiter. Laienhaft ausgedrückt kann man sagen, Elektronen auf der äußeren Schale - auch Valenzband genannt - eines Atoms hüpfen vom Valenzband eines Atoms zum Nachbaratom. Elektrizität ist also im Wesentlichen die Bewegung von Elektronen durch Materie. In der praktischen Anwendung ist diese Materie ein Stromkreis, aber auch zum Beispiel die Blitzentladung auftritt, in diesem Fall kann die ionisierte Luft als (Kurz-)Stromkreis betrachtet werden.\nWir gehen atomar vor: Leitende Elemente…​ Die erste Gruppe von Elementen (oder Verbindungen), die wir hier vorstellen werden, sind die Leiter. Einige wichtige Vertreter dieser Gruppe sind die Elemente Aluminium und Kupfer die beide für elektrische Übertragungsleitungen und Stromnetze unverzichtbar sind. Wie die folgende Tabelle zeigt, verfügen beide Elemente über freie Elektronen auf ihrer Valenz Valenzschale freie Elektronen, die, wie oben beschrieben, benötigt werden, um den Elektronenwechsel von einem Atom zum anderen zu ermöglichen von einem Atom zum anderen und damit die Bewegung von Elektronen zu ermöglichen, was das Element (in seiner reinen Form) zu einem Leiter macht.\nNatürlich gibt es in der realen Welt mehrere Faktoren, die den hier vorgeschlagenen idealisierten Eigenschaften entgegenwirken hier vorgeschlagenen Eigenschaften entgegenwirken. So müssen wir unter anderem berücksichtigen, dass Metalle bei Kontakt mit Sauerstoff oxidieren mit Sauerstoff oxidieren, wodurch sich eine dünne, aber effektiv isolierende Schicht auf der Oberfläche des Metalls bildet, die einen guten Kontakt verhindert. Auf solche Effekte können wir später eingehen. Lassen Sie uns jetzt einfach mit dem Thema weitermachen…​\nconductor\natomic model of aluminium (13)\natomic model of copper (28)\nvalence shell / free electron(s): 3 (3)\nvalence shell / free electron(s): 1 (1)\n\\large \\[Q = N \\cdot (\\pm e)\\]\n\\large \\[I = \\frac{\\Delta Q }{\\Delta t}\\]\n…​und nicht so leitfähig Die zweite Gruppe von Elementen, die wir hier vorstellen wollen, sind Elemente, deren Leitfähigkeit (stark) von ihrem Reinheitsgrad und von Umgebungs Faktoren wie Temperatur abhängt. Die Vertreter dieser Gruppe werden als Halbleiter bezeichnet. Kohlenstoff und Silizium sind Beispiele, die im Periodensystem auftauchen. Der Autor hat diese beiden Elemente ausgewählt, da sie sehr interessante Eigenschaften haben in Bezug auf - aber nicht nur - die Leitfähigkeit. Dies ist auf die Anzahl der Valenzelektronen Elektronen auf der äußeren Schale.\nsemiconductor\natomic model of carbon (6)\natomic model of silicon (14)\nvalence shell / free electron(s): 4 (0)\nvalence shell / free electron(s): 4 (0)\nWarum also haben Kohlenstoff und Silizium trotz ihrer vier Elektronen auf der Valenzschale im Vergleich zu Kupfer so schlechte Leitfähigkeitseigenschaften auf der Valenzschale Elektronen?\nDie Antwort liegt in der einfachen Tatsache, dass sowohl Kohlenstoff als auch Silizium ein Gitter bilden, das alle Elektronen der Valenzschale verbraucht.\ncovalent bonding of carbon\ncovalent bonding of silicon\nsemiconductor\nSpannung und Potential Die folgende Tabelle zeigt die gebräuchlichen Symbole für Spannungsquellen. Auf der linken Seite ist eine ideale Spannungsquelle dargestellt, während auf der rechten Seite eine reale Spannungsquelle abgebildet ist. Wie Sie sehen können, ähnelt die reale Quelle einer Batteriezelle. Natürlich kann die Spannungsquelle von einer tatsächlichen Batteriezelle abweichen und wird auch meist nicht implizit dargestellt.\nideal voltage source\nreal voltage source\nEine ideale Spannungsquelle liefert eine Spannung mit einem bestimmten Wert.\nWie wir in den unten gezeigten Schaltplänen sehen können, ist eine Spannung einfach die Differenz zwischen zwei Potentialen. Im ersten Beispiel (links) wird der untere Knotenpunkt als Referenzpunkt gewählt, da er als Masse signalisiert wird. Die Spannung beträgt also 1,5 V für U_B0 bzw. 3 V für U_A0. Im Beispiel rechts hingegen wird der Übergang zwischen den Batteriezellen als Bezugspunkt und Masse gewählt. Die Potentialdifferenzen, die wir hier messen, sind: U_A0 = 1,5V und U_B0 =-1,5V. Übrigens werden solche Doppelstromversorgungen - allerdings mit einem Spannungsbereich von 12…​15V - oft für Anwendungen mit Operationsverstärkern verwendet.\nSingle power supply\nDual power supply\n\\large \\[U = \\phi_{1} - \\phi_{0}\\]\nDas nächste Bild zeigt die einfachste mögliche Schaltung: Eine Spannungsquelle mit einem Widerstand in Reihe. Physikalisch gesehen ist jeder Widerstand nur ein Wandler von elektrischer Energie in thermische Energie, also Wärme.\nWiderstände werden in der Regel in Schaltungen verwendet, um die Spannung auf den gewünschten Wert abzusenken, bzw. den Strom, der zwischen bestimmten Pfaden eines Schaltkreises fließt, zu begrenzen. Wir werden im nächsten Abschnitt mehr darüber erfahren.\nOhmsches Gesetz und Leitungswiderstand Übung: Widerstand messen Zur Durchführung der folgenden Übung benötigen Sie ein Spannungs- und ein Amperemeter (oder einfach zwei Multimeter), eine variable Spannungsquelle und einige Probedrähte aus verschiedenen Materialien, aber mit gleicher Länge und gleichem Durchmesser. Wenn Sie nicht über die entsprechenden Geräte verfügen, können Sie diese Übung theoretisch auch in Qucs oder LTspice simulieren.\nDa wir aber im Voraus die Parameter der zu messenden Probedrähte festlegen müssen messen wollen, torpediert dieser Ansatz gewissermaßen den Zweck der Übung, nämlich zu lernen, wie man eine indirekte Messung des elektrischen Widerstandes.\nSchließen Sie die Geräte wie in der Abbildung unten dargestellt an, wobei der Probedraht den Widerstand Rx darstellt.\nMessen Sie nun für jeden Draht die Spannung und den Strom und zeichnen Sie ein Diagramm mit der Spannung auf der x-Achse und dem Strom auf der y-Achse. Du wirst sehen, dass du für verschiedene Materialien ein lineares Diagramm erhältst, aber mit einer unterschiedlichen Steigung. Sie haben also eine Beziehung gefunden zwischen Spannung, Strom und Widerstand gefunden. Nachdem du die verschiedenen Drähte gemessen hast, kannst du auch Stift und Papier verwenden: Zeichne eine Linie mit Bleistift eine Linie ziehen oder eine kleine Fläche kritzeln. Verbinden Sie diese nun mit den Sonden der Messanordnung. Sie werden sehen, dass auch die Graphitspur wie ein Leiter wirkt - nicht optimal, aber ein Leiter.\nDiese Beobachtung führt uns zu der wichtigsten Formel, die Ihnen in einem Elektrotechnikkurs 101 begegnen wird, dem Ohmschen Gesetz.\n\\large \\[ R [\\Omega] = \\frac{U [V]}{I [A]}\\]\nWenn wir diese Gleichung in ihre einfacher zu interpretierende Form U = R-I umstellen, erkennen wir, dass der Spannungsabfall (U) am Widerstand dem Widerstandswert ( R) mal dem durchfließenden Strom (I) entspricht. Wir haben noch nicht über den Strom gesprochen und werden dies auf einen späteren Abschnitt verschieben. Wie in den Bremsen angegeben, ist die Einheit des Widerstands Ω.\nIn der folgenden Abbildung sind die Regeln für die Reihen- und Parallelschaltung von Widerständen dargestellt.\nBei der Reihenschaltung addieren sich die Werte einfach, wie wir es bei den Spannungsquellen gesehen haben, während für die Parallelschaltung dasselbe gilt, allerdings für den Leitwert G, der der Kehrwert des Widerstands R ist und in S(iemens) gemessen wird.\nSo haben wir herausgefunden, dass sich die Materialien in ihrer elektrischen Leitfähigkeit - dem Kehrwert des elektrischen Widerstands - unterscheiden einige sind gut (Leiter), einige sind ziemlich schlecht und unbrauchbar (Nichtleiter), aber dennoch nützlich als Dielektrikum, wie wir im nächsten Abschnitt sehen werden im nächsten Abschnitt sehen werden, und einige dazwischen. Wir müssen natürlich auch beachten, dass die Leitfähigkeit nicht nur vom Material selbst, sondern auch von seiner Geometrie abhängt (außerdem ist sie (außerdem ist sie von der Temperatur abhängig, aber darauf gehe ich hier nicht ein), Sie wissen ja, dass wir uns mit Physik beschäftigen. in diesem Zusammenhang ist die folgende.\n\\large \\[ R = \\frac{\\rho L}{A}\\]\nFür die gebräuchlichste Rechteckform - wie eine Leiterbahn auf einer Leiterplatte - ergibt sich die Fläche A aus Breite mal Höhe\n\\large \\[ R = \\frac{\\rho L}{A} = \\frac{\\rho L}{w \\cdot h}\\]\nDer Gesamtwiderstand eines Drahtes oder einer Leiterbahn auf einer Leiterplatte ist also abhängig vom spezifischen Widerstand ρ, der Länge des Leiters und der Fläche, die für die Leiterbahn verwendet wird. des Leiters und der für die Stromübertragung verwendeten Fläche ab. Logischerweise erhöht sowohl der spezifische Widerstand als auch die Länge des Leiters den Widerstand erhöhen, während die Fläche dem entgegenwirkt.\nWarum müssen wir das wissen?\nAn dieser Stelle werden Sie sich vielleicht fragen, warum es wichtig ist, dies zu wissen, wenn wir einfach einen Schaltplan unseres Heimwerkerprojekts erstellen und es mit diskreten Bauteilen auf einem Breakout-Board realisieren können - die Antwort ist ganz einfach die Skalierung - für dieses einfache Bastlerbeispiel mag das funktionieren, aber es fehlt die Skalierbarkeit, die Kosten und / oder die Zuverlässigkeit.\nJe weiter wir in der Skala nach unten gehen, desto wichtiger werden parasitäre Effekte - wir werden in den folgenden Abschnitten mehr darüber erfahren.\nWiderstandsmessung\nDie folgende Abbildung zeigt das Prinzip der Widerstandsmessung mit einem Digitalmultimeter - abgesehen vom Bereichsschalter. Auf der linken Seite haben wir eine Konstantstromquelle, in der Mitte den zu messenden Widerstand - oder Draht - und auf der linken Seite ein Voltmeter, das die Spannung misst. Wie bei der Konstantstromquelle ist der Gesamtstrom im Stromkreis bekannt, der Widerstand kann daraus mit der gemessenen Spannung skaliert werden.\nDer Widerstand Das elektrische Bauteil selbst gibt es in allen Formen und Größen, je nach Anwendungsbereich. der Miniaturwiderstand für die Aufbautechnik, der in allen höher integrierten elektronischen Geräten verwendet wird, der durchschnittliche 1/4-Watt-Widerstand auf Kohlebasis mit 5 Prozent Toleranz (im Bild unten mittig dargestellt) und die präziseren Metallfilmwiderstände mit 1 % Toleranz (blau, rechts im Bild). Es gibt Widerstände mit mechanisch einstellbarem Widerstand, die Potentiometer genannt werden (wie die links im Bild gezeigten). Andere Typen sind Varistoren, bei denen der Widerstand von der angelegten Spannung abhängt, und einige andere Typen wie NTC / PTC in Abhängigkeit von der Temperatur.\n////Erklären Sie Aufbau und Struktur von SMD-Widerständen////\n"},{"id":40,"href":"/de/docs/digital_logic/01_boolean_algebra/","title":"01_boolean_algebra (de)","section":"Digital Logic","content":" (translation 2024-12-29)\nBoolesche Algebra und logische Grundgatter Wir beginnen (die Reise) mit drei sehr grundlegenden logischen Funktionen (oder Operationen), die trotz ihrer Einfachheit bereits gültige Anweisungen einer regulären CPU sind:\nNICHT, UND und ODER\nLogische Funktionen – auch Operationen genannt, der Autor wird hier beide Begriffe synonym verwenden – können auf verschiedene Weise beschrieben werden. Am häufigsten werden sie implizit als Boolesche Gleichung beschrieben, sie können aber auch explizit in einer Wahrheitstabelle erklärt werden.\nEine Wahrheitstabelle ist eine Tabelle mit einer Spalte für jede Eingabe und einer Spalte für jede Ausgabe. Sie zeigt also die Ausgabe bzw. die Ausgaben der Funktion für alle möglichen Kombinationen von Eingaben. Sie kann auch Spalten mit Zwischenwerten enthalten.\nDie in dieser Lektion gezeigten Wahrheitstabellen sind im Allgemeinen sehr klein und zeigen nur Kombinationen von zwei Eingaben, obwohl alle Funktionen, die Eingaben verbinden, auf eine beliebige Anzahl von Eingaben erweitert werden können.\nBoolesche Gleichungen können in Wahrheitstabellen umgewandelt werden und umgekehrt. Später werden wir auch Karnaugh-Diagramme vorstellen, eine Möglichkeit, die Boolesche Logik auf grafische Weise zu optimieren.\nNOT Die Not-Operation, auch als Inversion bezeichnet, wird als \\[\\overline{A} = \\neg A = Q\\] bezeichnet\nA\nQ\n0\n1\n1\n0\nDie Not-Operation ist die einzige mit nur einem Eingang, sie kann nicht erweitert werden.\nDementsprechend ist die Gate-Level-Implementierung auch unter dem Namen Inverter bekannt. Trotz seiner scheinbar einfachen Funktionalität gibt es viel über den Inverter zu sagen, sowohl in Bezug auf die Logik als auch auf die Implementierung. Daher wird der Autor ihm in naher Zukunft einen eigenen Beitrag widmen.\nUND Die Und-Operation, auch als Konjunktion bezeichnet, wird als \\[A \\land B = Q\\] bezeichnet\nA\nB\nQ\n0\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n1\nODER Die Oder-Operation, auch als Disjunktion bezeichnet, wird als \\[A \\lor B = Q\\] bezeichnet\nA\nB\nQ\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n1\nObwohl die Boolesche Algebra an sich ein interessantes Gebiet ist, werden wir das Thema hier nur kurz streifen, gerade genug, um ein Gefühl dafür zu bekommen und zu verstehen, wie man mit Booleschen Formeln arbeitet.\nNote Wenn Sie an einer tieferen Betrachtung interessiert sind, die Induktion und Beweisführung bietet, verweise ich Sie auf die entsprechende Literatur (Quellen am Ende aufgeführt). Die Gesetze der Booleschen Algebra sind in der folgenden Tabelle aufgeführt:\nGesetz\n∧ (Konjunktion, UND-Operator)\n∨ (Disjunktion, ODER-Operator)\nKommutativgesetz\n\\[p \\land q = q \\land p\\]\n\\[p \\lor q = q \\lor p\\]\nAssoziativgesetz\n\\[p \\land (q \\land r) = (p \\land q) \\land r = pqr\\]\n[p \\lor (q \\lor r) = (p \\lor q) \\lor r = p \\lor q \\lor r\\]\nAbsorptionsgesetz\n\\[p \\land (p \\lor q) = p\\]\n\\[p \\lor (p \\land q) = p\\]\nDistributivgesetz\n\\[p \\lor (q \\lor r) = (p \\land q) \\lor (p \\land r) = pq \\lor pr\\]\n\\[p \\lor (q \\lor r) = (p \\lor q) \\lor (p \\lor r) = (p \\lor q)(p \\lor r)\\]\nneutrale Elemente\n\\[p \\land 1 = p\\]\n\\[p \\lor 0 = p\\]\nKomplementärelement\n[p ∧ Ωp = 0]\n[p ∨ Ωp = 1]\nReference\nHans-Jochen Bartsch\nTaschenbuch Mathematischer Formeln, 20. Auflage, S. 27- 28\nDie ersten beiden in der Tabelle genannten Gesetze, das Kommutativgesetz und das Assoziativgesetz, kennen Sie wahrscheinlich intuitiv oder aus der Schule.\nWie Sie sehen, kann jedes Gesetz sowohl auf Konjunktionen als auch auf Disjunktionen angewendet werden, ohne dass es Ausnahmen gibt.\nDas Kommutativgesetz besagt, dass die Reihenfolge der Variablen für die Operation neutral ist und vertauscht werden kann, ohne dass sich das Ergebnis der Operation ändert.\nDas Assoziativgesetz besagt, dass Klammern austauschbar sind. Konjunktionen können ohne Operator zusammengefasst werden.\nDas Absorptionsgesetz ist Ihnen wahrscheinlich nicht aus der Schule bekannt, da es nur in der Logik verwendet wird und in der Schulmathematik keine Entsprechung hat.\nDas Distributivgesetz wiederum ist aus der Schule bekannt. Es besagt, dass Variablen/Operationen außerhalb von Klammern auf alle Variablen in der Klammer angewendet werden müssen.\nDas Gesetz der neutralen Elemente ist wiederum etwas Besonderes in der booleschen Algebra. Die logische Eins entspricht „wahr“, und daher sind p und wahr gleich „wahr“, ebenso wie die logische Null „falsch“ ist und daher p oder falsch gleich p ist.\nDas Komplementärgesetz impliziert, dass es zu jedem Element (Variable) p ein komplementäres Element (Variable) p gibt, so dass die Konjunktion zu einer logischen Null führt, während die Disjunktion zu einer logischen Eins führt.\nAn dieser Stelle muss der Autor etwas weiter ausholen, da einige praktische Probleme auf elektrischer Ebene einige Überlegungen auf ihrer logischen Ebene erfordern: Auf der Implementierungsebene (für eine elektrische Implementierung) ist es eher ungewöhnlich, UND, ODER und NICHT direkt zu verwenden, stattdessen werden die inversen Funktionen NAND und NOR verwendet.\nNAND und NOR Die NAND-Operation wird als \\[\\overline{A \\land B} = Q\\] bezeichnet, während die NOR-Operation als \\[\\overline{A \\lor B} = Q\\] aufgeführt ist-\nNAND\nNOR\nWie Sie sehen können, sind die Ergebnisse für diese beiden Funktionen genau das Gegenteil ihres jeweiligen Komplements (NAND ⇐⇒ AND, NOR ⇐⇒ OR). In diesem Sinne empfiehlt der Autor dem Leser, die entsprechenden Wahrheitstabellen als Übung zu erstellen.\nDer De-Morgan-Satz Zusätzlich zu den oben eingeführten grundlegenden Axiomen gibt es den De-Morgan-Satz, den wir benötigen, um NAND und NOR einfach umzuwandeln. Der Einfachheit halber zeigen wir nur für zwei Elemente, aber der Satz ist unabhängig von einer beliebigen Anzahl von Elementen/Eingaben.\n\\[\\overline{p_1 \\land p_2} = \\overline{p_1} \\lor \\overline{p_2}\\]\nA\nB\n\\[\\overline{A}\\]\n\\[\\overline{B}\\]\n\\[\\overline{AB}\\]\n\\[\\overline{A} \\lor \\overline{B}\\]\n0\n0\n1\n1\n1\n1\n0\n1\n1\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n1\n0\n0\n0\n0\n\\[\\overline{p_1 \\lor p_2} = \\overline{p_1} \\land \\overline{p_2}\\]\nA\nB\n\\[\\overline{A}\\]\n\\[\\overline{B}\\]\n\\[\\overline{AB}\\]\n\\[\\overline{A} \\lor \\overline{B}\\]\n0\n0\n1\n1\n1\n1\n0\n1\n1\n0\n0\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n0\n0\n0\nJetzt sind wir endlich gerüstet, um mit dem elektrischen Teil/der Beschreibung fortzufahren.\nUmsetzung auf elektrischer Ebene Zunächst stellen wir einige gängige elektronische Komponenten und ihre Symbole vor, die in elektrischen Schaltplänen verwendet werden.\nDie Diode Wir beginnen unsere Reise mit einem vereinfachten Schaltkreisentwurf für „und“ und „oder“, der als verdrahtete Logik bezeichnet wird. Dieser Schaltkreisentwurf ist so einfach, dass es nicht einmal möglich ist, einen Inverter darin zu implementieren.\nverdrahtet und\nverdrahtet oder\n# diodes: 2\n# diodes : 2\nWie Sie sehen können, ist diese Schaltung nicht kompliziert – selbst Laien auf dem Gebiet der Elektronik sollten in der Lage sein, die wesentlichen Teile zu identifizieren – die Eingänge sind jeweils mit einer Diode verbunden. Eine Diode ist ein einfacher Halbleiter, der als Einweg-Strasse für elektrischen Strom fungiert. Halbleiter sind eine Gruppe von Materialien (hier sind aufgrund ihrer chemischen Eigenschaften nur Silizium und Germanium nützlich), nicht wirklich leitfähig, aber auch kein Isolator. Tatsächlich hängt die Leitfähigkeit des Materials von der beabsichtigten Verunreinigung seiner Kristallgitterstruktur mit Elementen der fünften Hauptgruppe ab, bei einem n(egativ)-dotierten Material bzw. der dritten Hauptgruppe für ein p(ositiv)-gepunktetes Material. Dieser Vorgang wird als Dotierung bezeichnet. Für den interessierten Leser hier ein Link zu allen physikalischen Hintergründen, die der Autor zu faul war zu wiederholen, da sie oft und besser bereits im Internet erklärt werden ;-) .\nAlles, was wir jetzt wissen müssen, ist, dass eine Diode aus einem Substrat (in den meisten Fällen heute Silizium) besteht, das auf der einen Seite n-dotiert und auf der anderen Seite p-dotiert wird, wodurch dazwischen ein pn-Übergang entsteht, der als Einwegbarriere fungiert: Elektronen können von der n-Seite zur p-Seite strömen, aber nicht umgekehrt.\nDie zweite Komponente der oben gezeigten Schaltkreise ist ein Widerstand, dessen einziger Zweck darin besteht, den fließenden Strom zu reduzieren. Für „wire-and“ ist er als Pull-up-Widerstand verdrahtet, während er für „wire-or“ als Pull-down-Widerstand verdrahtet ist. „Wire-and“ erreicht nur dann einen ausreichend hohen Pegel, wenn alle Eingänge einen hohen Pegel aufweisen. Ähnlich verhält es sich mit „wire-or“, das nur dann einen niedrigen Pegel aufweist, wenn keiner der Eingänge einen hohen Pegel annimmt. Um zu verhindern, dass Strom vom Pull-up-Widerstand zum Ausgang der vorherigen Schaltung (Draht und) bzw. Strom von einem Eingang zurück zum anderen Eingang (Draht-oder) fließt, sind die Dioden vorhanden.\nEin Problem dieser Anordnung, auf das wir definitiv irgendwann stoßen werden, ist, dass das Signal beim Fließen vom Eingang zum Ausgang abgeschwächt wird und es keine Möglichkeit gibt, das Signal wiederherzustellen, sodass der Signalpegel am Ausgang von der nachfolgenden Schaltung möglicherweise nicht richtig erkannt wird. An dieser Stelle möchte der Autor eine Anmerkung zu einem subtilen Detail in der Terminologie machen: Obwohl es oft als Verstärkung beschrieben wird, möchten wir hier festhalten, dass wir hier einen „intelligenten“ Signalverstärker wollen, der den Signalpegel des Eingangssignals erkennt und wiederherstellt, im Gegensatz zu einem „dummen“ Verstärker, der lediglich das Eingangssignal verstärkt.\nDioden sind also ein gutes Bauteil, z. B. nützlich, wenn Teile der Schaltung vor elektrostatischer Entladung geschützt werden sollen (ESD), doch für unsere Logik ist es nicht ausreichend.\nWas wäre, wenn wir ein Bauteil hätten, das das Signal verstärken kann, sodass wir Schaltkreise entwerfen könnten, die auch die Signalpegel damit wiederherstellen? Glücklicherweise gibt es ein solches Bauteil, das im nächsten Abschnitt vorgestellt wird.\nDer MOSFET-Transistor Der Transistortyp, den wir hier vorstellen und verwenden möchten, ist ein MOSFET (Metall-Oxid-Halbleiter-Feldeffekttransistor) – im Gegensatz zum klassischen Bipolartransistor. Wie der Name schon sagt, ist ein MOSFET ein Transistor (oder Halbleiter), bei dem der Laststrom durch die Stärke des elektrischen Feldes gesteuert werden kann, das am Gate-Eingang erzeugt wird\nDas obige Bild skizziert die Hauptstruktur eines MOSFET auf dem Silizium. Source und Drain sind beide mit einem eigenen n-Wannen-Substrat verbunden, während das dazwischenliegende Gate durch eine dünne Siliziumdioxidschicht isoliert ist. Es gibt einen vierten Anschluss, „Bulk“, der zum Substrat führt, in diskreten MOSFETs, die mit der Source verbunden sind, aber im Moment ist dieser nicht relevant. Hinter der Funktionsweise eines MOSFET steckt eine Menge komplexer Physik. Alles, was wir im Moment wissen wollen, ist, dass beim Anlegen einer Spannung an das Gate ein elektrisches Feld induziert wird, das einen Kanal zwischen Source und Drain erzeugt und den Elektronenfluss von Source zu Drain ermöglicht. Je höher die Gatespannung, desto größer (breiter) der Kanal, desto mehr Elektronen fließen (natürlich bis zu einer bestimmten Grenze). Und wenn die Gate-Spannung Null ist, ist auch der Kanal nicht vorhanden.\nNachfolgend sind häufig verwendete Symbole für MOSFETs, die in elektrischen Schaltplänen verwendet werden, sowie einige andere, die wir aufgrund des Kurses benötigen, dargestellt. Einige haben mehr als nur eines, insbesondere der MOSFET hat eine Reihe verschiedene Symbole, die die Unterschiede in der physischen Komponente widerspiegeln.\nMit dem eingeführten MOSFET-Element und einem einzelnen Widerstand, einem Element, das den Stromfluss reduziert, können wir direkt eine Inverterschaltung implementieren, wie in der obigen Abbildung dargestellt. Die Source ist mit der Erde verbunden und der Drain ist mit dem Inverterausgang und auch mit der Spannungsquelle über einen hochohmigen Widerstand verbunden. Das Gate ist der Eingang des Inverters. Wenn die Spannung am Gate niedrig eingestellt ist, leitet der MOSFET nicht und somit ist das am Ausgang verfügbare Potenzial ausreichend für eine logische Eins. Wenn eine Spannung an das Gate angelegt wird, wird der Drain-Source-Pfad des MOSFET leitfähig, das am Ausgang verfügbare Potenzial bricht zusammen und fließt über den Drain-Source-Pfad ab.\nAuf elektrischer Ebene hat der Inverter zwei verschiedene Aufgaben zu erfüllen\nAuffrischen des Signals (Pegel), das der Inverter von der vorhergehenden Schaltung erhält\nTatsächliches Invertieren des Signals\nEs gibt auch integrierte Schaltkreise, die als Puffer oder Treiber bezeichnet werden und ausschließlich der ersten genannten Aufgabe gewidmet sind. Wir werden dies in einem späteren Blogbeitrag/einer späteren Lektion besprechen. Hier wollen wir uns nur auf den logischen Teil des Invertierens des Signals konzentrieren, obwohl beide Funktionen gleich wichtig sind, weshalb sie in einem Schaltkreis kombiniert werden Schaltung kombiniert werden. Natürlich müssen die logischen Signale auch in anderen logischen Schaltungen – wie und und oder – aufgefrischt werden, aber in den meisten Fällen wird diese Aufgabe ausschließlich von diesen Inverterstufen erledigt, danach oder davor.\nIm Symbol wird die erste Aufgabe, das Auffrischen des Signals (Pegel), durch das Dreieck angezeigt, während der kleine Kreis die eigentliche Invertierungsfunktion kennzeichnet.\nNMOS NAND\nNMOS NOR\n# transistor: 2\n# transistor: 2\nJetzt wird klar, warum die Umkehrfunktion von UND und ODER auf Gatterebene einfacher ist als die ursprüngliche Funktion. Weil man anschließend eine Inverterschaltung hinzufügen muss, wodurch sich die Anzahl der Transistoren erhöht.\nEin großer Nachteil der Implementierung ist der hohe Stromverbrauch, der durch den Pull-up-Widerstand verursacht wird. Schauen wir uns an, ob es eine Möglichkeit gibt, dieses Problem zu lösen. Was wäre, wenn es einen Transistor mit der Bezeichnung PMOS mit einer komplementären Struktur gäbe – p-Wannen auf einem n-dotierten Substrat – für unsere bisher verwendete NMOS-Schaltung?\nWenn wir diese anstelle des Widerstands für den Pull-up-Pfad verwenden, können wir die Verlustleistung drastisch reduzieren. Wie Sie sich denken können, gibt es diese Technik, bei der beide Transistortypen kombiniert werden, und sie wird CMOS ( kurz für Complementary Metal Oxid Semiconductor) genannt.\nCMOS NAND\nCMOS NOR\n# Transistor: 4\n# Transistor: 4\nJetzt wird klar, woher die CMOS-Technologie ihren Namen hat: Wie wir in der Implementierung von NAND und NOR in der CMOS-Technologie sehen können, ist die obige P-Schaltung genau das Komplement der unteren N-Schaltung. Für den Inverter war diese Eigenschaft aufgrund der Symmetrie einfach nicht erkennbar. Aber wir können auch den Nachteil der CMOS-Technologie erkennen: Die Anzahl der Transistoren verdoppelt sich, was den Aufwand und die Komplexität des Herstellungsprozesses erhöht (komplexere Masken und Layouts, mehr Verarbeitungsschritte aufgrund unterschiedlicher Transistortypen, nmos und pmos auf einem Wafer) und der integrierten Schaltung als Endprodukt.\nDie Toolchain, der CMOS-Prozess und die damit verbundenen Technologien sind jedoch bereits seit Jahrzehnten weiter- entwickelt und ausgereift, sodass dies heute keine Rolle mehr spielt. Tatsächlich hat Google kürzlich sogar das SkyWater Open Source PDK 130 veröffentlicht, ein sogenanntes Process Design Kit, das Elektrotechnikern eine Tool (Chain) zur Verfügung stellt, um Designs für anwendungsspezifische integrierte Schaltkreise (ASICS) zu erstellen, die dann direkt mit einem 130-nm-Prozess hergestellt werden können. Mehr dazu gibt es unter hier auf Hackaday.\nDas war ein erster kleiner Einblick in die Boolesche Logik und ihre Implementierung auf Silizium. Natürlich steckt noch viel mehr dahinter als nur ein Referenzdesign, auch haben wir uns noch nicht mit ESD-Messungen und Schutzschaltungen für die Ein- und Ausgänge befasst.\nIm nächsten Beitrag werfen wir einen Blick auf die Exklusiv-Oder-Verknüpfung (XOR).\n"},{"id":41,"href":"/de/pages/overview/","title":"How does a CPU work? Overview","section":"Pages","content":" Wie funktioniert eine CPU - Inhaltsverzeichnis Einführung und Überblick Einführung und Überblick\nJedes Thema dieses Kurses ist in zwei Teile gegliedert:\nEin Teil über die mathematische Seite der digitalen Logik, idealerweise fast unabhängig von Implementierungsdetails und ein konkreterer Teil, der genau diese Details behandelt. Im konkreten Teil werden wir hauptsächlich die Implementierung auf einer elektrischen Ebene diskutieren, obwohl auch andere Lösungen möglich sind, die auf Fluiddynamik oder optische Gatter basieren. Die meisten Computer und Logikgatter basieren immer noch auf Elektronik und Halbleitertechnologie, und das wird sich auch mit Quantencomputing nicht ändern, das hauptsächlich an die Wahrscheinlichkeitstheorie gebunden ist bzw. diese ergänzt. Mit dem Quantencomputing werden sich jedoch die Grundlagen, die der Autor hier beschreibt, vollständig ändern.\nKombinatorische Logik Einführung in die kombinatorische Logik\nKurze Einführung in die kombinatorische Logik und ihre verschiedenen Beschreibungsmodelle.\nEin erster Blick auf die digitale Logik Boolesche Algebra, grundlegende Logikgatter und ihre Implementierung\nIn dieser Lektion werden wir Wahrheitstabellen und Boolesche Notation entdecken und etwas über De Morgans Gesetze lernen.\nAußerdem werfen wir einen Blick auf die grundlegendsten Logikgatter und warum sie in der Elektronik normalerweise nicht als solche implementiert werden, sondern sehen uns stattdessen NAND und NOR an.\nSie müssen wählen! Ein komplexes Gatter: XOR\nEine weitere CPU-Anweisung und als Randbemerkung und Vorbereitung auf das nächste Thema sehen wir uns das XOR-Gatter an. Wie in der ersten Lektion sehen wir uns zuerst den logischen Teil und dann seine Übersetzung in eine elektrische Implementierung an.\n01+01 = 10 Binärsysteme (Teil I) und kombinatorische Logik (Teil I)\nHier erklären wir das grundlegende Konzept des Zählens mit nur zwei verschiedenen Zuständen.\nAußerdem lernen wir, wie man zwei positive ganzzahlige Werte im Binärsystem summiert, leiten die für einen Volladdierer erforderliche Logik ab und tauchen in das Thema der kombinatorischen Logik ein.\nIm negativen Raum ist viel Platz Binärsysteme (Teil II) vorzeichenbehaftete Ganzzahlen\nZweiter Teil über das Binärsystem. In diesem Beitrag lernen wir Einser- und Zweierkomplement sowie Subtraktion.\nAddieren ist nicht alles Kombinatorische Logik (Teil II), eine einfache ALU\nWir wollen die erste Serie mit diesem zweiten Kapitel über kombinatorische Logik abschließen.\nWir werden den Addierer zu einer einfachen ALU erweitern.\nÜberblick, was als nächstes kommt Von kombinatorisch zu sequentiell\nIn diesem ersten Kurs haben wir einige Grundlagen der digitalen Logik gelernt. Aber all diese Beispiele verwenden nur statische Logik, uns fehlt noch ein Konzept, wie berechnete Werte gespeichert werden.\nWir müssen das Konzept von Registern und sequentieller Logik lernen. Dies wird das Hauptthema der zweiten Beitragsreihe sein.\nExtra Lass mich das nachschlagen Erster Blick auf Speicher und Look-Up-Tables (LUTs)\nIn dieser Lektion lernen wir, dass – im Prinzip – jede Form kombinatorischer Logik in „Software“ umgewandelt werden kann, indem man sie in den Speicher legt. In einem praktischen Beispiel werden wir zeigen, wie ein DDS-Sinuswellengenerator eine Look-Up-Table (LUT) verwendet, um den Sinus zu replizieren.\n"},{"id":42,"href":"/de/about/","title":"About","section":"Agenda","content":" Ein einfaches, statisches Blog, in dem ich über Themen wie Elektronik \u0026amp; Computer und - vielleicht - Philosophie schreibe.\nLieber Leser meines bescheidenen Blogs, ich bin Sven Wehrend, eine 1987 geborene Scanner-Persönlichkeit, die sich für ein breites Spektrum an verschiedenen Themen interessiert, das von Technik über Psychologie bis hin zu Spiritualität reicht.\nIch habe Technische Informatik an der HTW Berlin (Bachelor) und der TU Berlin (Master) studiert.\nImpressum und Addresse: Sven Wehrend Eythstrasse 20 12105 Berlin\nEmail: sven.wehrend[at]gmail.com\nÜbersetzt mit DeepL.com (kostenlose Version)\n"},{"id":43,"href":"/de/posts/web/01_writing-about-math-with-asciidoc/","title":"Über Mathematik schreiben mit Asciidoc (de)","section":"Web","content":" Beim Verfassen eines Blog-Beitrags, der Teil einer Reihe von Beiträgen ist, die in Zukunft veröffentlicht werden sollen, stellte ich fest, dass mir in Nikola einige Tools fehlten. Beim Hinzufügen mathematischer Formeln wurde mir klar, dass es keine Standardmethode gibt, um Bilder aus diesen mathematischen Formeln zu rendern und sie als Bild-Tags in den HTML-Code einzufügen. Stattdessen werden mathematische Formeln über JS verarbeitet, das ich auf meiner Website auf ein absolutes Minimum zu reduzieren versuche. Also begann ich, ein eher „quick-and-dirty“-Plugin zu implementieren, um genau diese Umwandlung durchzuführen, und zwar mit latex und dvipng oder dvisvgm. Dann stieß ich auf diesen Blogbeitrag , wo ich über asciidoc, geschrieben in Python, und seinen Nachfolger asciidoctor, geschrieben in Ruby, las, die verschiedene Anzeigeformate unterstützen. Ideal für den Inhalt, den ich im Sinn hatte. Also installierte ich das Nikola-Plugin asciidoc (das hauptsächlich ein Wrapper für die asciidoc-Binärdatei ist, die als Unterprozess aufgerufen wird) über\nnikola plugin -i asciidoc in meiner lokalen Umgebung installiert und meine Blogbeiträge zunächst halbautomatisch konvertiert, was aufgrund des Metadatenabschnitts von Nikola nicht die beste Idee ist, und dann manuell fortgesetzt. Nach einigen Frustrationen mit den Pfaden für den Latex-Filter in asciidoc funktionierte es.\nAls Beispiel für einen der zukünftigen Blogbeiträge hier wurden eine oder besser gesagt zwei mathematische Gleichungen auf diese Weise dargestellt:\n\\[ \\begin{array}{c} c = x \\land y \\\\ s = x \\oplus y \\end{array} \\]\nNur als Randbemerkung: Es beschreibt einen Halbaddierer.\nEdit Grammatik verbessert.\n"},{"id":44,"href":"/de/posts/web/00_setting_up_nikola/","title":"Ein statisches Blog aufsetzen mit Nikola (de)","section":"Web","content":" Ich habe Nikola vor einigen Monaten entdeckt, als ich nach einem einfachen statischen Website-Generator suchte, um mit minimalem Aufwand einen Blog einzurichten.\nUm die Sache etwas interessanter und gleichzeitig einfacher zu machen, werden wir Nikola in einem Docker-Container verwenden. Daher benötige ich hier ein fast grundlegendes Verständnis für Docker.\nErstellen Sie zunächst ein Verzeichnis auf unserem Host-System, in dem die Dateien gespeichert werden sollen, z. B. „blog“ in Ihrem Home-Verzeichnis.\nSie können inoffizielle Images mit der neuesten Version von Nikola wie folgt abrufen:\ndocker pull dragas/nikola und das Image ausführen, um eine (Bash-)Shell zu erhalten:\ndocker run -it --network=„host“ -v ~/blog:/nikola dragas/nikola Hier steht die Option „-it“ für „interaktiv“ – was sie zwar nicht tut, aber sie ist leicht zu merken, also lassen wir es so. Außerdem müssen wir unser Volume hinzufügen, eine Speicherressource, die vom Hostsystem und dem Docker-Container gemeinsam genutzt wird. Wir fügen also -v ~/blog für unseren Blog hinzu, der sich in unserem Home-Verzeichnis befindet (unter Linux, auf Windows-Systemen unterscheiden sich die Pfade). Außerdem müssen wir die Option --network=„host“ hinzufügen, da wir sonst nicht von unserem Host-System und damit von unserem Browser aus auf die Webseite zugreifen können. Wenn Sie interessiert sind, besuchen Sie Docker run\nHier können Sie die üblichen Bash-Befehle wie cd, ls, ps usw. ausführen. Sie können gerne testen und erkunden Grundlegende Bash-Befehle :-)\nNachdem Sie sich nun ein wenig mit dem System vertraut gemacht haben, können Sie ein grundlegendes Nikola-Projekt über Folgendes starten:\nnikola init Sie werden durch einige Fragen zu Ihrem Blog geführt. Als Ziel geben Sie einfach . ein.\nWir erstellen einen ersten Beitrag mit:\nnikola new_page -t „Hello World“ Schreiben Sie den Beitrag auf Ihrem Host-System in einem Editor Ihrer Wahl. Er befindet sich in blog/posts/hello-world.rst und wird dann mit:\nnikola build Um die Website zu testen, starten Sie den Testserver mit:\nnikola serve und öffnen Sie Ihren Browser auf http://localhost:8080 .\nDas ist cool, aber wir wollen jetzt sicher ein bisschen Styling und Anpassung vornehmen, da das aktuelle Aussehen ziemlich standardisiert ist. Der Autor bevorzugt einen schlichten und einfachen Stil ohne viel unnötigen Ballast. Also habe ich nach einem solchen Thema gesucht, aber sie waren nicht nach meinem Geschmack. Dann fand ich das Nikola port of Hyde\nDas Thema kann installiert werden mit:\nnikola theme -i hyde Nach der Installation musste das Thema in der „About“-Sektion der Seitenleiste angepasst werden. Daher weicht die hier gezeigte Version vom ursprünglichen Aussehen ab. Die Datei assets/css/hyde.css im Verzeichnis des frisch installierten Themas wurde angepasst. Idealerweise sollten die Änderungen in einer zusätzlichen Datei custom.css vorgenommen werden\nJetzt viel besser!\nWenn wir mit dem Ergebnis zufrieden sind, können wir unsere neue statische Website auf einem Webspace unserer Wahl bereitstellen. Dazu passen wir die Bereitstellungseinstellung in der Datei conf.py an. Dies kann wie folgt aussehen.\nDEPLOY_COMMANDS = { \u0026#39;default\u0026#39;: [ \u0026#39;rsync -rav --delete output/ user@server:/var/www/virtual/user/html\u0026#39;, \u0026#39;rdiff-backup output ~/blog-backup\u0026#39;, ] } Jetzt können wir diesen Befehl einfach durch Eingabe von\nnikola deploy ausführen und die neue Website ist Teil von www.\n"},{"id":45,"href":"/de/docs/digital_logic/agenda2/","title":"Agenda2","section":"Digital Logic","content":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN\" \"http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd\"\u003e- no title specified Combinatorial Logic\nSequential Logic\n00_combinatorial_logic\n10_sequential_logic\n01_boolean_algebra\n11_clocks,flipflops_and_registers\n02_XOR\n12_automata\n03_binary_system\n13_cpu_control 04_Signs\n14_programmable Logic\n05_ALU\n15_test_logic\n06_Memory\n16_ HDLs (VHDL+Verilog)\n17_Register-Transfer-Level\nComputer Architecture / Processor design\n20_RISC_V 21_ISA, Assembler + Linker\n22_RISC_V_implementation\nExcursions\nX0_Multiplication\nX1_Division X2_Trigonometric functions (CORDIC)\nX3_Sigmoid functions\nOther topics\nO00_Consciousness "},{"id":46,"href":"/de/docs/digital_logic/agenda3/","title":"Agenda3","section":"Digital Logic","content":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN\" \"http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd\"\u003e - no title specified Combinatorial Logic\nSequential Logic\n00_combinatorial_logic\n10_sequential_logic\n01_boolean_algebra\n11_clocks,flipflops_and_registers\n02_XOR 12_automata\n03_binary_system 13_cpu_control 04_Signs\n14_programmable Logic\n05_ALU 15_test_logic\n06_Memory 16_ HDLs (VHDL+Verilog)\n17_Register-Transfer-Level\nComputer Architecture / Processor design\n20_RISC_V 21_ISA, Assembler + Linker\n22_RISC_V_implementation\nExcursions\nX0_Multiplication\nX1_Division X2_Trigonometric functions (CORDIC)\nX3_Sigmoid functions\nOther topics\nO00_Consciousness "},{"id":47,"href":"/de/drafts/alu2/","title":"Alu2","section":"Drafts","content":" title: How does a CPU work? The swiss knife (Part II)\nslug: how-does-a-cpu-work-alu-2\ndate: 2022-02-09\ncategory:\nlink:\ndescription:\ntype: text\nALU (Arithmetic Logic Unit) Instruction table logic operations description implementation data type / size and\nbasic boolean Op\n-\nbit\nor\nbasic boolean Op\n-\nbit\nnot\nbasic boolean Op\n-\nbit\nxor\ncomplex boolean Op\n-\nbit\nshl\nshift left\n-\nvarious\nshr\nshift right\n-\nvarious\ncontrol instructions description data type / size ld\nload\nvarious\nst\nstore\nvarious\njx\njump (x= gt,eq, lt )\nvarious\narithmetic operations description implementation data type / size ashl\narithmetic shift left\n-\nvarious\nashr\narithmetic shift right\n-\nvarious\ninc\nincrement\n-\nvarious\ndec\ndecrement\n-\nvarious\nadd\naddition\n-\n(u) integer\nsub\nsubtraction\n-\n(u) integer\nmul\nmultiplication\nsoftware-routine or HW\n(u)integer\ndiv\ndivision\nsoftware-routine or HW\n(u)integer\nsin\nsine\nsoftware-routine (Cordic)\n(u) integer\ncos\ncosine\nsoftware-routine (Cordic)\n(u) integer\ntan\ntangens\nsoftware-routine (Cordic)\n(u) integer\nCompare operations The first type of instructions we have nor called not even discussed are compare instructions. We first show a comparator for a single bit, and then derive an comparator for arithmetic operations.This whole section is just a quotation, the original source is found here.\nA B \u0026gt; (G) = (E) \u0026lt; (L) 0\n0\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n1\n0\n0\n1\n1\n0\n1\n0\nThis leads us to three simple boolean equations (greater than, equal, less than):\n\\[ G = A\\overline{B} \\]\n\\[ E = \\overline {A \\oplus B} \\]\n\\[ L = \\overline{A}B \\]\nWe extend this scheme to a 4 bit width comparator as follows:\n\\[ A = A_{1}A_{2}A_{3}A_{4} \\quad and \\quad B=B_{1}B_{2}B_{3}B_{4} \\]\nGreater than \\huge \\[ \\begin{array}{l} (1) \\quad A_{1} \u0026gt; B_{1} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\\\ (2) \\quad A_{1} = B_{1};A_{2} \u0026gt; B_{2} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\\\ (3) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} \u0026gt; B_{3} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\\\ (4) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} = B_{3};A_{4} \u0026gt; B_{4} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\end{array} \\]\n\\huge \\[ \\begin{array}{l} For \\quad (1) \\quad G = A_{1}\\overline{B}_{1} \\\\ For \\quad (2) \\quad G= \\overline {A_{1} \\oplus B_{1}} (A_{2}\\overline{B_{2}}) \\\\ For \\quad (3) \\quad G= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (A_{3}\\overline{B_{3}}) \\\\ For \\quad (4) \\quad G= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (A_{4}\\overline{B_{4}}) \\end{array} \\]\nFrom this follows, that G=1 when either of the above equations holds…​\n\\huge \\[ \\begin{array}{l} G= A_{1}\\overline{B}_{1} + \\overline {A_{1} \\oplus B_{1}} (A_{2}\\overline{B_{2}}) \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (A_{3}\\overline{B_{3}}) + \\\\ \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (A_{4}\\overline{B_{4}}) \\end{array} \\]\nLess than \\huge \\[ \\begin{array}{l} (5) \\quad A_{1} \u0026lt; B_{1} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\\\ (6) \\quad A_{1} = B_{1};A_{2} \u0026lt; B_{2} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\\\ (7) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} \u0026lt; B_{3} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\\\ (8) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} = B_{3};A_{4} \u0026lt; B_{4} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\end{array} \\]\n\\huge \\[ \\begin{array}{l} For \\quad (5) \\quad L= \\overline{A}_{1}B_{1} \\\\ For \\quad (6) \\quad L= \\overline {A_{1} \\oplus B_{1}} (\\overline{A_{2}}B_{2}) \\\\ For \\quad (7) \\quad L= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (\\overline{A_{3}}B_{3}) \\\\ For \\quad (8) \\quad L= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (A_{4}\\overline{B_{4}}) \\end{array} \\]\nFrom this follows, that L=1 when either of the above equations holds…​\n\\huge \\[ \\begin{array}{l} L= \\overline{A}_{1}B_{1} + \\overline {A_{1} \\oplus B_{1}} (\\overline{A_{2}}B_{2}) \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (\\overline{A_{3}B_{3}}) + \\\\ \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (\\overline{A_{4}}B_{4}) \\end{array} \\]\nEqual Last but not least for equal holds:\n\\huge \\[ \\begin{array}{l} A_{1}=B_{1}; A_{2}=B_{2};A_{3}=B_{3};A_{4}=B_{4} ⇒ E=1 \\\\ E = \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} \\quad \\overline {A_{4} \\oplus B_{4}} \\end{array} \\]\nThus, the logical circuit is designed as follows:\nComparator circuit The 4063 cmos IC is a 4 bit comparator IC. It can be cascaded to cover wider bit ranges.\nShift operations The next important set of operations are the shift operations. Those can be divided in logical as well as arithmetic shift operations.\nAs you may have noticed, in the last posts we have not even mentioned the two more advanced fundamental arithmetic operations multiplication and divison of integers. mul and div are very elaborate operations compared to addition and subtraction.\nSimple CPUs and microprocessors do not even have multiplier units or division units. The instructions have to be programmed as a software routine, we go into this in more details in another blogpost. (And then there is of course also floating point arithmetic, even more complex than our currently discussed integers).\nThe now introduced arithmetic shift operations solves multiplication and division operations at least for a subset of powers of two:\nAn arithmetic left shift of a two’s complement value by n bits equals a multiplication by 2n. (Given no overflow is produced)\nAn arithmetic right shift equals the floor of a division by 2n.\nA simple Shifter The gate-level implementation of a simple shifter is shown below.\nNext we see the truth table for the decoder logic, the derivation of the netlist is left as excercise for the reader.\nSel1 Sel0 R nop L 0\n0\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n1\n0\n0\nWe see the gate-level implementation of such a shifter- is shown for the operations is realised in pass-transistor-logic (Reference: VLSI Design by K.Lal Kishore and V.S.V Prabhakar).\nBarrel Shifter A more sophisticated shifter implementation is the so known barrel shifter. The barrel shifter allows a shift over multiple bits in one go.\nAn implementation in pass-transistor-logic is shown below.\n"}]