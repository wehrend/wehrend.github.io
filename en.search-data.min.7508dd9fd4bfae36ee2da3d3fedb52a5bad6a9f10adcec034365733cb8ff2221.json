[{"id":0,"href":"/posts/web/29_odoo_with_frontend/","title":"Modify the Odoo Frontend","section":"Web","content":" Today, I want to show you how you can modify your Odoo frontend, I wont go to deep into owl and instead just show the basic steps for implementing modifications and changes via HTML5, CSS und javascript.\nLets dive in and wet the toes.\nWe begin by writing a short cut-through css file to change and modify the view (in my example case here removing carets on the provisioning reports) but feel free to change any other element (or attribute) you want\nprovisions.css\n.fa-caret-down { display: none: !important } and put this file into the file path: static/src/css/provision.css\nFinally we need to make Odoo aware of the newly added files, by putting it into the frontend assets and here into the backend\nmanifest.py\n# Asset Bundles \u0026#39;assets\u0026#39;: { \u0026#39;web.assets_backend\u0026#39;: [ \u0026#39;my_module_provisions/static/src/css/provisions.css\u0026#39;, ], }, which looks in the full file like these:\nmanifest.py\n{ # App Information \u0026#39;name\u0026#39;: \u0026#39;\u0026lt;your module\u0026gt;\u0026#39;, \u0026#39;summary\u0026#39;: \u0026#39;\u0026lt;your module description\u0026gt;\u0026#39;, \u0026#39;version\u0026#39;: \u0026#39;16.0.1.0.2\u0026#39;, \u0026#39;category\u0026#39;: \u0026#39;Base\u0026#39;, \u0026#39;license\u0026#39;: \u0026#39;OPL-1\u0026#39;, # Author \u0026#39;author\u0026#39;: \u0026#39;foo bar\u0026#39;, \u0026#39;maintainer\u0026#39;: \u0026#39;fizz buzz\u0026#39;, \u0026#39;website\u0026#39;: \u0026lt;website\u0026gt;, \u0026#39;support\u0026#39;: \u0026#39;\u0026lt;mail\u0026gt;\u0026#39;, # Odoo Apps Store \u0026#39;price\u0026#39;: 0.00, \u0026#39;currency\u0026#39;: \u0026#39;EUR\u0026#39;, \u0026#39;images\u0026#39;: [], # \u0026#39;live_test_url\u0026#39;: \u0026#39;https://...\u0026#39;, # App Installation \u0026#39;application\u0026#39;: False, \u0026#39;installable\u0026#39;: True, \u0026#39;auto_install\u0026#39;: False, # Dependencies \u0026#39;depends\u0026#39;: [ \u0026#39;account\u0026#39;, \u0026#39;account_reports\u0026#39;, ], \u0026#39;external_dependencies\u0026#39;: {}, # Data \u0026#39;data\u0026#39;: [ \u0026#39;views/account_account.xml\u0026#39;, \u0026#39;views/account_move.xml\u0026#39;, \u0026#39;views/provision_category.xml\u0026#39;, \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#39;data/provisions_schedule.xml\u0026#39;, \u0026#39;data/account_report_actions.xml\u0026#39;, \u0026#39;data/menuitems.xml\u0026#39;, ], # Demo files - only installed and updated in demo Mode \u0026#39;demo\u0026#39;: [], # Asset Bundles \u0026#39;assets\u0026#39;: { \u0026#39;web.assets_backend\u0026#39;: [ \u0026#39;my_module_provisions/static/src/css/provisions.css\u0026#39;, ], }, # Hooks \u0026#39;pre_init_hook\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;post_init_hook\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;uninstall_init_hook\u0026#39;: \u0026#39;\u0026#39;, } So,we created the first module involvin frontend stuff.\n"},{"id":1,"href":"/posts/web/30_hugo_move_to_gh_pages/","title":"Move Hugo Web-presence to GH-Pages","section":"Web","content":" Hi there, a few months ago I decided, I would want to go to a form of webspace where I dont have to spend money. Although its only a few bucks, I thought it would be time to move on…​So this is basically a tutorial to move over to github pages…​\nWe start with the Makefile. My new setup looks like the following:\ninclude credentials.mk build_dir := wehrend.github.io up: hugo serve --disableFastRender --renderStaticToDisk --ignoreCache --config ./content/config.toml deployment: @echo \u0026#34;Building site...\u0026#34; hugo -D -d $(build_dir) --config ./content/config.toml @echo \u0026#34;Changing directory to output folder...\u0026#34; @cd $(build_dir) \u0026amp;\u0026amp; \\ if [ -n \u0026#34;$$(git status --porcelain)\u0026#34; ]; then \\ echo \u0026#34;Adding changes...\u0026#34;; \\ git add .; \\ read -p \u0026#34;Enter commit message: \u0026#34; COMMIT_MSG; \\ echo \u0026#34;Committing changes...\u0026#34;; \\ git commit -m \u0026#34;$$COMMIT_MSG\u0026#34;; \\ echo \u0026#34;Pushing to GitHub via SSH with credentials...\u0026#34;; \\ GIT_SSH_COMMAND=\u0026#34;sshpass -p $(SSH_PASS) ssh\u0026#34; git push git@github.com:wehrend/hugo_blog.git main; \\ else \\ echo \u0026#34;No changes to commit.\u0026#34;; \\ fi cleanup: @echo \u0026#34;Cleaning up...\u0026#34; rm -rf ./wehrend.github.io @echo \u0026#34;Cleanup complete.\u0026#34; and the credentials.mk file shown below which should be explicit in the .gitignore tp prevent secrets fromm being leaked.\nSSH_PASS = \u0026lt;password or token\u0026gt; Next, before doing incremental changes, first we need to create a repository for the pages as is described here:\nfirst create a new public reposiory under https://github.com/\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io which is in my case\nhttps://github.com/wehrend/wehrend.github.io, then we need to go to our main directory hugo and manipulatre the publishDir URL in the config file, so that it points to \u0026lt;username\u0026gt;.github.io instead of public, then do an add *, followed by a git commit and git push origin main .\n"},{"id":2,"href":"/posts/web/28_setup_your_python_based_project/","title":"Setup your python based backend system on Debian Bullseye","section":"Web","content":" Here I wanted to document how to setup a python based backend (here: Odoo, but it could also be for example Django) on a pristine Debian / Ubuntu on\nAfter a new installation of Debian / Ubuntu you need to install a couple of packages to start of with a usable system, we add the following packages via apt-get:\nsudo apt-get install chromium, git, qdirstat, make, build-essential, python3 (Qdirstat is not needed always needed but sometimes helpful to have for a shell equivalent you can also use / install ncdu instead.)\nNext, we install the packagemanager for python:\nsudo apt-get install pip, pipx Then we download the odoo (pr django or flask) software by cloning the git repos to the localhost (to spare a few bytes, we only take the latest branch)\ngit clone git@github.com:odoo/odoo.git --single-branch -b 18.0 odoo Next we need to download and install postgresql (the database behind Odoo) :\nsudo apt-get install postgresql This command will install postgresql in the version 15.\nAfter that then we need to go into the odoo directory and create a virtual environment which is done via the following three commands sven@debian:~/software cd odoo sven@debian:~/software/odoo$ python3 -m venv venv sven@debian:~/software/odoo$ source venv/bin/activate\nThat next command downloads a couple of all python based dependencies, for example werkzeug and pytz\npipx install -r requirements.txt Trigger für man-db (2.11.2-2) werden verarbeitet ... Trigger für libc-bin (2.36-9+deb12u9) werden verarbeitet ... (odoo-venv) sven@debian:~/software/odoo$ pip3 install -r requirements.txt Ignoring asn1crypto: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring Babel: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring cbor2: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring chardet: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring cryptography: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring decorator: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring docutils: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring freezegun: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring gevent: markers \u0026#39;sys_platform != \u0026#34;win32\u0026#34; and python_version == \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring gevent: markers \u0026#39;sys_platform != \u0026#34;win32\u0026#34; and python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring greenlet: markers \u0026#39;sys_platform != \u0026#34;win32\u0026#34; and python_version == \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring greenlet: markers \u0026#39;sys_platform != \u0026#34;win32\u0026#34; and python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring idna: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring Jinja2: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring libsass: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring lxml: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring lxml: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring lxml-html-clean: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring MarkupSafe: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring MarkupSafe: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring num2words: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring openpyxl: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring Pillow: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring Pillow: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring psutil: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring psutil: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring psycopg2: markers \u0026#39;python_version == \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring psycopg2: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring pyopenssl: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring PyPDF2: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring pypiwin32: markers \u0026#39;sys_platform == \u0026#34;win32\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring python-dateutil: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring python-ldap: markers \u0026#39;sys_platform != \u0026#34;win32\u0026#34; and python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring python-stdnum: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring qrcode: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring reportlab: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring reportlab: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring requests: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring rjsmin: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring rl-renderPM: markers \u0026#39;sys_platform == \u0026#34;win32\u0026#34; and python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring urllib3: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring Werkzeug: markers \u0026#39;python_version \u0026lt;= \u0026#34;3.10\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring Werkzeug: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring xlrd: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring XlsxWriter: markers \u0026#39;python_version \u0026gt;= \u0026#34;3.12\u0026#34;\u0026#39; don\u0026#39;t match your environment Ignoring zeep: markers \u0026#39;python_version \u0026lt; \u0026#34;3.11\u0026#34;\u0026#39; don\u0026#39;t match your environment Collecting asn1crypto==1.5.1 Using cached asn1crypto-1.5.1-py2.py3-none-any.whl (105 kB) Collecting Babel==2.10.3 Using cached Babel-2.10.3-py3-none-any.whl (9.5 MB) Collecting cbor2==5.4.2 Using cached cbor2-5.4.2.tar.gz (85 kB) Installing build dependencies ... done Getting requirements to build wheel ... done Preparing metadata (pyproject.toml) ... done Requirement already satisfied: chardet==5.2.0 in ./odoo-venv/lib/python3.11/site-packages (from -r requirements.txt (line 10)) (5.2.0) Collecting cryptography==3.4.8 Using cached cryptography-3.4.8-cp36-abi3-manylinux_2_24_x86_64.whl (3.0 MB) Collecting decorator==5.1.1 Using cached decorator-5.1.1-py3-none-any.whl (9.1 kB) Collecting docutils==0.20.1 Using cached docutils-0.20.1-py3-none-any.whl (572 kB) Collecting freezegun==1.2.1 Using cached freezegun-1.2.1-py3-none-any.whl (16 kB) Collecting geoip2==2.9.0 Using cached geoip2-2.9.0-py2.py3-none-any.whl (18 kB) Collecting gevent==22.10.2 Using cached gevent-22.10.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (6.8 MB) Collecting greenlet==2.0.2 Using cached greenlet-2.0.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (618 kB) Collecting idna==2.10 Using cached idna-2.10-py2.py3-none-any.whl (58 kB) Collecting Jinja2==3.1.2 Using cached Jinja2-3.1.2-py3-none-any.whl (133 kB) Collecting libsass==0.22.0 Using cached libsass-0.22.0-cp36-abi3-manylinux_2_5_x86_64.manylinux1_x86_64.whl (9.4 MB) Collecting lxml==4.9.3 Using cached lxml-4.9.3-cp311-cp311-manylinux_2_28_x86_64.whl (7.9 MB) Collecting MarkupSafe==2.1.2 Using cached MarkupSafe-2.1.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (27 kB) Collecting num2words==0.5.10 Using cached num2words-0.5.10-py3-none-any.whl (101 kB) Collecting ofxparse==0.21 Using cached ofxparse-0.21.tar.gz (53 kB) Preparing metadata (setup.py) ... done Collecting openpyxl==3.0.9 Using cached openpyxl-3.0.9-py2.py3-none-any.whl (242 kB) Requirement already satisfied: passlib==1.7.4 in ./odoo-venv/lib/python3.11/site-packages (from -r requirements.txt (line 44)) (1.7.4) Collecting Pillow==9.4.0 Using cached Pillow-9.4.0-cp311-cp311-manylinux_2_28_x86_64.whl (3.4 MB) Collecting polib==1.1.1 Using cached polib-1.1.1-py2.py3-none-any.whl (20 kB) Collecting psutil==5.9.4 Using cached psutil-5.9.4-cp36-abi3-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (280 kB) Collecting psycopg2==2.9.5 Using cached psycopg2-2.9.5.tar.gz (384 kB) Preparing metadata (setup.py) ... done Collecting pyopenssl==21.0.0 Downloading pyOpenSSL-21.0.0-py2.py3-none-any.whl (55 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 55.1/55.1 kB 2.9 MB/s eta 0:00:00 Collecting PyPDF2==2.12.1 Downloading pypdf2-2.12.1-py3-none-any.whl (222 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 222.8/222.8 kB 10.3 MB/s eta 0:00:00 Collecting pyserial==3.5 Downloading pyserial-3.5-py2.py3-none-any.whl (90 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 90.6/90.6 kB 18.5 MB/s eta 0:00:00 Collecting python-dateutil==2.8.2 Using cached python_dateutil-2.8.2-py2.py3-none-any.whl (247 kB) Collecting python-ldap==3.4.0 Downloading python-ldap-3.4.0.tar.gz (376 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 376.2/376.2 kB 22.2 MB/s eta 0:00:00 Installing build dependencies ... done Getting requirements to build wheel ... done Preparing metadata (pyproject.toml) ... done Collecting python-stdnum==1.19 Downloading python_stdnum-1.19-py2.py3-none-any.whl (1.0 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.0/1.0 MB 24.3 MB/s eta 0:00:00 Requirement already satisfied: pytz in ./odoo-venv/lib/python3.11/site-packages (from -r requirements.txt (line 67)) (2024.2) Collecting pyusb==1.2.1 Downloading pyusb-1.2.1-py3-none-any.whl (58 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 58.4/58.4 kB 19.8 MB/s eta 0:00:00 Collecting qrcode==7.4.2 Downloading qrcode-7.4.2-py3-none-any.whl (46 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 46.2/46.2 kB 10.2 MB/s eta 0:00:00 Collecting reportlab==3.6.12 Downloading reportlab-3.6.12-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (2.8 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.8/2.8 MB 26.6 MB/s eta 0:00:00 Collecting requests==2.31.0 Downloading requests-2.31.0-py3-none-any.whl (62 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 62.6/62.6 kB 20.3 MB/s eta 0:00:00 Collecting rjsmin==1.2.0 Downloading rjsmin-1.2.0.tar.gz (419 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 419.9/419.9 kB 23.4 MB/s eta 0:00:00 Preparing metadata (setup.py) ... done Collecting urllib3==1.26.5 Downloading urllib3-1.26.5-py2.py3-none-any.whl (138 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 138.1/138.1 kB 26.7 MB/s eta 0:00:00 Collecting vobject==0.9.6.1 Downloading vobject-0.9.6.1.tar.gz (58 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 58.6/58.6 kB 18.5 MB/s eta 0:00:00 Preparing metadata (setup.py) ... done Collecting Werkzeug==2.2.2 Downloading Werkzeug-2.2.2-py3-none-any.whl (232 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 232.7/232.7 kB 39.7 MB/s eta 0:00:00 Collecting xlrd==1.2.0 Downloading xlrd-1.2.0-py2.py3-none-any.whl (103 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 103.3/103.3 kB 21.3 MB/s eta 0:00:00 Collecting XlsxWriter==3.0.2 Downloading XlsxWriter-3.0.2-py3-none-any.whl (149 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 149.9/149.9 kB 25.5 MB/s eta 0:00:00 Collecting xlwt==1.3.0 Using cached xlwt-1.3.0-py2.py3-none-any.whl (99 kB) Collecting zeep==4.2.1 Downloading zeep-4.2.1-py3-none-any.whl (101 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 101.2/101.2 kB 23.8 MB/s eta 0:00:00 Collecting cffi\u0026gt;=1.12 Downloading cffi-1.17.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (467 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 467.2/467.2 kB 25.0 MB/s eta 0:00:00 Collecting maxminddb\u0026gt;=1.4.0 Downloading maxminddb-2.6.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (88 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 88.1/88.1 kB 26.8 MB/s eta 0:00:00 Collecting zope.event Downloading zope.event-5.0-py3-none-any.whl (6.8 kB) Collecting zope.interface Downloading zope.interface-7.2-cp311-cp311-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (259 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 259.8/259.8 kB 18.5 MB/s eta 0:00:00 Requirement already satisfied: setuptools in ./odoo-venv/lib/python3.11/site-packages (from gevent==22.10.2-\u0026gt;-r requirements.txt (line 21)) (66.1.1) Collecting docopt\u0026gt;=0.6.2 Downloading docopt-0.6.2.tar.gz (25 kB) Preparing metadata (setup.py) ... done Collecting beautifulsoup4 Downloading beautifulsoup4-4.12.3-py3-none-any.whl (147 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 147.9/147.9 kB 22.5 MB/s eta 0:00:00 Collecting six Downloading six-1.17.0-py2.py3-none-any.whl (11 kB) Collecting et-xmlfile Downloading et_xmlfile-2.0.0-py3-none-any.whl (18 kB) Collecting pyasn1\u0026gt;=0.3.7 Downloading pyasn1-0.6.1-py3-none-any.whl (83 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 83.1/83.1 kB 26.6 MB/s eta 0:00:00 Collecting pyasn1_modules\u0026gt;=0.1.5 Downloading pyasn1_modules-0.4.1-py3-none-any.whl (181 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 181.5/181.5 kB 26.6 MB/s eta 0:00:00 Collecting typing-extensions Downloading typing_extensions-4.12.2-py3-none-any.whl (37 kB) Collecting pypng Downloading pypng-0.20220715.0-py3-none-any.whl (58 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 58.1/58.1 kB 19.9 MB/s eta 0:00:00 Collecting charset-normalizer\u0026lt;4,\u0026gt;=2 Downloading charset_normalizer-3.4.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (143 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 143.9/143.9 kB 25.7 MB/s eta 0:00:00 Collecting certifi\u0026gt;=2017.4.17 Downloading certifi-2024.12.14-py3-none-any.whl (164 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 164.9/164.9 kB 25.2 MB/s eta 0:00:00 Collecting attrs\u0026gt;=17.2.0 Downloading attrs-24.3.0-py3-none-any.whl (63 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 63.4/63.4 kB 22.2 MB/s eta 0:00:00 Collecting isodate\u0026gt;=0.5.4 Downloading isodate-0.7.2-py3-none-any.whl (22 kB) Collecting platformdirs\u0026gt;=1.4.0 Downloading platformdirs-4.3.6-py3-none-any.whl (18 kB) Collecting requests-toolbelt\u0026gt;=0.7.1 Downloading requests_toolbelt-1.0.0-py2.py3-none-any.whl (54 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 54.5/54.5 kB 22.0 MB/s eta 0:00:00 Collecting requests-file\u0026gt;=1.5.1 Downloading requests_file-2.1.0-py2.py3-none-any.whl (4.2 kB) Collecting pycparser Downloading pycparser-2.22-py3-none-any.whl (117 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 117.6/117.6 kB 24.9 MB/s eta 0:00:00 Collecting soupsieve\u0026gt;1.2 Downloading soupsieve-2.6-py3-none-any.whl (36 kB) Building wheels for collected packages: cbor2, python-ldap Building wheel for cbor2 (pyproject.toml) ... done Created wheel for cbor2: filename=cbor2-5.4.2-cp311-cp311-linux_x86_64.whl size=171878 sha256=a2561520f78ff510ee0de12d15e40d10244c8c18c1a5c4c64bff0954e91637bc Stored in directory: /home/sven/.cache/pip/wheels/72/80/58/875f97226ba6eb6644fcbcdd2095bb304a64511ed3f11e6a55 Building wheel for python-ldap (pyproject.toml) ... error error: subprocess-exited-with-error × Building wheel for python-ldap (pyproject.toml) did not run successfully. │ exit code: 1 ╰─\u0026gt; [124 lines of output] /tmp/pip-build-env-3ivowifu/overlay/lib/python3.11/site-packages/setuptools/_distutils/dist.py:270: UserWarning: Unknown distribution option: \u0026#39;test_suite\u0026#39; warnings.warn(msg) running bdist_wheel running build running build_py creating build/lib.linux-x86_64-cpython-311 copying Lib/ldapurl.py -\u0026gt; build/lib.linux-x86_64-cpython-311 copying Lib/ldif.py -\u0026gt; build/lib.linux-x86_64-cpython-311 creating build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/syncrepl.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/sasl.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/resiter.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/pkginfo.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/modlist.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/logger.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/ldapobject.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/functions.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/filter.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/dn.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/constants.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/compat.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/cidict.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/asyncsearch.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/async.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap copying Lib/ldap/__init__.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap creating build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/vlv.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/sss.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/simple.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/sessiontrack.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/readentry.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/pwdpolicy.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/psearch.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/ppolicy.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/pagedresults.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/openldap.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/libldap.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/deref.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls copying Lib/ldap/controls/__init__.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/controls creating build/lib.linux-x86_64-cpython-311/ldap/extop copying Lib/ldap/extop/passwd.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/extop copying Lib/ldap/extop/dds.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/extop copying Lib/ldap/extop/__init__.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/extop creating build/lib.linux-x86_64-cpython-311/ldap/schema copying Lib/ldap/schema/tokenizer.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/schema copying Lib/ldap/schema/subentry.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/schema copying Lib/ldap/schema/models.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/schema copying Lib/ldap/schema/__init__.py -\u0026gt; build/lib.linux-x86_64-cpython-311/ldap/schema creating build/lib.linux-x86_64-cpython-311/slapdtest copying Lib/slapdtest/_slapdtest.py -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest copying Lib/slapdtest/__init__.py -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest running egg_info writing Lib/python_ldap.egg-info/PKG-INFO writing dependency_links to Lib/python_ldap.egg-info/dependency_links.txt writing requirements to Lib/python_ldap.egg-info/requires.txt writing top-level names to Lib/python_ldap.egg-info/top_level.txt reading manifest file \u0026#39;Lib/python_ldap.egg-info/SOURCES.txt\u0026#39; reading manifest template \u0026#39;MANIFEST.in\u0026#39; no previously-included directories found matching \u0026#39;Doc/.build\u0026#39; adding license file \u0026#39;LICENCE\u0026#39; writing manifest file \u0026#39;Lib/python_ldap.egg-info/SOURCES.txt\u0026#39; /tmp/pip-build-env-3ivowifu/overlay/lib/python3.11/site-packages/setuptools/command/build_py.py:212: _Warning: Package \u0026#39;slapdtest.certs\u0026#39; is absent from the `packages` configuration. !! ******************************************************************************** ############################ # Package would be ignored # ############################ Python recognizes \u0026#39;slapdtest.certs\u0026#39; as an importable package[^1], but it is absent from setuptools\u0026#39; `packages` configuration. This leads to an ambiguous overall configuration. If you want to distribute this package, please make sure that \u0026#39;slapdtest.certs\u0026#39; is explicitly added to the `packages` configuration field. Alternatively, you can also rely on setuptools\u0026#39; discovery methods (for example by using `find_namespace_packages(...)`/`find_namespace:` instead of `find_packages(...)`/`find:`). You can read more about \u0026#34;package discovery\u0026#34; on setuptools documentation page: - https://setuptools.pypa.io/en/latest/userguide/package_discovery.html If you don\u0026#39;t want \u0026#39;slapdtest.certs\u0026#39; to be distributed and are already explicitly excluding \u0026#39;slapdtest.certs\u0026#39; via `find_namespace_packages(...)/find_namespace` or `find_packages(...)/find`, you can try to use `exclude_package_data`, or `include-package-data=False` in combination with a more fine grained `package-data` configuration. You can read more about \u0026#34;package data files\u0026#34; on setuptools documentation page: - https://setuptools.pypa.io/en/latest/userguide/datafiles.html [^1]: For Python, any directory (with suitable naming) can be imported, even if it does not contain any `.py` files. On the other hand, currently there is no concept of package data directory, all directories are treated like packages. ******************************************************************************** !! check.warn(importable) creating build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/README -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/ca.conf -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/ca.pem -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/client.conf -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/client.key -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/client.pem -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/gencerts.sh -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/gennssdb.sh -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/server.conf -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/server.key -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs copying Lib/slapdtest/certs/server.pem -\u0026gt; build/lib.linux-x86_64-cpython-311/slapdtest/certs running build_ext building \u0026#39;_ldap\u0026#39; extension creating build/temp.linux-x86_64-cpython-311/Modules x86_64-linux-gnu-gcc -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -fPIC -DHAVE_SASL -DHAVE_TLS -DHAVE_LIBLDAP_R -DHAVE_LIBLDAP_R -DLDAPMODULE_VERSION=3.4.0 \u0026#34;-DLDAPMODULE_AUTHOR=python-ldap project\u0026#34; \u0026#34;-DLDAPMODULE_LICENSE=Python style\u0026#34; -IModules -I/home/sven/software/odoo/odoo-venv/include -I/usr/include/python3.11 -c Modules/LDAPObject.c -o build/temp.linux-x86_64-cpython-311/Modules/LDAPObject.o In file included from Modules/LDAPObject.c:3: Modules/common.h:15:10: fatal error: lber.h: Datei oder Verzeichnis nicht gefunden 15 | #include \u0026lt;lber.h\u0026gt; | ^~~~~~~~ compilation terminated. error: command \u0026#39;/usr/bin/x86_64-linux-gnu-gcc\u0026#39; failed with exit code 1 [end of output] note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed building wheel for python-ldap Successfully built cbor2 Failed to build python-ldap ERROR: Could not build wheels for python-ldap, which is required to install pyproject.toml-based projects Next, if all is installed well, we should face the next error, coming from postgresql:\npsycopg2.OperationalError: connection to server on socket \u0026#34;/var/run/postgresql/.s.PGSQL.5432\u0026#34; failed: FATAL: role \u0026#34;\u0026lt;user\u0026gt;\u0026#34; does not exist So, here we need to create a user odoo and add its role to the postgresql pg_hba.conf\nsudo adduser --system --home=/opt/odoo --group odoo Next, open the psql commandline, and add the user / role odoo:\nsudo -u postgres psql CREATE USER odoo WITH PASSWORD \u0026#39;odoo\u0026#39;; Next, allow the user to create databases:\nALTER USER odoo CREATEDB; and leave the psql shell: \\q\nWe copy over the file below to /etc/postgresql/15.0/pg_hba.conf :\nlocal all postgres trust # TYPE DATABASE USER ADDRESS METHOD # \u0026#34;local\u0026#34; is for Unix domain socket connections only local all all trust # IPv4 local connections: host all all 127.0.0.1/32 scram-sha-256 # IPv6 local connections: host all all ::1/128 scram-sha-256 # Allow replication connections from localhost, by a user with the # replication privilege. local replication all peer host replication all 127.0.0.1/32 scram-sha-256 host replication all ::1/128 scram-sha-256 …​and start odoo-bin via\npython3 ./odoo-bin -c debian/odoo.conf Next we might still need to install the one or other packages before we can visit the site on the webbrowser.\n"},{"id":3,"href":"/posts/web/27_compiling_kicad_on_debian_bullseye/","title":"Compiling Kicad on Debian Bullseye","section":"Web","content":" With my new hobby, there came the desire to learn to build and design my own PCB. With that in mind, I began to use the open source ecad solution Kicad. Now I became interested in participating in this project, but, to compile the code you have endure a few challenges - you know, collecting the dependencies,installing them, choose the right branch whiche compiles down and so on. Here I want to show you my experience with that.\nFirst, clone the gitlab repository:\ngit clone https://gitlab.com/kicad/code/kicad.git git checkout 8.0 Then, you need to install a couple of dependencies I list them in a hopefully complete list\nsudo apt-get install cmake libgl-dev libglew-dev libcurl4-openssl-dev ngspice xfonts-scalable libocct-data-exchange-dev libocct-draw-dev libocct-foundation-dev libocct-modeling-algorithms-dev libocct-modeling-data-dev libocct-ocaf-dev libocct-visualization-dev protobuf-compiler libprotobuf-dev swig python3 python3-pip libwxgtk3.0-gtk3-dev unixodbc unixodbc-dev libsecret1 But cmake and wxwidgets both are too old under Debian Bullseye,so you need to install them separately…​\nFor cmake it is straightforward, you clone the repository and build the program from source:\ngit clone https://github.com/Kitware/CMake.git cd CMake ./bootstrap \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install For wxwidgets its a bit harder, you clone the repository with:\ngit clone https://github.com/wxWidgets/wxWidgets.git git checkout v3.2.4 cd wxWidgets/ git submodule update --init src/jpeg git submodule update --init src/tiff git submodule update --init src/stc/scintilla git submodule update --init 3rdparty/catch git submodule update --init 3rdparty/nanosvg mkdir buildgtk cd buildgtk/ ../configure --with-gtk --prefix=/usr make -j3 sudo make install Now you are finally ready to build Kicad itself…​\ngit clone https://gitlab.com/kicad/code/kicad.git git checkout 8.0 mkdir -p build/release cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DKICAD_USE_EGL=ON -DKICAD_WAYLAND=OFF ../../ make -j3 "},{"id":4,"href":"/posts/web/26_get_the_nandlab_go_board_ready_on_debian/","title":"FPGA 101: Get the Nandland Go board ready on Debian Bullseye","section":"Web","content":" Hi there,\nfinally this week the nandland go board I ordered from the developer Russell Merrick a month ago arrived. It took a detour due to some shipping problems, but this is not about that, so. I had to face quite a few obstacles to get this running on my Debian Bullseye.\nSerial Connection via USB First of all, to connect to the board via FTDI usb as suggested on Debian Bullseye you have to first add your user to the group \u0026#39;dialout\u0026#39;, this is done like below:\nsu - usermod -aG dialout $user (in my case $user is sven) exit and then reboot the machine. After that connect it again (just to be sure). And then start putty, and enter /dev/ttyUSB1 as the port you want to use (/dev/ttyUSB0 does not work here) and type baudrate 115200 as suggested. Now you can type in chars and digits and they will be send to the device and back. So this works now.\nInstall Icecube2 Lets get to the next obstacle, the iCEcube2 installer (and the software) needs to have the library libpng12.so.0 in place and as you can find out with\nfile ./iCEcube2setup_Dec_10_2020_2012 this outputs ./iCEcube2setup_Dec_10_2020_2012: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.2.5, not stripped so you know that you need to install that for the i386 architecture.You can do this via:\nsu apt-get install libpng16-16:i386 ln -s /usr/lib/i386-linux-gnu/libpng16.so.16.37.0 libpng12.so.0 Now the software should launch as expected.\nLicense / Network Issues Next you need to get a Node license that is tied to your hostid from Lattice, you find it out via\nip addr show and take the string \u0026#39;link/ether\u0026#39; and copy the Physical MAC address (12-digit hexadecimal value) behind (without colons \u0026#39;:\u0026#39;), into the license file generator. Next check the checkbox and click \u0026#39;Generate License\u0026#39;. Submit. You should get an email with the license file \u0026#39;license.dat\u0026#39; attached. Put that into the directory of your software installation.\nexport LM_LICENSE_FILE=~/software/iCEcube2.2020.12/license/license.dat; (Make this persistent by putting it in your bashrc. so you dont have to repeat this every time you start the software). Now we get an error that contains something like: ‘Invalid host. The hostid of this system does not match the hostid (error code -9)’\nAs turns out, this error only exists, since debian changes the network interface name to something other than \u0026#39;eth0\u0026#39;, but the license server expect it to be at this point they even write it itself on the support page if you enter license issues:\n\u0026#34;--If you are getting the error ‘Invalid host. The hostid of this system does not match the hostid (error code -9)’, As Lattice tools use the hardcoded Network Interface Name (eth0) and if the active Network Interface name on the system is set to other than eth0, it fails to check the license file and generate the above error. To avoid this you need to rename the active Network Interface Name to eth0 as follows:- 1). Run the following command with root privileges: a). cd /etc/udev/rules.d/ b). vi 70-persistent-net.rules In the 70-persistent-net.rules file you will see a value as: NAME =”\u0026lt;active NIC name (for example p6p1,em1 etc)” change it to NAME=”eth0” and save the file 2). Reboot the system. --Please check the MAC address provided by you at our website should be the MAC ID of your Ethernet LAN card. --Before submitting the case Please provide us the info regarding Linux version , Output screenshot of error, Output screenshot of the command ‘ifconfig -a’ and your current license” .\u0026#34; So to solve this issue, you need to create a file like below, as root open a text-editor:\nsu nano /etc/udev/rules.d/70-persistent-net.rules and enter the text below into it - of course with your physical mac adress / hostid as shown in ip addr show:\nSUBSYSTEM==\u0026#34;net\u0026#34;, ACTION==\u0026#34;add\u0026#34;, DRIVERS==\u0026#34;?*\u0026#34;, ATTR{address}==\u0026#34;\u0026lt;your-mac-address\u0026gt;\u0026#34;, ATTR{dev_id}==\u0026#34;0x0\u0026#34;, ATTR{type}==\u0026#34;1\u0026#34;, KERNEL==\u0026#34;enp11s*\u0026#34;, NAME=\u0026#34;eth0\u0026#34; then close the file and reboot the machine. Next time you open icecube2 it should work and launch as expected.\nSo, I hope this blog post finds to you in the right moment, and helps you to do it faster than me, spending a whole afternoon to fix this issues.\n"},{"id":5,"href":"/posts/synth/25_build_your_own_modules/","title":"Build your own synthesizer modules","section":"Posts","content":" Introduction Hi, today I want to share with you the basic knowledge of DIYing your own synthesizer modules - those do not need of the eurorack standard although in my case they are.\nIf you get started with eurorack format or any other modular like synth standard, but especially the eurorack standard - you will be most likely overwhelmed about the sheer number of manufacturers and available. You can have a simple look here on ModularGrid. You need a few weeks or even months, spending time reading some test articles on Amzona.de , or visiting Synthesizer Stores like SchneidersLaden to get a rough idea of the diversity of the market.\nWhy DIY? But why in the world, if you have so many options already available of readily assembled modules to a good price tag, would you choose to get into DYI and build modules for yourself? There can be multiple reasons: - DYI is cheaper than readily available modules, although this is quiet debatable, since you have big initial costs for tooling and stuff. - DYI is interesting because you learn a lot how the modules work, how electronics in general works, and with time you get eventually better in detecting and fixing the errors you make\nIs definitely worthwhile if you want to consider a hobby like electronics, and personally I think a modular synthesizer is the best way to get in contact with electronics and audio circuits as a hobby.\nNext, we will briefly discuss what tools, components and consumables you need to start with this hobby. Only briefly, since this is discussed in multiple ways and forms in the internet. Also, I will narrow the scope down to modules,not case and power supply,since this is a whole other topic, and besides you should never build own power supply if you do not know what you are doing. Stay away from the mains!\nEquipment So here is the list of tools you will definitely need as a basic set:\na solder station and solder supplies\na DMM or multimeter to measure resistors, voltages and currents\na third hand (that eases your process of soldering by means)\na side cutter / wire cutter\nan electronic pliers\nas solder for THT (through hole, which you should begin with) you should order some lead-free solder with 1mm diameter\na good illuminated workplace\ndepending on your workbench a soldering mat, to prevent your bench from being burned!\nThese are the absolute essentials (you could theoreticaly miss out the DMM but it wont do you any good, since its cheap and you need it for basic testing) And,also, I bet, I forgot something.\nIf you want to enter the world of smd /smt technology (we want to use / describe only size 0805 here) you would additionally need:\nas solder for smd soldering lead-free solder of diameter 0.3mm\ntweezers\nand optional some magnification glasses, but as said those are optional (e.g. I did not needed them yet, since 0805 is relatively big)\nTesting your module That is so far for the building part, but you also need some equipment for testing. It makes sense to first test the module in a separate rack with a separate power supply before putting it into your eurorack case and eventually in case of malfunctioning harm other modules. Here a small pod makes totally sense 4ms pod32.\nAlso, you need probably some input source for your module like cv, audio or gate signals, use a simple oscillator (cv,audio) or sequencer (gate) for that reason: Here Erica Synth Pico VCO or Erica Synth Pico VCO2 comes to mind.\nAlso, you need some output module, actually you can really start with this kit its an easy amplifier with a built-in speaker CLACKTRONICS - MINI SPEAKER KIT\nReverse Polarity protection In this regard I also want to remind you to always use reverse polarity protection diodes in your builds. Use 1N5817 (THT) or MBR0540T1 (smd) for this matter. I could not find a picture so I copied from some befaco schematics so bear with me and ignore the 100nF capacitors.\nWhile this picture might make not sense to you yet, it will as soon as you get learning to read electronics schematics (which you should if you wanna consider this hobby).\nSome Manufactures and Modules to start Lets finally go to the heart of this blog post, which manufactures and modules should you consider as a beginner?\nI personally started my journey with the well documented erica synths edu series, then a few befaco modules (also well documented,also a bit cheaper over on exploding shed, regarding on shipping costs) and then modules from NonlinearCircuits (NLC) (same well documented), but there is no particular reason to do them in this order.\nConclusion and links In conclusion the world of eurorack synthesizers and modules is a worthwhile (albeit money-consuming) endeavour, where you should totally go on the bandwagon if you have the need or urge to do so.\nLast but not least some links thrown, so you know where to start looking for inspiration and DIY kits:\nexploding shed, a company based in Leipzig Germany\n3U Shop, based in Petershagen near Berlin, Germany\nSynthesizer – So funktioniert elektronische Klangerzeugung by Florian Anwander The book that brought me into this hobby [German]\nMuffWiggler A very nice synthesizer forum\nSo, spread the sound! ( Still Todo: adding some pictures.)\n"},{"id":6,"href":"/posts/web/ltb162/25_ltb162/","title":"A favorite hobby of mine: Lustiges Taschenbuch Nr. 162","section":"Web","content":" It is about time, to share another favorite of mine with you, and this is duckburg and the duck universe. I take the LTB (Lustiges Taschenbuch) Nr. 162 as an example from the golden era of the comic series \u0026#34;Lustiges Taschenbuch\u0026#34;\nDer goldene Totempfahl (The golden totem pole) In the story \u0026#34;Der goldene Totempfahl\u0026#34; english the golden totem pole, uncle scrooge is making a movie about his life, the story plays in the county of Dawson, where they are getting lost after a storm, they meet the indianer \u0026#34;großer Elch\u0026#34; english \u0026#34;big moose\u0026#34; and are searching for the gold nuggets big moose saved for uncle scrooge back in time. The movie ends with big moose ending as a movie star.\nDer reichste Mann des Universums (The richest men in universe) In the story \u0026#34;Der reichest Mann des Universums\u0026#34; (the richest men in universe) uncle scrooge goes on a tour in space with his kins (the nephew Donald Duck and grandnephews Tick, Trick and Track). They become involved in a contest of the richest men in universe with some other guy out in space, who has a wish-machine…​ Due to uncle scrooge presence, the sensitive balance of the ecosystem gets disturbed…​ (you have to read the story for yourself ;-) )\n"},{"id":7,"href":"/posts/web/24_fpga_beginners_3/","title":"FPGA 101: DE10-nano board: Hello World","section":"Web","content":" Today I want to show you, how to connect to the DE10-nano board, the successor of the DE0-nano board. It is a bit bigger, costs nearly 300 bucks, but also supports Linux out-of-the-box. There is an Angstrom Linux installed on the SD-card.\nTo connect to the board via the UART interface, power-up the board with the wall-wart,enter the sd-card to start the linux booting, and finally connect the micro-b usb cable (like shown below) with the PC.\nThen go to the console and enter (as root)\n# dmesg | grep FTDI if the driver ideally is already installed you should get back something like:\n[ 6352.585966] usb 3-4: Manufacturer: FTDI [ 6352.648922] usbserial: USB Serial support registered for FTDI USB Serial Device [ 6352.648961] ftdi_sio 3-4:1.0: FTDI USB Serial Device converter detected [ 6352.656051] usb 3-4: FTDI USB Serial Device converter now attached to ttyUSB0 Now, you only need to change user permissions, again as root (you need to do this after every boot / connection):\n# chmod a+rw /dev/ttyUSB0 Then, lastly, you need to install putty which on Linux is as simple as on Windows:\n# apt-get install -y putty Then open putty\n$ putty enter the device /dev/ttyUSB0, like shown in the ftdi output above, enter the baud-speed of 115200 and then save the configuration.\nPress \u0026#39;open\u0026#39; and ideally it should connect to the board. If no warning appears,press enter, and you get belows picture:\nenter root as login and enter as password.\nTo be continued…​\n"},{"id":8,"href":"/posts/web/23_fpga_beginners_2/","title":"FPGA 101: Starting with Quartus and Verilog","section":"Web","content":" So, you decided you want to learn fpga programming and have done the prerequisite from the introduction 0 as well as done the simple logic circuit via quartus’s bdf files. Today we want to show you how to figure out Quartus by doing another hardware equivalent of the hello-World program used in the software world - we do program a binary counter showing of by the LED array we have available on our DE0-nano board. For this we will make use of both the Block Diagram Files (bdf) from Quartus and the popular HDL (Hardware Description Language) Verilog.\nSo we simply start by opening Quartus via the desktop-icon. Then we go to menu File \u0026gt;\u0026gt; New Project wizard as shown below, and click it. Then we give it the name counter, we quickly click through the steps of the wizard, there is no more action to do, just click ok until the end of the wizard. During this tutorial we will create the following files:\nbinarycounter.v - The verilog module with the binary counter\nclock_divider.v - A clock divider to slow the system clock to a low frequency the eye still can follow\ncounter.bdf - A quartus schematic file to tie both above modules and connect it to the pins\nWe start with the binary counter.\nBinary counter in Verilog First we define the module, giving it a name as well the in(s) and out(s) it is carrying as parameters. For now this is very simple: We have clk which is shortly for clock as input, and one output called out.\nmodule bin_counter(clk, out); Next we define the input(s) and outputs respectively, the clock will be defined as input from a wire, since it is going into the module and only one single signal that can get high or low. For the output we will define a register - its defined by the keyword reg - to store the values, followed by square-brackets, to define that the output is an array of 8 bits, [0:7] means we have 8 bits, starting from index 0, ending at index 7.\nmodule bin_counter(clk, out); input wire clk; output reg [0:7] out; Then we define the essential module, by specifing what happens between the begin and the end statement, before we use the keyword always followed by an \u0026#39;@\u0026#39; and the sensitivity list in paranthesis. The sensitivity list list’s the clock with podsedge, meaning it reacts on transitions from low (0) to high (1). In between begin and end we simply increment the counter of the out signal.\nmodule bin_counter(clk, out); input wire clk; output reg [0:7] out; always @ (posedge clk) begin out \u0026lt;= out + 1; end Finally we end the module description via the \u0026#39;endmodule\u0026#39; statement.\n/binarycounter.v module bin_counter(clk, out); input wire clk; output reg [0:7] out; always @ (posedge clk) begin out \u0026lt;= out + 1; end endmodule Clock divider in Verilog Now we can connect our clock signal from the FPGA board, to our input of our binary counter. But wait - there is a problem: If you have a look into the datasheet or the user manual of the board, you will see, that the external clock on the DE0-nano board has a frequency of 50 Mhz, we need to divide this down to a frequency of around 1Hz, which is 1 cycle per second. For that we need to divide the signal by roughly 50.000.000. To compute how much bit width we need we need to do a little computation:\n\\[50.000.000 = 2^x\\]\n\\[x = log_{2}(50.000.000)= 25.575\\]\nSo, because we need to round up the result we need a bit-width of 26 bits. with that we would have a frequency of (50MHz / 2^26) = 0.745 Hz as the result. That is less than 1 Hz , but for now we can live with that. What now follows is the simple implementation of the counter:\n/clock_divider.v module clock_divider(clk,out); input wire clk; output reg [0:25] out = 0; always @ (posedge clk) begin out \u0026lt;= out + 1; end endmodule Counter BDF Lastly we create the counter.bdf file, that ties all together a shown below.\nFirst we have to open the file binarycounter.v and clicking File \u0026gt;\u0026gt; Create / Update \u0026gt;\u0026gt; Create Symbol Files for Current File like shown in the image below. We open the file / tab clock_divider.v and repeat the step above.\nAfter that step we find the just newly created files in the Symbol Library, open the symbol library (see picture below) and you find the modules under directory project.\nNext, follow the different buildsteps throughout the schematic file:\nWhen under properties assigning the bus width, be aware that the syntax is \u0026#39;..\u0026#39; instead of \u0026#39;:\u0026#39; (semicolon) !!\nPin assignment Next we need to link the design inputs and outputs to the physical pins. Below the picture of the clock pin. Do not forget to run the synthesis or at least the analysis before.\nAnd the picture of the LED outputs.\nAnd here the image of the pin planner\nSo for the DE0-nano board we need to assign the pins as follows:\nclock50 | PIN_R8\nled1| PIN_A15\nled2| PIN_A13\nled3| PIN_B13\nled4| PIN_A11\nled5| PIN_D1\nled6| PIN_F3\nled7| PIN_B1\nled8| PIN_L3\nProgramming the device So now we are done with all the work, we can do full synthesis and program our board.\nGo to Tools \u0026gt;\u0026gt; Programmer or simply click on the programmer icon, and connect your lovely FPGA board to the computer via usb. The hardware should be detected displayed, as well as the sof software file chosen.\nFinally, you should see the leds on the board counting with a frequency of 0.745 Hz.\nHere as well are the project files Counter project files\nDisclaimer: I have stolen this tutorial from here but given it my own images and style.\n"},{"id":9,"href":"/posts/web/22_fpga_beginners_1/","title":"FPGA 101: Starting with Quartus","section":"Web","content":" So, you decided you want to learn fpga programming and have done the prerequisite from the last blog post. Today we want to show you how to figure out Quartus by doing a hardware equivalent of the hello-World program used in the software world - we call it AndGate because it is simply that - an and gate feed by to push-buttons as input and a status-LED as output. This way we will make use of the Block Diagram Files (bdf) from Quartus.\nSo we simply start by opening Quartus via the desktop-icon. Then we go to menu File \u0026gt;\u0026gt; New Project wizard as shown below, and click it.\nI have stolen this tutorial from here but given it my own images and style.\nSetup the project Next we see an introduction window as shown below. We click next to get to the next window where we name the Project.\nGive it a proper AndGate or HelloWorld, as you like…​\nNext on the page \u0026#39;Project Type\u0026#39; we select \u0026#39;Empty Project\u0026#39;\nWe skip the next page \u0026#39;Add files\u0026#39; and go to \u0026#39;Family, Device and Board Settings\u0026#39;.\nHere we select the Family Cyclone IV E and select the device with the name \u0026#39;EP4CE22F17C6\u0026#39; according to the accompanied data sheet of the DE0-nano board. We click next and for now skip the step \u0026#39;EDA Tool Settings\u0026#39;. Finally, we get to the Summary of the project wizard.\nAfter you confirmed all is as it should be, click on \u0026#39;Finish\u0026#39; to end the project wizard.\nBuilding the logic As described above we will use the staple features of Quartus to build our own logic in a graphical way without any HDL (Hardware Description) like VHDL or Verilog.\nA tab AndGate.bdf appears with a blank canvas where we can \u0026#39;draw\u0026#39; our circuit /logic gates. If we want, we can save our current state by going to File \u0026gt;\u0026gt; save as …​ and give a name andGate.bdf and a suitable path.\nNow click on the symbol tool icon as shown in the image below, to open the symbol library.\nA new window opens, showing the library with the three main folders \u0026#39;Megafunction\u0026#39;,\u0026#39;other\u0026#39; and primitives…​\nWe are looking for and gate with two inputs, so go to \u0026#39;Primitives\u0026#39;, \u0026#39;logic\u0026#39;, \u0026#39;and2\u0026#39;, confirm with \u0026#39;ok\u0026#39;…​\nNow click in the middle of the grid canvas to enter the symbol, then click esc to exit the library modus.\nAdding pins Next we will add some pins to the design file. Those pins define the interface between our design and the physical I/O pins. Later in the pin assignment we will link the pins to the physical pins of the device.\nThe pin tool icon is right next to the symbol tool icon. Click on the arrow to open the selection menu.\nSelect output and drop the icon down somewhere next to the output of the and gate. Then draw a wire between the gate output and the pin by starting from either point, holding down the mouse and drawing a wire to the other point. Then we have a connection.\nNow, lets do the same thing equivalent for the input pins…​\nLastly we will rename the pins to a more suitable name. Double click on the pin, and rename it. Another way is to click on it and in the context menu chosing properties. We rename the inputs to \u0026#39;in1\u0026#39;,\u0026#39;in2\u0026#39; and the output to \u0026#39;out1\u0026#39;, so that we find the pins correctly named in the pin assigner tool later on.\nPhysical Pins / Pin Assignment To check out the I/O pins we need, lets check out the user manual of the DE0-nano board.\nHere - in above picture - we see the two pushbuttons of the nano board,which are buffered via the SN74AUC17 to do debouncing.\nAnd in below we see an (overly simplified) schematic of the LEDs in the output, missing the pre-resistors.\nNow we have all the physical pins that we need together:\npin E1 - first push-button\npin J15 - second push-button\npin A15 - status LED\nNow to link the design with the physical pins, in Quartus we are going to use the tool Pin Planner.\nThis tool provides us with a map of available pins and functions and allows us to map parts of the design to the desired pins.\nIn order for Quartus to understand which parts of our design can be mapped, we first need to run a partial compilation on the design called analysis and elaboration.\nAnalysis and elaboration There are different stages of processing required to convert our design into something that can be loaded on to the FPGA.\nAnalysis – in this part of the process Quartus checks the design for any errors such as syntax or semantic error.\nElaboration – in the first stage of compilation, Quartus maps out the design in RTL blocks. These are the building blocks within the FPGA that perform basic functions such as memory storage, logic gates and registers.\nSynthesis – in the final stage of compilation, Quartus synthesizes a design at the logic level, converting the RTL design into a gate level design.\nIn order to get our pins to appear in the pin planner we could run a full compilation. However this is not necessary as we only need to run the analysis and elaboration stage.\nQuartus gives us three compilation tools that allow us to run different levels of compilation. We will do a closer look at these steps and what they do in a future blog post. As the full compilation can take some time it makes sense to only run the necessary process. Go ahead and run analysis and elaboration using the tool found in the menu bar at the top of the screen.\nPin assignment Once the process has completed you will have a compilation report and the analysis and elaboration process in the left-hand menu will have a green tick next to it.\nNow we can open the pin planner by clicking assignments \u0026gt; pin planner from the menu at the top of the screen.\nThe pin planner is a little complex at first glance, but it is fairly easy to use.\nYou will see a map of the FPGA with all of the physical pins and their functions.\nWe are interested in the list of pins at the bottom. If you have successfully completed the previous step you should see the pins listed. Go ahead and enter your switch and LED pins in the location box.\nThe input pins should correspond to the physical pins you have connected to the push buttons and the output pin should correspond to the output pin with the LED connected. Once you are done you can close the pin planner.\nYou should notice that Quartus has labelled the pins with the physical outputs that we have just assigned. Note that I have detached the design window to allow a larger work area.\nYou can detach a window by right clicking the tab at the top of the work area and selecting detach. You can also attach and detach windows from the window menu on the top menu bar.\nHardware Compilation / Synthesis Now after we have our pins assigned we can run the compilation process in the hardware world called synthesis, by which the design will be transformed to a binary SRAM object file (sof). Meaning its only running in the volatile Static RAM not persisted and be gone after power supply is down.\nProgramming After the synthesis has completed we can run the programmer to load this compiled program ino our FPGA. We can open the programmer via Tools \u0026gt;\u0026gt; Programmer or via the icon shown below\nOnce you’ve connected the Nano board with the usb cable, in the programmer click on \u0026#39;Hardware Setup\u0026#39;, in the list of the opening window the device should show up as \u0026#39;USB-Blaster\u0026#39; in the list, select it and click ok. Now we need to select Auto-detect to scan the jtag chain, looking for the fpga device EP4CE22. Also make sure you have the sof file generated - if nothing is shown and in doubt - just running all the steps including Timing Analysis by hand.\nIf you have the sof file in place and the hardware showing up just hit the \u0026#39;start\u0026#39; button, then the programmer does it job.\nNow the LED should lit up if you press both buttons at the same time. But if we test the hardware we will notice a different behaviour here: We did not check that the datasheet specifies a high level for the push buttons if not pushed, so we need to modify the design, for better comparison we also add an or gate and connect it to led 1.\nI leave it open to the reader to figure out how to design the circuit as shown. If not successfull (or to lazy) the bdf file can be found here (link below).\nextended Circuit BDF\nAnd do not forget to connect the pin from the or gate output to the dedicated pin of led 1 (PIN_A13), as shown below\nRun the synthesis process and program the board and test.\nNow, when we test the behaviour, we will see that now it behaves correctly as suggested.\n"},{"id":10,"href":"/posts/web/21_fpga_beginners_0/","title":"FPGA 101: Starting with HDLS","section":"Web","content":" Today I want to start a blog post series about hardware programming. We start with an introduction to hardware programming with the FPGA-board DE0 Nano from former Altera now Intel. You see a picture of the small board below. It seems you can still order this board, but I have not tested.\nWe will show how to setup the environment, in the first step we will (show how to) download and install quartus on a Debian distribution, and configure the programmer. In the second step we will install the simulation software Modelsim.\nQuartus IDE The installer can be found here. After accepting the license agreement the 60Mb big quartus installer will be downloaded. In the shell console cd to Downloads and change the permissions, making it executable, and execute it\n$ cd ~/Downloads $ chmod +x ./qinst-lite-linux-23.1std-991.run $ ./qinst-lite-linux-23.1std-991.run The installer GUI opens and you get to select the according packages. Do select the packages as shown below (on this system its already installed): Please check that you have around 20GB disk space free on the partition where you want to install the software, download size is around 4.4 - 5.0 GB.\nThen, click the download. The download and installation takes a bit of time, so get a cup of coffee in between. After installation finished in your console go to the installation - you have it probably installed in your home directory or under /opt - and execute the shell command to start quartus - or simply click on the Desktop icon.\n$ cd intelFPGA_lite/23.1std/quartus/bin/ $ ./quartus Now it is time to take the CD from the DE-0 nano board and copy its content on your computer…​ Or simply download it from here. (You have to registrate yourself).\nAfter copying, open the project my_first_fpga. You see the different code parts in the project view left.\nThis tutorial is in detail documented in the De0-Nano user manual page 40 - page 80 DE0-nano User Manual\nTo quote the user manual (p.44): Create a design that causes LEDs on the development board to blink at two distinct rates. This design is easy to create and gives you visual feedback that the design works. Of course, you can use your DE0-Nano board to run other designs as well. For the LED design, you will write Verilog HDL code for a simple 32-bit counter, add a phase-locked loop (PLL) megafunction as the clock source, and add a 2-input multiplexer megafunction. When the design is running on the board, you can press an input switch to multiplex the counter bits that drive the output LEDs.\nThe view below shows the quartus block design file (bdf) for the simple project my_first_fpga. Its depicting a PLL Megafunction and (bus) Multiplexer Megafunction which is IP (=Intellectual Property from Altera / Intel). And then there is a verilog file containing our custom counter logic as shown below.\n./simple_counter.v //It has a single clock input and a 32-bit output port module simple_counter ( CLOCK_50, counter_out ); input CLOCK_50 ; output\t[31:0] counter_out; reg [31:0] counter_out; always @ (posedge CLOCK_50) // on positive clock edge begin counter_out \u0026lt;= #1 counter_out + 1;// increment counter end endmodule // end of module counter And to check the pin assignment,we open Assignments \u0026gt;\u0026gt; Pin Planner Now we can run the Compiler - which in hardware programming is a bit different from software compilers - but we get to that in another blog post.\nWe can see in the compile report that 1 of 4 PLLs in total is used. Otherwise we use less than 1 percent of resources.\nBefore we can programm the board first we have to configure the usb settings of our distribution, as documented here.\nAccording to \u0026#39;Driver Setup on RedHat Linux Enterprise 5 and Above\u0026#39; which is also valid for Debian Buster / Bullseye, as root user we create a new file /etc/udev/rules.d/51-usbblaster.rules\n# Intel FPGA Download Cable SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6001\u0026#34;, MODE=\u0026#34;0666\u0026#34; SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6002\u0026#34;, MODE=\u0026#34;0666\u0026#34; SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6003\u0026#34;, MODE=\u0026#34;0666\u0026#34; # Intel FPGA Download Cable II SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6010\u0026#34;, MODE=\u0026#34;0666\u0026#34; SUBSYSTEM==\u0026#34;usb\u0026#34;, ATTR{idVendor}==\u0026#34;09fb\u0026#34;, ATTR{idProduct}==\u0026#34;6810\u0026#34;, MODE=\u0026#34;0666\u0026#34; Then we need to exit quartus and restart the computer, plug the usb cable from terasic in and connect it to your board.\nThen, do the following as described here.\nStart the Quartus® II software.\nChoose Programmer from the Tools menu. The Programmer window will open.\nClick the Hardware Setup…​ button to open the Hardware Setup window.\nThe selected programming hardware is identified as Currently Selected Hardware. Programming hardware that is already set up appears in the Available hardware items window.\nClick the Add Hardware button to open the Add Hardware window if the programming hardware you would like to use is not listed in the Available hardware items window.\nSelect the appropriate programming cable or programming hardware from the Hardware Type list.\nSelect the appropriate port and baud rate if necessary.\nClick OK.\nSelect the programming hardware you would like to use by choosing it in the Available hardware items list.\nClick Close.\nYour programming hardware has been set up. (For detailed information about how to program Intel FPGA devices, refer to Quartus II Help.)\nNow, you can program the board with the given sof (sram object file). As the title sram suggest, this is a volatile programming which is lost after power supply is gone.\nWe are still missing an important piece of software, which is the simulation software modelsim. We show this in the future\nModelsim The download link for Modelsim for quartus is given here .\nTo install Modelsim on a debian system some 32 bit libraries have to be installed to.\nFor Ubuntu and Debian the commands are as follows:\n$ sudo dpkg --add-architecture i386 $ sudo apt-get update $ sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32ncurses6 libxft2 libxft2:i386 libxext6 libxext6:i386 Then the downloaded binary needs to be set executable and executed\n$ cd ~/Downloads $ chmod +x ModelSimSetup-20.1.1.720-linux.run $ ./ModelSimSetup-20.1.1.720-linux.run Now it is ready to be used (mostly, we have still to configure things so that it started from quartus.) Next we will do simple circuit with testbench, so the simulator can be tested.\nThe simulator is started by executing qhsim in the binary folder\n$ cd ../intelFPGA/20.1/modelsim_ase/bin $ ./qhsim To be continued…​\n"},{"id":11,"href":"/posts/web/20_reducing_rare_earth_elements/","title":"Reducing Rare Earth Dependence: The Quest for Alternative Magnetic Materials","section":"Web","content":" Introduction Rare earth elements have long been the backbone of high-tech magnets, with metals like neodymium and dysprosium playing pivotal roles in various industries. However, the scarcity and rising demand for these valuable resources have prompted researchers to seek alternative solutions. In an effort to reduce our reliance on rare earth magnets, scientists are exploring innovative materials and alloy combinations. Among the promising contenders is cerium, an abundant and accessible rare earth element, showing potential to replace or augment neodymium magnets. In this article, we’ll delve into the groundbreaking research by Thomas Lograsso and his team at the Ames Laboratory of the US Department of Energy.\nThe Rare Earth Challenge The increasing demand for rare earth elements, coupled with the limited number of reliable suppliers, has led to concerns over future shortages. Geopolitical factors, including China’s dominance in the rare earth market, have raised additional challenges. To address these issues, researchers have been on a quest to discover alternative materials for strong permanent magnets that could reduce our reliance on neodymium and other rare earth elements.\nCerium: A Promising Alternative Researchers have set their sights on cerium, a rare earth element that is more abundant and economically accessible. To transform cerium into a powerful magnet, the scientists began by exploring paramagnetic materials. These substances are weakly attracted to magnetic fields but are not permanently magnetized.\nThomas Lograsso explains, \u0026#34;We can essentially rehabilitate such systems and turn them into magnets by adding specific materials.\u0026#34; This involves starting with alloys or compounds possessing the right properties to become ferromagnetic at room temperature. But which materials fit the bill?\nIdentifying Promising Candidates To identify promising candidates, Lograsso and his team employed a computer-based approach. This method allowed them to predict the magnetic behavior of a wide range of materials and determine their suitability for solid-state magnets. The results of this approach were promising, revealing the potential to create powerful magnets with materials like cerium-cobalt (CeCo₃) by introducing additives such as magnesium. Subsequent experiments validated the theory, proving the transformation of cerium-cobalt into a ferromagnet.\nAnother promising candidate identified through this research is CeCo₅, a material that is already a strong ferromagnet. However, calculations and experiments demonstrated that the addition of copper and iron could further optimize its magnetic properties.\nA Sustainable and Economic Solution These additives could pave the way for cerium-based materials to potentially replace rare earth magnets like neodymium and dysprosium. The advantage is that cerium belongs to the rare earth family, making it more readily available and easier to source than its counterparts.\nLograsso emphasizes, \u0026#34;Being able to replace the highly demanded and scarce rare earth metals makes sense both economically and environmentally.\u0026#34; While the modified cerium-cobalt compounds may not yet match the strength of the most powerful rare earth magnets, they could still provide valuable alternatives for specific applications.\nBeyond Cerium: Exploring Further Alternatives The research doesn’t stop at cerium-based solutions. Lograsso and his team are already experimenting with alternative materials that do not rely on cerium or other rare earth metals. For instance, they are working with cobalt to magnetize iron-germanium (Fe₃Ge) and explore the potential for these materials in high-performance applications.\nAs we face the challenges of rare earth scarcity and increasing demand, the search for alternative materials is becoming more critical than ever. The groundbreaking work by researchers like Thomas Lograsso and his team offers hope that we can reduce our dependence on rare earth elements, providing more sustainable and accessible solutions for the technologies that power our modern world.\n(Written by chatgpt 3.5, proofread by Sven Wehrend, backed up by the source: https://www.scinexx.de/news/technik/alternative-magnete-gegen-den-rohstoffmangel/)\n"},{"id":12,"href":"/posts/web/19_rare_earth_elements/","title":"Unlocking the Secrets of Rare Earth Elements: The Remarkable Case of Neodymium","section":"Web","content":" Introduction Rare earth elements, often shrouded in mystery, play a crucial role in our modern world. From smartphones to electric vehicles, renewable energy technologies, and even defense systems, these elements are the unsung heroes that make our daily lives more sustainable, efficient, and connected. In this article, we’ll delve into the fascinating world of rare earth elements, with a focus on the versatile element, neodymium.\nThe Rare Earth Elements: An Overview Rare earth elements (REEs) are a group of seventeen chemical elements that occupy the lanthanide series of the periodic table, along with scandium and yttrium. Despite the name, they are not necessarily rare, but they are typically found in low concentrations, making their extraction and purification challenging and costly.\nThe significance of rare earth elements lies in their unique properties, which make them indispensable in various high-tech applications. These properties include magnetic behavior, luminescence, and catalytic activity, making REEs integral to the development of cutting-edge technologies.\nMeet Neodymium: A Star Among Rare Earth Elements Neodymium, with the atomic number 60 and chemical symbol Nd, is one of the standout members of the rare earth family. It has earned its place in the spotlight due to its remarkable magnetic properties. Neodymium magnets, known as NdFeB magnets (neodymium, iron, and boron), are some of the most powerful and commercially significant permanent magnets available. These small but potent magnets are used in a multitude of everyday applications.\nApplications of Neodymium Magnets Electronics: Neodymium magnets are the driving force behind many electronic devices. They are used in hard drives, headphones, and speakers, providing us with the clear and immersive audio experiences we enjoy.\nElectric Vehicles: Electric motors in vehicles are often powered by neodymium magnets. These magnets make electric vehicles more efficient and sustainable by enhancing motor performance while reducing energy consumption.\nRenewable Energy: Wind turbines rely on neodymium magnets to generate electricity efficiently. The lightweight and powerful neodymium magnets allow for smaller, more energy-efficient turbines that harness wind power effectively.\nMedical Devices: Neodymium magnets are used in various medical devices, including MRI machines and dental equipment, due to their strong magnetic properties.\nGreen Technologies: Neodymium plays a critical role in the development of green technologies, such as energy-efficient lighting and regenerative braking systems in hybrid and electric cars.\nThe Challenges of Neodymium Production While neodymium is vital for our modern world, its production comes with environmental and geopolitical challenges. The majority of the world’s neodymium supply is sourced from China, which can lead to concerns about supply chain security and environmental consequences of mining and processing.\nEnvironmental concerns stem from the extraction process, which involves harmful chemicals and waste materials. This calls for more sustainable practices and the development of recycling methods to reduce our dependence on new neodymium mining.\nConclusion Rare earth elements, including neodymium, are the unsung heroes that drive our high-tech world. From the screens of our smartphones to the quiet hum of electric vehicles, these elements make our lives more efficient and environmentally friendly. As we continue to rely on neodymium and other rare earth elements, it is essential to explore sustainable production and recycling methods to ensure their availability for future generations. Neodymium, with its remarkable magnetic properties, stands as a testament to the immense potential of rare earth elements in shaping our modern world.\n(Written by chatgpt 3.5, proofread by Sven Wehrend, the author of the website)\n"},{"id":13,"href":"/posts/web/18_op-amps_introduction/","title":"Op-Amps introduction","section":"Web","content":" OP-Amp Today I want to speak about op-amps. These wonderful, but mysterious components, we have heavely often appearing in circuit schematica of analog or analog / digital hybrid circuits. We want to demistify these components.\nThere are two basic thumb rules when handling ideal op-amp circuit. (Real-world op-amp circuits are a bit more complicated, but we will discuss this later).\n1. The first thumb rule is that Vout is essentially the difference of the voltage values at the both inputs, multiplied with an arbitrary but high amplification factor A. \\[ V_{out} = A (V_{in+} - V_{in-}) = \\] in short this goes to\n\\[ V_{in+} = V_{in-}\\]\n2. The second thumb rule is, that there is no input current. The non-inverting amplifier The non-inverting amplifier is simple and easy to calculate: The Amplification A is the output voltage divided by the input voltage, which can be computed as follows:\n\\[ A = \\frac{U_{out}}{U_{in}} = \\frac{R1 + R2}{R1}=1 + \\frac{R2}{R1}\\]\n\\[U_{in}= 5V; R_{1} = 100 k\\Omega; R_{2} = 100 k\\Omega \\]\n\\[ \\frac{U_{out}}{U_{in}} = 1 + \\frac{R2}{R1}\\]\n\\[ U_{out} = ( 1 + \\frac{R2}{R1}) \\cdot U_{in} = ( 1 + \\frac{100k\\Omega}{100k\\Omega}) \\cdot 5V = (1 + 1) \\cdot 5V = 10V\\]\n\\[ A = 2 \\]\nThe voltage follower A special case of the non-inversting amplifier is the voltage follower. A voltage follower also called impedance converter is used to buffer and decouple a stage from its previous stage. It has a low impedance on the input but a high impedance on the output. So this is used so that later stages do not burden previous stages in terms of voltage.\nThe (inverting) rectifier Another small circuit example is the inverting rectifier. It only lets pass the negative half-wave of an alternating sine current. (See also: here )\nTo be continued…​\n"},{"id":14,"href":"/posts/web/17_analog_computers_101/","title":"Analog Computers 101","section":"Web","content":" Analog Computers Today I want to speak about analog computers. In todays times analog computers are leading a shadowy existence, compared to their digital counterparts. But they are wonderous little machines. And that machines I mean wordly because there exists analog mechanical computers that are models from the world and used to compute and predict tides in certain areas of the world . Also the brain is an enourmous analog computer with a comparatively very small enery budget. It only takes 12 Watt. 12 Watt; that is not even a quarter of the power supply budget of a laptop, which uses 65 Watt. And you can do very heavy lifting with the brain, but back to topic. I want to talk mainly about analog electronic computers, during the world war two those were used to compute ballistic curves. So analog computers can sum up, multiply, divide, integrate and differentiate like their digital counterparts.\nSum up To sum up different signals, we can use an op-amp in an inverting wiring, that just sums up the signals on its inputs. As it is inverting we need a second op-amp to add behind to get the right signal at the end. The same circuit is used as a mixer circuit for audio signals, from which I also bought the photo.\nMultiply To create an analog multiplier we are using a trick here, by transforming the input signals into the logarithmic space summing up the result and transforming it back to the linear space. Mathematically speaking we do the following\n\\[c= a*b = alog( \\log(a) + \\log(b))\\]\nBelow you can see the according schematic: The first stage at the inputs are both logarithmic amplifiers, you can see the feedbacking diode between output and non-inverting input. Then we see a simple adder circuit ( an inverting amplifier, with a sum-up node before). And lastly we have an antilogarithmic amplifier, putting the signals back into the linear space. Be aware that the output is actually inverted and we need an additional inverting amplifier to correct the resulting signal.\nTo be continued…​\n"},{"id":15,"href":"/posts/synth/16_noise_floor/","title":"Eurorack Synthesizer - Noise Floor","section":"Posts","content":" In meinem mobilen Setup, dem NiftyVCase, habe ich meine DIY-Module gesammelt (mit Ausnahme des Doepfer A-124, den ich wegen seines großartigen Klangs einbauen musste). Es verfügt über eine Kick-Drum von Erica Synths, einen even VCO, eine Sampling-Modulator, A*B+C und Rampage von Befaco. Sowie den Divebomb III für etwas Delay. Zu guter Letzt ein Zlon-Skew-LFO und ein BCM086-Diodenleiter-Hochpassfilter.\nLink:../noise_floor.m4a[noise floor Audio]\n"},{"id":16,"href":"/posts/synth/15_jam_session/","title":"Eurorack Synthesizer - Jam Session","section":"Posts","content":" Dieses Mal haben wir einen verschachtelten Patch, der ein neues Mitglied enthält, den Zufallssequenzer von rat-king, der, wie der Name schon sagt, schöne zufällige Sequenzen liefert. Außerdem haben wir ein neues Mixer-Modul, selbstgebaut. Wir verwenden auch beide VCOs und beide LFO-Module…​\nJam-Session Audio\n"},{"id":17,"href":"/posts/synth/14_another_small_patch/","title":"Eurorack Synthesizer - Another small patch","section":"Posts","content":" So here is another small patch idea for the Doepfer A-100 system, this time featuring the SEM filter from Oberheim, incarnated in the Doepfer modul A-106-5. We also utilize two LFO modules…​\nLFO SEM Patch Audio\nLFO SEM Patch Audio 2\nLFO SEM Patch Audio 3\nTo this day I did not find the right audio recorder,and I am recording with my smartphone, so the sound quality is rather bad. I am still searching for the ideal recording hardware.\n"},{"id":18,"href":"/pages/short-introduction-to-electronics-102/","title":"Prequel: Introduction to electronics - 102","section":"Pages","content":" Time-sensitive components After reviewing and extensively describing the most important component, the resistor, in the first part, now we want to have a look at the next important component, the capacitor. Capacitor are also passive components, meaning they do not amplify a signal.\nElectrostatic field If we take two metal planes and park them side by side, with a small thin layer of a non-conducting substance in-between, we created an electrostatic field.\nThe build-up of the electrostatic field happens via a DC source, in the image below depicted by the generator G. The source voltage of the generator shifts th electrons located in the wire and the metal plates. This way on the right plate originates an overflowm of electrons (-Q) , while on the other plate a ahortage of the same amount, +Q, originates.\nFor a short amount of time, a charging current flows with the instantaneous value i, which in tradtional direction, promotes a quantity of electricity +Q. The charging current i becomes zero, if the quantity of electricity +Q and -Q generated voltage equals out.\nThe electrostatic field endures after detachment from the DC source, which can be verified with a high impedance voltmeter.The conclusion: The electrostatic field originates by the separated loads +Q, -Q. THe existing voltage shows, that energy is stored in the field. This arrangement is called a plate capacitor.\nReference: Dieter Zastrow, Elektrotechnik,16.Auflage, p. 120. It is another basic electronic component, oftentimes used in electronic devices. The substance in-between is called a dielectricum.\nCapacitance The basic equation for computing the capacity, the no.-1 property of a condensator is a follows. The capacity C of the capacitor gives the interesting ratio of the stored charge quantity Q to the charging voltage U_c .\n\\[C= \\frac{Q}{U_c}\\]\nParallel- and series circuit In parallel connection of capacitors, the capacitances add up to the total capacitance.\n\\[C= C_{1} + C_{2} + …​ \\]\nIn series connection, the reciprocal of the total capacitance is equal to the sum of the reciprocals of the individual capacitances.\n\\[ \\frac{1}{C}= \\frac{1}{C_{1}} + \\frac{1}{C_{2}} + …​ \\]\nThe Capacitor and Coils The elements next introduced, have a clue compared to the static of (ohmic) resistor. Now the time comes into focus, too, since capacitator and coils are both in a sense time-sensitive elements. So normally we would start with introducing the Capacitor with all its implication, and then go over to the coils wich are introduced then afterwards. Instead for this post, we show both of them in a comparision as they have complementary properties.\nconductor\ncoil\ncircuit symbol of a capacitor\ncircuit symbol of a coil\nstores energy in electrical field\nstores energy in a magnetic field\nleads in phase\nlags in phase\nblocks in DC Mode\nin DC mode current is growing while, voltage is taken done, with the same rate\nFrequency-dependent networks (Filters) An often and very popular application of capacitors are filters, Simple filters of first order like shown here,are build up from one resistor and one capacitor. Next we want to compute the frequency response of a filter by getting the frequency response function, which is the outgoing voltage divided by the in-going voltage - this becomes clearer with the following examples.\nLowpass Filter 1.order lowpass\nfrequency response\n\\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{(1/j\\omega C)}{(R+ 1/j \\omega C)} = \\frac{(1/j\\omega C)\\cdot j \\omega C}{(R+ 1/j \\omega C) \\cdot j \\omega C } = \\frac{1}{1+ j\\omega RC } = \\frac{1}{1+ j \\omega/ \\omega_g}\\]\ncutoff frequency (with example values of R=1kOhm, C= 1µF)\n\\[ \\omega_g = \\frac{1}{RC} = \\frac{1}{1 \\cdot 10^3 \\cdot 1 \\cdot 10^6}= 10^3= 1000 \\cdot 1/s\\]\nWe have to use some help to generate the Bode diagram for the lowpass shown above, to do that, please install matplotlib via the following command:\npip install matplotlib\nand execute the following python script:\nimport matplotlib.pyplot as plt import numpy as np # Define the transfer function of a first-order low-pass filter def lowpass_first_order(frequency, cutoff_frequency): return 1 / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequency range for the Bode diagram (logarithmic scale) frequency = np.logspace(0, 6, 1000) # From 10^0 to 10^6 Hertz # Cutoff frequency of the low-pass filter cutoff_frequency = 1000 # Example value - You can set your own value here # Calculate the gain in decibels (20 * log10(Amplitude)) gain_db = 20 * np.log10(lowpass_first_order(frequency, cutoff_frequency)) # Calculate the phase response in degrees (angle) phase_deg = np.degrees(np.arctan(-frequency / cutoff_frequency)) # Create the Bode diagram with both gain and phase plt.figure(figsize=(10, 6)) # Gain plot (magnitude) plt.subplot(2, 1, 1) plt.semilogx(frequency, gain_db, label=\u0026#39;Gain (dB)\u0026#39;) plt.ylabel(\u0026#39;Gain (dB)\u0026#39;) plt.title(\u0026#39;Bode Diagram of a First-Order Low-Pass Filter\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phase plot plt.subplot(2, 1, 2) plt.semilogx(frequency, phase_deg, label=\u0026#39;Phase (degrees)\u0026#39;) plt.xlabel(\u0026#39;Frequency (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (degrees)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Save the Bode diagram as an SVG file plt.savefig(\u0026#39;lowpass_bode_phase.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optionally, display the Bode diagram plt.show() Highpass Filter 1.order highpass\nfrequency response\n\\[ H(\\omega) = \\frac{U_{out}}{U_{in}} = \\frac{R}{R+ 1/j\\omega C} = \\frac{j \\omega C}{1+ j \\omega RC} = \\frac{j\\omega / \\omega_g}{1+ j\\omega/ \\omega_g}\\]\ncutoff frequency (with example values of R=1kOhm, C= 1µF)\nAnd here again the python script, this time for the high-pass:\nimport matplotlib.pyplot as plt import numpy as np # Define the transfer function of a first-order high-pass filter def highpass_first_order(frequency, cutoff_frequency): return frequency / np.sqrt(1 + (frequency / cutoff_frequency)**2) # Frequency range for the Bode diagram (logarithmic scale) frequency = np.logspace(0, 6, 1000) # From 10^0 to 10^6 Hertz # Cutoff frequency of the high-pass filter cutoff_frequency = 1000 # Example value - You can set your own value here # Calculate the gain in decibels (20 * log10(Amplitude)) gain_db = 20 * np.log10(highpass_first_order(frequency, cutoff_frequency)) # Calculate the phase response in degrees (angle) phase_deg = np.degrees(np.arctan(frequency / cutoff_frequency)) # Create the Bode diagram with both gain and phase plt.figure(figsize=(10, 6)) # Gain plot (magnitude) plt.subplot(2, 1, 1) plt.semilogx(frequency, gain_db, label=\u0026#39;Gain (dB)\u0026#39;) plt.ylabel(\u0026#39;Gain (dB)\u0026#39;) plt.title(\u0026#39;Bode Diagram of a First-Order High-Pass Filter\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() # Phase plot plt.subplot(2, 1, 2) plt.semilogx(frequency, phase_deg, label=\u0026#39;Phase (degrees)\u0026#39;) plt.xlabel(\u0026#39;Frequency (Hz)\u0026#39;) plt.ylabel(\u0026#39;Phase (degrees)\u0026#39;) plt.grid(which=\u0026#39;both\u0026#39;, axis=\u0026#39;both\u0026#39;, linestyle=\u0026#39;--\u0026#39;) plt.legend() plt.tight_layout() # Save the Bode diagram as an SVG file plt.savefig(\u0026#39;highpass_bode_diagram.svg\u0026#39;, format=\u0026#39;svg\u0026#39;) # Optionally, display the Bode diagram plt.show() "},{"id":19,"href":"/posts/synth/13_another_simple_patch/","title":"Eurorack Synthesizer - Another simple patch","section":"Posts","content":" Hier ist also eine weitere einfache Patch-Idee für das Doepfer A-100-System, diesmal mit dem SEM-Filter von Oberheim, verkörpert im Doepfer Modul A-106-5. Wir verwenden auch zwei A-110-Oszillatormodule (ein Standard- und ein Basis-Modul) und den LFO.\nLink:../sem_patch.m4a[SEM Patch Audio]\nBis heute habe ich nicht den richtigen Audiorecorder gefunden und nehme mit meinem Smartphone auf, sodass die Tonqualität eher schlecht ist. Ich bin immer noch auf der Suche nach der idealen Aufnahmehardware.\n"},{"id":20,"href":"/posts/web/12_caches_and_caching/","title":"Caches and Caching","section":"Web","content":" When you fire up your browser to visit a website, you most probably did not noticed a very important mechanism underlying the browser and working in the background. Caching. Caches are used everywhere to optimize and improve access times and such in consequence the overall performance (of a site). Caching in the browser for example means, that ideally only the portions of the website that changed are loaded from the www. All else was already loaded before and did not change, thus needs no reload. Portions that are no longer up-to-date become invalidated (also known as cache-invalidation) and are loaded anew from the source. There are two types of very different caches in the computer\nhardware caches, real physical parts of silicon located near the CPU,\nsoftware caches, implemented in the application respectively underlying libraries\nThe type we want to discuss here are the latter ones.\nThere are multiple different caching strategies, see also here, but we want to focus on the Last-recently-Used (LRU) caching strategy here. Python’s library functools provides a decorator @lru_cache for this caching strategy. But before just mindlessly using the decorator @lru_cache you should think about the problem itself, as already stated.\nSimple example, taken from the python documentation:\nfrom functools import lru_cache @lru_cache(maxsize=None) def fib(n): if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) \u0026gt;\u0026gt;\u0026gt; [fib(n) for n in range(16)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610] \u0026gt;\u0026gt;\u0026gt; fib.cache_info() CacheInfo(hits=28, misses=16, maxsize=None, currsize=16) "},{"id":21,"href":"/posts/synth/11_more_patch_ideas/","title":"Eurorack Synthesizer - More patch ideas","section":"Posts","content":" Hier ist also eine weitere Patch-Idee für das Doepfer A-100-System. Die Ergebnisse der Doepfer-Oszillatoren sind prägnante „knarzig-kernige“ Klänge. Wir verwenden zwei A-110-Oszillatormodule (ein Standard- und ein Basic-Modul), einen Ringmodulator (A-114) und ein Wespentaille-Filter (A-124) sowie einige Hilfsmodule wie einen Sequenzer und einen LFO.\npithily…​ Audio\n"},{"id":22,"href":"/posts/synth/09_eurorack_modular/","title":"Pocket Operator Modular 400 in eurorack","section":"Posts","content":" Also kaufte ich mir einen günstigen Eurorack-Koffer von Doepfer und ein Set Frontplatten plus Netzteil für den Pocket Operator Modular 400 von Oddvolt, um die besagte Maschine in ein Eurorack-Modulsystem einzubauen. Ich habe mir auch einen kleinen, aber anständigen Sequenzer gekauft, da der von Teenage Engineering nicht nicht sehr handlich ist. Ich habe noch zwei weitere Module auf meiner Liste, das Doepfer A-119, ein Eingangsmodul, sowie das Doepfer A-124, ein Wasp-Filter [natürlich die Special-Edition in schwarz-gelb, da dies auch noch farblich passt], um das Setup zu vervollständigen.\nEurorack Modular…​ Video\n"},{"id":23,"href":"/posts/web/10_wishlist/","title":"Topics to write about - Wishlist","section":"Web","content":" This is a small, incomplete list of topics I’d like to write about in the mid- to far future.\nCaches\nInterrupts\nOut-of-Order execution\nRAW, WAR and WAW conflicts\nFilters (analog and digital)\nAnalog computers\nneuronal networks\nthe macrobiom\n"},{"id":24,"href":"/posts/web/08_religion_spirituality/","title":"Religion vs. spirituality - why I prefer the latter","section":"Web","content":" What I have learned about religions and spirituality over the last years and decades boils down to one simple statement: Religion is about right and wrong and old, outdated dogmas, while spirituality simply says \u0026#34;It is how it is\u0026#34;. For spirituality, there is no right or wrong, only the single moment in the present in which we dwell. I find this viewpoint quite amazing. From what I found, it leads to a more awakened state.\n"},{"id":25,"href":"/posts/web/07_serial_interfaces/","title":"Why are serial interfaces everywhere - instead of parallel ones","section":"Web","content":" USB, SPI, I²C, Sata - all these interfaces is common that they are serial interfaces. Serial interfaces are todays common. But why is that the case, especially for high-speed communication? it sounds simply counterintuitive: Parallel wires can theoretically send more bits per time than on singular wire can. The answer to that question is complex and multilayered. There are multiple different reasons why serial interfaces are preferred over parallel interfaces. Lets start with the obvious ones: The PCB routing of busses of 8, 16, 32 or even 64 bit width gets increasingly complex to route on printed circuits boards (PCBs).The second problem, related to this, is that signal slope need to get transmitted at the same time for all parallel lines (wires), which results in a more complex routing since edges in the strip conductor needs to be compensated. Simply put the additional logic implemented in chips to convert the serial signal to parallel ones again (deserializer) and vice versa (serializer) is much cheaper than the costs of complex routings.\n"},{"id":26,"href":"/pages/overview2/","title":"How does a CPU work 2? Overview","section":"Pages","content":" How does a CPU work 2 - Table of contents From Combinatorial to Sequential Logic - Introduction Introduction to Sequential Logic\nWe get from purely conmbinatorial logic circuits wihout any form of memeory to sequential logic circuits with some type of memory (mostly flipflops)\nClocks,Flipflops and registers Clocks,flipflops and registers\nWe make a leap into the area of sequential logic and introduce some concepts vital for the sequential logics, like clock, flipflops and registers\nAutomata Automata\nWe introduce the two (three) different automata Mealy, Moore (and Medwedjew). Those can be synchronous or asynchronous.\nCPU Control CPU control\nHere we are dissecting the brain of a CPU, the control unit, which handles and controls all actions of a cpu\nProgrammable Logic Programmable Logic\nWe introduce the concept of programmable logic for both, combinatorial and sequential logic.\nTest thoroughly Testable Logic\nEvery embedded circuit or logic needs some infrastructure for testing. Here we introduce JTAG and boundary-scan-tests.\nHDLs VHDL and Verilog\nWe introduce the concept of a Hardware Description Language (HDL) like VHDL and Verilog.\nExtra Register-Transfer-Level Register-Transfer-Level\nIn this lesson we introduce the concept of the register transfer level.\n"},{"id":27,"href":"/posts/synth/06_pocket_operator_modular_400/","title":"The Pocket Operator Modular 400 patch ideas (II)","section":"Posts","content":" Plong…​ Video\nMit dem Zufallsmodul können wir ein Signal vom Eingang abtasten und halten. Sein Gegenstück ist das Rauschmodul. Wir speisen den Sägeausgang in den Eingang des Zufallsmoduls ein.\nBeep,bleep…​ Video\n\u0026#39;\u0026#39;\u0026#39;.\nSinus-Ausgang -\u0026gt; Lautsprecher rechts. Hüllkurvenausgang -\u0026gt; Sinus-Taste. LFO-Rechteck -\u0026gt; Hüllkurven-Trigger. LFO-Rechteck -\u0026gt; Sinus fm Sweeping Sinus…​ Video\nWir können das Setup erweitern, indem wir den Sequenzer verwenden und den Filter nutzen. Denn das Schöne an modularen Synthesizern ist, dass der Filter nicht nur in Signalpfaden, sondern auch in Steuerpfaden verwendet werden kann ;-) ..\nFilterausgang -\u0026gt; Sinussteuerung. Sequenzerausgang -\u0026gt; Filtereingang --- "},{"id":28,"href":"/docs/digital_logic_2/10_sequential_logic/","title":"10_sequential_logic","section":"Digital Logic 2","content":" Sequential Logic Complementary to Combinatorial logic, sequential logic contains some type of memory, making the behaviour state-dependent. We need to feed it a clock signal.\nMealy and Moore Automata (synchronous) There are two different types of finite automata in the digital logic. Those are:\nThe mealy automata, which is dependent on the input and the state\nThe moore automata, which is only dependent on the state\nSynchronous and Asynchronous sequential Logic There are two different types of sequential logic, the synchronous sequential logic with one central clock, as well as the asnychonous logic which has multiple clock domains.\nWhen we add a clock function to our automata shown above the synchronous automata becomes an asynchronous automata.\n"},{"id":29,"href":"/posts/synth/05_pocket_operator_modular_400/","title":"The Pocket Operator Modular 400 patch ideas","section":"Posts","content":" Ein analoger modularer Synthesizer war schon immer mein Traum, letzte Woche habe ich mir diesen Traum erfüllt und den Pocket Operator Modular 400 von der schwedischen Firma Teenage Engineering bestellt. Wie bei den Möbeln der anderen beliebten schwedischen Firma muss man ihn erst selbst zusammenbauen, bevor man damit einen Ton erzeugen kann. Das hat etwa 3 bis 4 Stunden gedauert. Aber es hat sich gelohnt.\nHier sind einige Patch-Ideen. Im ersten Beispiel mischen wir einfach die Ausgänge aller 3 Oszillatoren zusammen und steuern den Sinusoszillator mit dem Dreieckausgang des LFO und die Impulsbreite des Rechteckoszillators mit dem LFO-Rechteck.\nMixer-Ausgang → Lautsprecher rechts.\nSinus-Ausgang → Mixer 3.\nSägezahn-Ausgang → Mixer 2.\nRechteck-Ausgang → Mixer 1.\nSinus-Ausgang → Sägezahn FM.\nLFO Dreieck → Sinus-Steuerung.\nLFO Rechteck → Rechteck-PWM\nPOM 400 Video\nSong from Tibet Video\nPlong…​ Video\n(Ich entschuldige mich für die schlechte Video- und Tonqualität, die Einrichtung wird verbessert.) Das Schöne an modularen Synthesizern ist, dass sie den traditionellen Signalweg von spannungsgesteuertem Oszillator (VCO), spannungsgesteuertem Filter (VCF) und spannungsgesteuertem Verstärker (VCA) durchbrechen und es ermöglichen, dass die gesamte Kreativität in experimentellen Aufbauten gipfelt.\nMit dem Zufallsmodul können wir ein Signal vom Eingang abtasten und halten. Sein Begleiter ist das Rauschmodul. Wir speisen den Sägezahnausgang in den Eingang des Zufallsmoduls ein.\nLink:../beep_bleep.mp4[Beep,bleep…​ Video]\n\u0026#39;\u0026#39;\u0026#39;.\nSinus-Ausgang -\u0026gt; Lautsprecher rechts. Hüllkurvenausgang -\u0026gt; Sinustaste. LFO-Rechteck -\u0026gt; Hüllkurven-Trigger. LFO-Rechteck -\u0026gt; Sinus fm Sweeping Sinus…​ Video\nWir können das Setup erweitern, indem wir den Sequenzer verwenden und den Filter nutzen. Denn das Schöne an modularen Synthesizern ist, dass der Filter nicht nur in Signalpfaden, sondern auch in Steuerpfaden verwendet werden kann ;-) ..\nFilterausgang -\u0026gt; Sinussteuerung. Sequenzerausgang -\u0026gt; Filtereingang "},{"id":30,"href":"/posts/web/04_odoo_hacks/","title":"Odoo hacks: Remove Lock-Button from Odoo v12","section":"Web","content":" Today I want to introduce a solution for a usability-problem I had in Odoo recently. In Odoo 12 there is a lock button next to the edit / save button, and you have to click both to (1) unlock the page and (2) make it editable. This should be done in one step, effectively removing the locking mechanism used in the Delivery Orders (class StockPicking) and Manufacturing Orders (class MrpProduction). The solution requires an xml and a javascript-file as well as a dedicated web-controller. The soliution is presented below.\n/static/src/xml/trigger_toggle.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;openerp\u0026gt; \u0026lt;data\u0026gt; \u0026lt;template id=\u0026#34;assets_backend\u0026#34; name=\u0026#34;trigger_toggle assets\u0026#34; inherit_id=\u0026#34;web.assets_backend\u0026#34;\u0026gt; \u0026lt;xpath expr=\u0026#34;.\u0026#34; position=\u0026#34;inside\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/nm_data_stock/static/src/js/trigger_toggle.js\u0026#34;/\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/openerp\u0026gt; The code is pretty self-explanatory. We use the xml file to add the script. Dont forget to add it in the manifest-file. The javascript functions _onEdit and _onSave are functions from the core webclient (to be more precise web.FormController), and we add some simple url-parsing and an ajax-RPC-call to both functions.\nstatic/src/js/trigger_toggle.js odoo.define(\u0026#39;nm_data_stock.trigger_toggle\u0026#39;, function(require){ \u0026#39;use strict\u0026#39;; var ajax = require(\u0026#39;web.ajax\u0026#39;) var FormController = require(\u0026#39;web.FormController\u0026#39;); var triggerButton = FormController.include({ _onEdit: function () { // wait for potential pending changes to be saved (done with widgets // allowing to edit in readonly) this.mutex.getUnlockedDef().then(this._setMode.bind(this, \u0026#39;edit\u0026#39;)); const url = new URL(this.$el.context.baseURI) const parsedHash = new URLSearchParams(url.hash.substring(1)) const id = parsedHash.get(\u0026#39;id\u0026#39;) const model = parsedHash.get(\u0026#39;model\u0026#39;) if (model.toString() == \u0026#39;mrp.production\u0026#39; || model.toString() == \u0026#39;stock.picking\u0026#39;) { console.log(\u0026#39;OnEdit \u0026#39;+ id + \u0026#39; \u0026#39;+ model); ajax.jsonRpc(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, \u0026#39;call\u0026#39;, {\u0026#39;id\u0026#39;: id,\u0026#39;model\u0026#39;: model,\u0026#39;button_state\u0026#39;: \u0026#39;edit\u0026#39;} ) } }, _onSave: function (ev) { ev.stopPropagation(); // Prevent x2m lines to be auto-saved var self = this; this._disableButtons(); const url = new URL(this.$el.context.baseURI) const parsedHash = new URLSearchParams(url.hash.substring(1)) const id = parsedHash.get(\u0026#39;id\u0026#39;) const model = parsedHash.get(\u0026#39;model\u0026#39;) if (model.toString() == \u0026#39;mrp.production\u0026#39; || model.toString() == \u0026#39;stock.picking\u0026#39;) { console.log(\u0026#39;OnSave \u0026#39;+ id + \u0026#39; \u0026#39;+ model); ajax.jsonRpc(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, \u0026#39;call\u0026#39;, {\u0026#39;id\u0026#39;: id, \u0026#39;model\u0026#39;: model,\u0026#39;button_state\u0026#39;: \u0026#39;save\u0026#39;} ) } this.saveRecord().always(function () { self._enableButtons(); }); }, }) }) Below is shown the webcontroller as endpoint for the ajax-RPC-call shown above…​\ncontrollers/main.py\nfrom odoo import http from odoo import api,fields from urllib import parse class ToggleController(http.Controller): @http.route(\u0026#39;/web/webclient/trigger_toggle\u0026#39;, type=\u0026#39;json\u0026#39;, auth=\u0026#34;none\u0026#34;) def trigger_toggle(self, **kw): id = kw.get(\u0026#39;id\u0026#39;) model = kw.get(\u0026#39;model\u0026#39;) if model and id: print(model) obj = http.request.env[model].browse(int(id)) return obj.sudo().trigger_toggle(kw.get(\u0026#39;button_state\u0026#39;)) Last but not least the implementation in the both classes.\nmodels/stock.py\nclass StockPicking(models.Model): \u0026#34;\u0026#34;\u0026#34;Inherit class StockPicking from module stock.\u0026#34;\u0026#34;\u0026#34; def trigger_toggle(self, state): if state==\u0026#39;edit\u0026#39;: self.is_locked = False if state==\u0026#39;save\u0026#39;: self.is_locked = True class MrpProduction(models.Model): \u0026#34;\u0026#34;\u0026#34;Inherit class MrpProduction\u0026#34;\u0026#34;\u0026#34; def trigger_toggle(self, state): if state==\u0026#39;edit\u0026#39;: self.is_locked = False if state==\u0026#39;save\u0026#39;: self.is_locked = True "},{"id":31,"href":"/docs/digital_logic_x/x2_cordic/","title":"X2_cordic","section":"Digital Logic X","content":" The CORDIC algoritm and direct digital synthesis (DDS) The CORDIC (which stands for \u0026#34;coordinate rotation digital computer\u0026#34;) algorithm, was developed in 1956 by Jack.E. Volder, to replace the analog resolvers used for missiles navigation by digital computation on digital computer. The algorithm turned out to be very successfull, today it can be found in every pocket calculator, doing the computation of the trigonometrical functions sinus, cosinus and tangens. But the algorithm is not limited to that it can also calculate logarithmic and exponential functions, given the needed modifications.\nThe CORDIC algorithm In the image below, V0 shows the start vector\n\\[v_{0}=\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\] which we now iterate, by multiplying it with the rotation matrix, given below:\n\\[v_{i+1}= R_i v_i\\]\n\\[ R_i = \\begin{bmatrix} cos(\\theta) \u0026amp; -sin(\\theta) \\\\ sin(\\theta) \u0026amp; cos(\\theta) \\end{bmatrix} \\] We use the following two trigonometric identities:\n\\[ cos(\\theta) = \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\]\n\\[ sin(\\theta) = \\frac{tan(\\theta)}{\\sqrt{1+tan^2(\\theta)}} \\]\nthe rotation matrix becomes\n\\[ R_i = \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\begin{bmatrix} 1 \u0026amp; -tan(\\theta) \\\\ tan(\\theta) \u0026amp; 1 \\end{bmatrix} \\]\nThen the rotation vector $v_{i+1}= R_i v_i$ becomes:\n\\[ \\begin{bmatrix} x_{i+1} \\\\ y_{i+1} \\\\ \\end{bmatrix} = \\frac{1}{\\sqrt{1+tan^2(\\theta)}} \\begin{bmatrix} 1 \u0026amp; -tan(\\theta) \\\\ tan(\\theta) \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} x_{i} \\\\ y_{i} \\\\ \\end{bmatrix} \\]\nWe replace the tangens function with a simpler expression, resulting in a bit shift.\n\\[ \\begin{bmatrix} x_{i+1} \\\\ y_{i+1} \\\\ \\end{bmatrix} = K_{i} \\begin{bmatrix} 1 \u0026amp; -\\sigma 2^{-i} \\\\ \\sigma 2^{-i} \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} x_{i} \\\\ y_{i} \\\\ \\end{bmatrix} \\] where\n\\[ K_{i} = \\frac{1}{\\sqrt{1+2^{-2i}}} \\]\nand $\\sigma_i$ is used to determine the direction of the rotation. If the angle $\\theta_{i}$ is positive then $\\sigma{i}$ is +1, otherwise -1.\nThe factor Ki can be factored completly for the iterative process.\n\\[ K(n) = \\prod_{i=0}^{n-1}K_{i} = \\prod_{i=0}^{n-1} \\frac{1}{\\sqrt{1+2^{-2i}}} \\]\n\\[ K = lim_{n→ \\infty} K \\approx 0.60725293500888 \\]\n"},{"id":32,"href":"/posts/web/03_separate_form_and_content/","title":"Separating blog and content","section":"Web","content":" As the blog grow bigger and after the move to odoo, I noticed a gap in the workflow,since a blog and its content itself are different entities, I wanted to handle them as such, that led me to a cleanup of the original source code for blog, where I moved teh content folder into a different repo, called hugo_content, the former repo I called hugo_blog. ---\nIn my case, this means you have to clone the repo hugo_blog first go inside the new directory (cd hugo ), checkout its branch \u0026#39;hugo\u0026#39; and then do a clone of the repo hugo_content.\n"},{"id":33,"href":"/docs/digital_logic_x/x0_multiplication/","title":"X0_multiplication","section":"Digital Logic X","content":" Multiplication and Divsion Multiplication operations can be implemented in very different ways: Slow, as a serial operation, controlled by a micro program or fast in dedicated hardware.\nThe division is a more complex operation, and thus will be discussed in another post. Also for multiplication we set the scope to unsigned integer numbers.\nShift left and shift right For multipliers that are powers of two, the operation is very simple and can be implemented via a shift left.\nA shift left by one bit equals a multiplication by 2, as left shift by n bits equals a multiplication by 2^n.\nA shift right is a division by 2, a right shift by n bits is a division by 2^n\nThe multiplication algorithm Of course we are not only interested in the special case of base two multipliers, but rather want the multiplication operation to work on all numbers we defined above. We begin with a serial multiplication implementation.\nTo start with, we analyze the steps of a binary multiplication, which frankly does not differ much from a multiplication in the decimal system and is even simpler. We multiply 7 times 6 in the binary system which results in 42.\nmultiplicand x multiplier = product\n\\[ \\begin{aligned} 0111_2 \\times 0110_2 \\\\ \\hline 0000 \\\\ 011110 \\\\ 011100 \\\\ 0111000 \\\\ \\hline 0101010 \\\\ \\end{aligned} \\]\nAs we can see, based on that example, the multiplication operation is a sequence of shifting and addition. From this, we can now dissect the multiplication operation and derive an algorithm from it.\nFor details we refer to the original source: Rechnerentwurf: Rechenwerke, Mikroprogrammierung, RISC by R. Hoffman, third edition, Oldenbourg Verlag.\nWe have a multiplicator of X[n] and a multiplier of Y[m], then the product of the multiplication operation results in P[n+m], meaning the size of the operation, logically, is the addition of both the size of the multiplicator and the multiplier.\nBooth Algorithm The booth algorithm is one of the most efficient algorithm, as said above, it is again a series of shifting and addition. But here the three following rules have to be considered (see here for reference ): 1. The multiplicand is subtracted from the partial product upon encountering the first least significant 1 in a string of 1’s in the multiplier 2. The multiplicand is added to the partial product upon encountering the first 0 (provided that there was a previous ‘1’) in a string of 0’s in the multiplier. 3. The partial product does not change when the multiplier bit is identical to the previous multiplier bit.\nThe booth algorithm applied can be watched here: Booth hardware implementation and flowchart The booth multiplier, shown below, consist of the registers A,B for the multiplier and multiplicand and Q for the result. The register AC is the accumulator,the bit register BR and the register QR. An extra flipflop Qn+1 is used to check the multiplier.The flowchart is given below. Initially the accumulator and the flipflop Qn+1 are cleared, reset to zero.The sequence counter SC ist set to the number of bits n of the multiplier. Then the two bits in Qn and Qn+1 are checked. In case these are 10 the multiplicand gets subtracted from the partial product residing in the Accumulator AC. In case they are 01 the multiplicand gets additioned to the partial product residing in the Accumulator AC. When the two bit are the same (00,11) the partial product is unchanged. Since the subtraction and addition alternate, an overflow cannot occur. As next step the partial product and the multiplier (plus Qn+1) are shifted right. This is an arithmetic shift (ashr) which shifts AC and QR to the right, thus the sign bit in AC is unchanged. The sequence counter is decremented and the computational loop gets repeated n times. When multiplying negative numbers we need to find 2’s complement because it is easier to add instead of doing a binary subtraction.\n"},{"id":34,"href":"/docs/digital_logic/00_combinatorial_logic/","title":"00_combinatorial_logic","section":"Digital Logic","content":" This course about digital logic is splitted into two big chunks:\nCombinatorial circuits (without memory elements)\nSequential circuits (with memory elements)\nWhile combinatorial circuits consists of boolean gates interconnected without feedback function, sequential gates posses a memory function,which makes them able to progress to another state.\nA combinatorial circuit can have n -wide vector of inputs and an m -wide vector of outputs.\nCombinatorial circuits can be described in different ways: As a formula, a circuit, a truth table or a Karnaugh map. All these descriptions are convertible into each other.\nSo lets get started with the fundamental logic gates and boolean algebra in the next post.\n"},{"id":35,"href":"/posts/web/02_moving-to-hugo/","title":"Moving to Hugo","section":"Web","content":" Since one week my blog is build on the static-site-generator Hugo. I wanted to move to Hugo far earlier, due to the wide variety of themes. However this required the move from Asciidoc to Asciidoctor, and I experienced a few problems with the integration of Asciidoctor into my existing workflow. As the approach of rendering the latex-equations in the asciidoc-documents no longer worked, I decided to move on to client-based rendering of formulas, like done in KaTex and Mathjax.\nSo to install Hugo, Asciidoctor and its dependencies without headaches, we again make use of Docker and its huge ecosystem: Somebody already created Docker images for hugo with asciidoctor integrated, so we do not need to go through the sometimes cumbersome setup of Asciidoctor and its dependencies.\nWith docker installed, in the shell (for Linux and Mac OS, for Windows the powershell) we do a\ndocker pull klakegg/hugo:edge-asciidoctor which pulls an image with the latest Hugo version and Asciidoctor integrated from the Docker-repo klakegg.\nWe navigate to the parent-directory of our blog, and run the following command:\ndocker run -it -v $(pwd):/src klakegg/hugo:edge-asciidoctor new site hugo/blog This creates the skeleton of our new site, looking like that:\nold-blog hugo └── blog ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── static └── themes We have no theme installed yet, so go to themes and select your favorite, mine is Book. We install it via simple download or via git:\ncd hugo/themes git clone https://github.com/alex-shpak/hugo-book and add the line:\ntheme = \u0026#34;hugo-book\u0026#34; to our config.toml. While we are at it we also add the following policy, necessary since hugo version 0.91, to our config.\nExample config.toml block\n[security] enableInlineShortcodes = false [security.exec] allow = [\u0026#39;^dart-sass-embedded$\u0026#39;, \u0026#39;^go$\u0026#39;, \u0026#39;^npx$\u0026#39;, \u0026#39;^postcss$\u0026#39;, \u0026#39;^asciidoctor$\u0026#39;] osEnv = [\u0026#39;(?i)^(PATH|PATHEXT|APPDATA|TMP|TEMP|TERM)$\u0026#39;] Now we need to move the content from the old blog to new, we do something similar to this:\ncp ../old_blog/pages ../hugo/content/docs cp ../old_blog/posts ../hugo/content/posts cp ../old_blog/images ../hugo/content/docs/images Now we need to convert the adoc-headers to the hugo frontmatter format, and also adapt the asciidoc syntax to the new.\nTo make our new blog digesting the equations and formulas written in Latex, we need to add the script for KaTex / Mathjax at some layout-file in the theme of our choice: Integrate KaTex\nTo see what we need to change, we execute the hugo-server and in the browser head over to the given address:\nhttp://localhost:1313\ndocker run -it -v $(pwd):/src -p 1313:1313 swehrend/hugo-ext-asciidoctor:edge-ext-debian server --renderToDisk which results in something similar to this:\nIf we are satisfied with the result, we can deploy our site with an rsync to our webspace, something similar to the following command:\nrsync -rav public/ wehrend@giclas.uberspace.de:/var/www/virtual/wehrend/html "},{"id":36,"href":"/docs/digital_logic/07_risc_v/","title":"07_RISC-V","section":"Digital Logic","content":" Digital design meets computer architecture RISC vs CISC and The RISC-V architecture Existing processor types can be classified by their instruction type set: Reduced instruction set computer (RISC), Complex instruction set computer (CISC) and hybrid forms. While mini processors like ARM for embedded systems mostly utilise reduced instruction sets,todays workstation and Server Architectures (x86, x86_64) are hybrids of RISC and CISC. The idea of a reduced instruction set is to avoid big complex instructions and multiple different addressing modes (as those typically used in x86 architectures). Advantages of a RISC architecture are shorter pipelines which allows faster clocking. RISC architectures follow a simple scheme: \u0026#39;Fetch → Decode → Fetch Operands → Execute → Write Back\u0026#39; Also instructions have a constant length, memory operations are divided from arithmetic operations, which is known as Load/Store-architecture. RISC-V is an open standard for the instruction set archtitecture (ISA). Most of this post is referenced from the popular book Computer Organization and Design (RISC-V) Edition by Hennessey and Patterson.\nRISC-V Assembler Here we introduce the RISC-V assembler. The subset shown here is a bit bigger than the one we will implement further down the line. For example also immediate instructions like \u0026#39;addi\u0026#39; are shown, necessay as a way to load constants into registers. The example program shown below, counts from 0 to 10, utilizing a loop.\nADDI x2, x0, 1 ADDI x3, x0, 10 loop: ADD x1, x1, x2 SW x1, 4(x0) BNE x3, x1, loop HLT Register-type: Instruction [dest. reg] [reg1] [reg2]\nLoad / Store-type: Instruction [dest. reg] [byte offset(reg1)]\nBranch-type: Instruction [dest. reg] [reg1] [dest. label]\nFor the load / store instructions the reg1 contains the start address while the byte offset contains the size of the value loaded into the register (normaly 4) / respectively written to the memory.\nAn overview of the instruction formats of the different types is given below:\nA minimal Implementation The minimal working subset of a RISC-V implementation contains the following instructions:\nArithmetic-logical instructions \u0026#39;add\u0026#39;, \u0026#39;sub\u0026#39;, \u0026#39;and\u0026#39; and \u0026#39;or\u0026#39; [Register-type instructions]\nMemory reference instructions like load word (lw) and store word (sw) [Store-type instructions]\nConditional branch instruction(s) like branch-if-equal (beq) [Branch-type instructions]\nWe will see how the instruction set architecture choosen, affects performance-related key aspects like clock rate and Cycles-per-instruction (CPI). We will also see, that the different instruction types only differ in the later stages of the Fetch→Decode→ Execute-cycle\nFor every instruction the first two steps are identical:\nThe program counter (PC) points to the current code that will be executed.The address is sent to the memory to fetch the current instruction from the memory.\nRead two (one for the lw-instruction) registers, the instruction fields contains the register numbers.\nFor the next steps the actions depend on the instruction type, but are still utilizing / sharing the same resources. For example the ALU is used by Register-type instruction to compute data, while it is also used by Store-type instructions to compute the address, and the Branch-instructions for the equality test. Only after that ALU, the different instruction types really differ.\nAs we will see the abstract schematic shown below does not explain all cases. We need another schematic extended, showing also the control parts.\nThe Fetch-Decode-Execute cycle for the different instruction types We will start with the common Fetch-Decode-Execute cycle of a common RISC processor, and demonstrate the working principle of it for typical instructions.\nThe full cycle is: Fetch → Decode → Fetch Operands → Execute → Write Back\nType example instruction Fetch Decode Fetch Operands Execute Write Back Register\nadd, sub,and,or\nfetch instruction, increase PC by 4\nDecode instruction\nFetch operands from registers\nExecute calculation in ALU\nWrite value back to data memory.\nStore\nlw,sw\nfetch instruction, increase PC by 4\nDecode instruction\noperand\nCalculate address\nread / write data from / to memory\nBranch\nbeq\nfetch instruction,set PC to destination address\nDecode instruction\nFetch operands from registers\nTest for equality (for beq)\nswitch multiplexer for address calculation to second adder\nThe instruction part To explain a cpu on this abstract level, we need to introduce some more concepts, e.g that an instruction, stored in memory, is accessible under a specific address. An address in RISC-V standards is a 32 bit long value, pointing to a certain cell in a memory array. The program counter (PC) is a register which points to a certain address in the memory / register file. The program counter is connected to the first address-adder with a contant intger of 4 (the adress offset, 4 * 1 byte = 32 bit).\nIf the instruction in the memory is an address modifying instruction, the given value will be added by the second address-adder. This way we can generate jump instructions.\nThe data path The data path shows some elements we already are familiar with - the ALU - as well as elments we are not yet familiar with - the memory blocks - on the right the so-called register file and on the left the data memory. Both inputs of the ALU are connected to one (different) register.\nThe control part The control part is the most black-boxed element we see. We know already how the multiplexers work, and we see already a feedback line for the branch control. But most of the elements in this abstract view remain unknown to the reader. Let us change this by having a closer look into it.\n"},{"id":37,"href":"/docs/digital_logic/06_memory/","title":"06_Memory","section":"Digital Logic","content":" Memory Organization In this blog post the author will introduce the different types of semiconductor memory. This is a wide field, so the goal here is to focus on the most important ones and draw the differences between the different types.\nThe Memory hierarchy As in computing all is about performance, we first have a look at the memory hierarchy. As you can see in the pyramid below, memory is ordered in layers. The slowest elements -also the ones with highest latency - are at the bottom of this pyramid, while the fastest ones are shown at the apex. Imagine your desk is the actual CPU, with an open book laying in front of your eyes. This is the register. Now you read in this book a reference to another book in your bookshelf. Your bookshelf is the cache here. The cache itself is again layered. Lets say L1-cache is the bookshelf in your room, L2-cache the bookshelf in another room and L3-cache books stored in a box in the same room. If you now have a reference in your current book (the one on your desk), that refers to a book you do not possess, you need to go to the public library. The public library is your RAM. The access times are really high. And lets say the book you need is also not available there, and they must order it from a library in another city. Then you got to the level at the bottom, which is the disk storage unit.\nAt the bottom is also the low-priced memory (per byte). The higher you go on the hierarchy the costlier the memory becomes. In this article we will expand our knowledge about the RAM. Caches are more complex and will eventually be handeled in a future article.\nRAM and ROM The image below shows the overall organization of a ram circuit, RAM stand for random access memory, so it means a memory with arbitrary access. Simply put, you set an address in and get the data which is stored under the given address location out.The schematic given here also holds for Read only memory (ROM). Complementary to ROM, which is persistent, RAM is volatile. So it needs ongoing power supply,otherwise it loses its stored data.\nAs can be seen the main parts apart from the memory itself are column- and row-decoder, as well as read / write amplifier. The address-decoder just consists of well-known combinatorial logic, while the amplifier are a bit more complex. The blue dots on the intersection of rows and columns mark the placements of the memory cell, depending on the type of memory, those differ and are explained in the next section.\nThe different memory cells static RAM (SRAM)\ndynamic RAM (DRAM)\ntransistor # 4\ntransistor # 1\ntransistor # 6\nSRAM vs. DRAM The static RAM (SRAM) cell has the advantage of holding the stored value as long as the power supply is not interrupted. Its clear disadvantage is the circuit effort of minum 4 transistor (for an nmos design) but regularly 6 for a cmos design.That makes it ideal for small pockets of memories like registers and cache located near the cpu. Complementary the dynamic RAM (DRAM) cell needs just one transistor and one capacitor to hold the stored value, but needs to be refreshed periodically.\nThe register file At this point the author wants to introduce the so-called register file. This is a type of memory which can have multiple read ports. which is useful as input for the ALU we introduced in the last blog post. While the amount of read ports is theoretically unlimited, the amount of write ports is usually one. The reason, as the vivid reader can imagine is to mitigate hazards, which is with multiple write ports difficult to handle.\n"},{"id":38,"href":"/docs/digital_logic_2/11_clocks_and_registers/","title":"11_Clocks_flipflops_and_registers","section":"Digital Logic 2","content":" Clocks, Flipflops and registers In this blog post the author will introduce multiple elements needed at a later stage.\nRegister-Transfer-Level needs a clock source As for now we only learned about combinatiorial logic, which works without any clock source - every signal is just delayed by the time it needs to travel through the circuit. This is known as asynchronous. But for more sophisticated tasks, sequential circuits, having registers storing the input and output signals are necessary to get correct results. This is known as synchronous. Most, if not all designs used nowadays are synchronous, due to a lower design complexity.\nRegister-Transfer-Level\nThe blue parts in the image above are showing registers where the values are stored, we will see later how those are implemented, lets first have a look at the clock source which is needed.\nThere are different ways to create a clock source:\nA crystal oscillator\nA ring oscillator\nThe former one is the classical, the later one a more modern variant.\ncrystal oscillator\nring oscillator\ntypical frequence range: 1Mhz..100Mhz\ntypical frequence range: 1Hz..15Mhz(discrete layout)\nfrequency determined by crystal geometry\nfrequency determined by propagation delay and number of gates\naccuracy mostly dependent from temperature; for precise applications crystal ovens are used\naccuracy mostly dependent from power supply stability\nThe crystal oscillator The crystal oscilltor is a clock source based on a quartz crystal. The frequency is dependent on the geometry of the quartz. Crystal oscillators are available in a metal box housing, with additional wiring, with the quartz being the heart of the circuit. The circuit is commonly based on the Pierce oscillator.\nTheir accuracy is mostly dependent on the temperature,so for applications with high accuracy needs, they are housed in a quartz oven, holding the quartz on a constant temperature. An interesting teardown of such an oscillator is available on Ken Shirriffs blog.\nThe ring oscillator Another common source of a clock source is the ring oscillator. The trick here is to chain an odd number of inverter gates and feedback the output of the last inverter as input to the first inverter. This way we create an oscillating circuit.\nThe frequency is dependent on the number of inverters as well as the propagation time Tp (see the equation below). The time the signal needs to travel trough the gate is known as propagation time Tp.\n\\[f_{ro} = \\frac{1}{2nT_{p}}\\]\nHere the accuracy is mostly dependent on the stability of the power supply. An example where it is used - e.g. the 8087, intels® Floating Point Unit - is again provided by Ken Shirriffs blog. As shown there, the frequency can be decreased by adding an RC-network between the inverters.\nThe classic RS-flipflop The classic flipflop consists of two Nand gates which outputs are feedback’ed to the complementary gate, as can be seen in the table below. Below the circuit the truth table is given. As can be seen the flipflop locks the output to one state, \u0026#39;1\u0026#39; or \u0026#39;0\u0026#39;. If both inputs are set low, the output is undefined (and conforms to the preferred position).\nRS-flipflop structure\nRS-flipflop symbol\n̅R\n̅S\nQ\n̅Q\ncomments\n0\n0\n1\n1\ninvalid\n0\n1\n1\n0\nReset\n1\n0\n0\n1\nSet\n1\n1\nQ\n̅Q\n— One application of the classic RS-flipflop is to debounce switches.\nBut for most applications a more evolved flipflop is necessary. Let’s have a look at the (D)ata-flipflop.\nThe D-flipflop In the D-flipflop the circuit of the RS-flipflop is preceeded by two Nand gates, controlled by a clock impulse. Only when the clock is high (i.e. \u0026#39;1\u0026#39;) the date applied to the (D)ata-input is valid and stored in the RS-fliplop. Otherwise the applied data input is invalid.\nD-flipflop structure\nD-flipflop symbol\nClock\nD\nQ\n̅Q\ncomments\n🠓 \u0026gt;\u0026gt;0\nx\nQ\n̅Q\nno change\n🠓 \u0026gt;\u0026gt;0\n1\n1\n0\nReset\n🠑 \u0026gt;\u0026gt;1\n0\n0\n1\nSet\n🠑 \u0026gt;\u0026gt;1\n1\nQ\n̅Q\n-\nA binary counter Using the D-flipflop we got acquainted with in the last section, we can construct an (asynchronous) binary counter. This output can be used as adresses for a ROM table, as we will see in another blog post.\nAsynchronous binary counter with D-flipflops\nUsing the outputs independent, it can be seen that the counter also works as frequency divider: On every output the frequency is divided by two referenced to the previous one.\nRegisters What are registers? Registers are used to hold respectively store values. Every slighlty more complex nowadays CPU has copious quantities of registers inside. Register sizes vary widely dependent on the application. Reaching from status registers only holding one bit to registers over 32 and 64 bit for regular registers until vector registers with a size of 64 bytes (= 512 bits). Those registers are named after a certain scheme, in some architectures with numbers (e.g. MIPS and ARM), other times with a more comnplex scheme of alphabetic numbers (like in x86 architectures).\nIn the previous sections we have learned about the flipflop. These are the building blocks of registers. As can be seen in the picture above every flipflop is clocked by the same signal. We will also often use the term accumulator. Accumulators are registers which are source and destination registers at the same time. So e.g. on addition they store one input value and after the operation, holding the result in the same register.\n"},{"id":39,"href":"/docs/digital_logic/05_alu/","title":"05_ALU","section":"Digital Logic","content":" The ALU, the swiss knife of every cpu Today the author wants to introduce an important part of every cpu: The arithmetic logic unit (ALU), we already know about some functions presented in the blog posts before. In this post we want to close the gaps systematically. Time for a short recap: The logic functions \u0026#39;and\u0026#39;,\u0026#39;or\u0026#39;,\u0026#39;not\u0026#39; and \u0026#39;xor\u0026#39; were introduced, also the arithmetic functions \u0026#39;add\u0026#39; and \u0026#39;sub\u0026#39; for integers were shown. Now we want to build most of those functionalities in one unit, the 1-bit alu cell.\nFunction description Ainvert Binvert Operation and\na \u0026amp; b\n0\n0\n00\nor\na | b\n0\n0\n01\nadd\na + b\n0\n0\n10\nsub\na - b\n0\n1\n10\nslt\na \u0026lt; b\n0\n1\n11\nnor\na nor b\n1\n1\n00\nnand\na nand b\n1\n1\n01\nA 1-bit ALU cell To keep things simple we implement an ALU for 1 bit, which then can be adapted to every bitwidth simply by repitition. We introduce an implementation designed by Hennessey and Peterson, quoted from the popular book Computer Organization and Design (RISC-V) Edition by Hennessey and Patterson.\nThe implementation will support the fundamental operations \u0026#39;and\u0026#39;,\u0026#39;or\u0026#39;, \u0026#39;add\u0026#39; and \u0026#39;sub\u0026#39;. As we already learned the subtraction can be realised two’s complement: Inverting the input B and setting the carry-in to one.\nConstruct an n-bit ALU The 1bit ALU-cell we created in the first section, can be chained to an n-bit width-alu. The last ALU-cell in the chain, differs a bit from the regular cell as it also includes an overflow-detection circuit. We will get to it later in the article.\nSet-less-than We want the complete ALU to support another fundamental instruction set-less-than (slt), necessary to allow branch-operations later on. For this operation the addional input \u0026#39;less\u0026#39; is designed. So the ALU supports an instruction that in C looks like:\n(a \u0026lt; b)? 1 : 0\nThis can be simply implemented by subtracting b from a, and testing if the value is less than zero. In the implementation, every alu-cell in the chain but the least-significant-bit, gets a zero on the \u0026#39;less\u0026#39; input. The first alu-cell gets the result of the last one, which is representing the most-significant-bit. As the msb also represents the sign bit, we can simply route as input to the least-significant and we are done. This is - however - not true, in case the subtraction might result in an overflow.\nAlso, we add a nor-gate with inputs from all result bits to detect zero.\nOverflow Detection The last 1-bit ALU cell in the chain has another output \u0026#39;overflow\u0026#39;, to indicate an overflow of the addition of two integer values. The encourages the inclined reader to derive the truth table and circuit as an exercise.\nFor a two’s complement interpretation overflow occurs in two cases:\nTwo positive numbers are added, the result becomes negative\nTwo negative number are added, the result becomes positive\nThe truth table for overflow is as follows (original source can be found here)\nBinv a(n-1) b(n-1) c(n-1) OF 0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n0\n1\n0\n0\n0\n0\n1\n1\n0\n0\n1\n0\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n0\n1\n0\n1\n1\n1\n0\n1\n0\n0\n0\n0\n1\n0\n0\n1\n0\n1\n0\n1\n0\n0\n1\n0\n1\n1\n1\n1\n1\n0\n0\n1\n1\n1\n0\n1\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n0\nThe circuit generated by Logisim is accordingly:\nMultiplexer \u0026amp; Demultiplexer To select one line out of multiple sources we need another key component, the multiplexer. We can find multiplexer in multiple places, however in an ALU it used to select one of the logic or arithmetic operations, we will see that later.\nThe demultiplexer- as the name suggest- does the exact opposite task and distributes signal on one line (input) to one of multiple outputs, depending on the selection bit(s).\nMultiplexer in complementary Pass-Transistor Logic We show and implement the multiplexer in pass-transistor-logic, as this is the most resource-efficient design…​\n"},{"id":40,"href":"/docs/digital_logic/04_signs/","title":"04_Signs","section":"Digital Logic","content":" Extending the binary system While in the previous blog post about addition, the binary numbers had only one interpretation, we extend the system here to include negative (integer) numbers.\nThe simplest approach we can think of is to use the most significant bit (MSB) as sign bit, where \u0026#39;0\u0026#39; ist intepreted as sign \u0026#39;+\u0026#39; and \u0026#39;1\u0026#39; is interpreted as \u0026#39;-\u0026#39;. However as we see in the following calculation this does not work as expected:\nOne complement As the previous approach does not fullfill the requirements let us introduce the one complement and two complement here. The one complement is just an inversion of every bit, independent from its significance.\n\\[ \\begin{array}{l} 00000011_{2} = +3_{10} \\\\ 11111100_{2} = -3_{10} \\end{array} \\]\nTwo complement However,as can be seen in the panel below, there is still a mismatch on addition. So, as a second step the inverted number is incremented by one. This leads us to the so-called two’s complement as seen below.\n\\[ \\begin{array}{l} 00000011_{2} = +3_{10} \\\\ 11111101_{2} = -3_{10} \\end{array} \\]\nAs can be seen in the following calculations, with the two’s complement we get the correct results. Overflow As can be seen, in both cases, for one- and two-complement an arithmetic overflow is produced. It is very dependent on the cpu achitecture how those are handled, but in every case you get the information as a flag (v) .\nImplementation of subtraction in a fulladder To extend the full-adder with the logic for subtraction we do not need to design from scratch all again. The properties of the xor-gate allows the first step of the two’s complement, the inversion of every bit, while for the second step the increment, we simply use \u0026#39;1\u0026#39; of the subtraction switch as carry-input for the first full-adder stage.\nOverview table for the number range -7..+7 decimal\nbinary\none complement\ntwo complement\n+7\n0111\n0111\n0111\n+6\n0110\n0110\n0110\n+5\n0101\n0101\n0101\n+4\n0100\n0100\n0100\n+3\n0011\n0011\n0011\n+2\n0010\n0010\n0010\n+1\n0001\n0001\n0001\n+0\n0000\n0000\n0000\n-0\n1000\n1111\n-\n-1\n1001\n1110\n1111\n-2\n1010\n1101\n1110\n-3\n1011\n1100\n1101\n-4\n1100\n1011\n1100\n-5\n1101\n1010\n1011\n-6\n1110\n1001\n1010\n-7\n1111\n1000\n1001\n"},{"id":41,"href":"/docs/digital_logic/03_binary_system/","title":"03_binary_system","section":"Digital Logic","content":" The Binary System All computer we act with on a daily base do not know about the decimal system we are using, based on the ten digits at our hands. All they know about are the states on and off. We build an imaginary circuit with a power source a control light - here an LED (Light Emitting Diode) - and a switch, closing the connection let the light flash. An off light counts as zero, and on light counts as one. Simple as it.We switch the light on and get a one.\nNow we extend this installation with a second light and switch left to current one. We switch the left light on and the right on. What we get as a result is a \u0026#39;2\u0026#39;. Switching the right light on again gets us to 3. Like in our decimal system, the significance of the left light is higher (at least in our example), only the factor differs, instead of 10 the factor is 2. We denote the significance with 2^n where n is the position of the light. Every switch is a bit - more exactly the switch is the input and the LED is the output. So with four switches -half a byte - we can count from 0 to 15, while with eight switches - a byte - we can count from 0 to 255. This scheme can be extended as needed.\nBinary\nHex\nunsigned Interpretation\n0000\n00\n0\n0001\n01\n1\n0010\n02\n2\n0011\n03\n3\n0100\n04\n4\n0101\n05\n5\n0110\n06\n6\n0111\n07\n7\n1000\n08\n8\n1001\n09\n9\n1010\n0A\n10\n1011\n0B\n11\n1100\n0C\n12\n1101\n0D\n13\n1110\n0E\n14\n1111\n0F\n15\nA simple Ripple-Carry adder Let us do some simple calculations with the goal to derive the necessary logic for an adder-unit. The addition is done like learned in elementary school, just that this time we add binary numbers. The first example works while the second one producesa carry flag besides the (wrong) result.\nScheme for combinatorial circuit We develop the RC-adder circuit according to the following scheme, applied to evaluate combinatorial circuits\nDefine inputs and outputs\nConstruct truth table\nEvaluate boolean equations / simplify\nDraw optimized combinatorial circuit\nTruth table for fulladder cell fulladder cell c_in A B c_out sum 0\n0\n0\n0\n0\n0\n0\n1\n0\n1\n0\n1\n0\n0\n1\n0\n1\n1\n1\n0\n1\n0\n0\n0\n1\n1\n0\n1\n1\n0\n1\n1\n0\n1\n0\n1\n1\n1\n1\n1\n\\[ \\begin{aligned} s \u0026amp; = (\\overline{c_{in}} \\land \\overline{A} \\land B) \\lor (\\overline{c_{in}} \\land A \\land {\\overline{B}}) \\lor (c_{in} \\land \\overline{A} \\land \\overline{B}) \\lor (c_{in} \\land A \\land B) \\\\ \u0026amp; = \\overline{c_{in}}(\\overline{A} \\land \\overline{B}) \\lor (A \\land \\overline{B}) \\lor c_{in}\\overline{A} \\land \\overline{B}) \\lor (A \\land B \\\\ \u0026amp; = \\overline{c_{in}}(A \\oplus B) \\lor c_{in}(\\overline{A \\oplus B}) \\\\ \u0026amp; = A \\oplus B \\oplus c_{in} \\end{aligned} \\]\n\\[ \\begin{aligned} c_{out} \u0026amp; = \\overline{c_{in}}(A \\land B) \\lor c_{in}(\\overline{A} \\land B) \\lor c_{in}(A \\land \\overline{B}) \\lor c_{in}(A \\land B) \\\\ \u0026amp; = \\overline{c_{in}}(\\overline{A} \\land \\overline{B}) \\lor (A \\land \\overline{B}) \\lor c_{in}\\overline{A} \\land \\overline{B}) \\lor (A \\land B \\\\ \u0026amp; = \\overline{c_{in}}(A \\land B) \\lor c_{in}[(\\overline{A} \\land B) \\lor (A\\land \\overline{B}) \\lor A \\land B] \\\\ \u0026amp; = \\overline{c_{in}}AB \\lor c_{in}(A \\oplus B) \\lor c_{in}AB \\\\ \u0026amp; = (\\overline{c_{in}} \\lor c_{in})AB \\lor c_{in}(A\\oplus B) \\\\ \u0026amp; = AB \\lor c_{in}A \\oplus B \\end{aligned} \\]\nA simpler approach Instead of the circuit of a fulladder cell, by only considering the both input signals without the carry, we evaluate the half-adder cell.\nA B c_out sum 0\n0\n0\n0\n0\n1\n0\n1\n1\n0\n0\n1\n1\n1\n1\n0\nAs we can see, the halfadder consists only of the two gates \u0026#39;AND\u0026#39; and \u0026#39;XOR\u0026#39;. Two halfadder and a separate \u0026#39;OR\u0026#39;-gate for the carry-signal result in a fulladder.\n\\[ \\begin{array}{c} c = x \\land y \\\\ s = x \\oplus y \\end{array} \\]\nCarry-Lookahead Adder To avoid the long delay for the carry signal in the rc-adder, the carry-Lookahead has been developed. The signals, (g)enerate and (p)ropagate are defined as follows (i being the index of the significance):\n\\[ \\begin{array}{c} g_{i} = a_{i} \\land b_{i} \\\\ p_{i} = a_{i} \\lor b_{i} \\end{array} \\]\nFrom these helper signals the next carry-value is calculated:\n\\[ c_{i+1} = g_{i} \\lor c_{i} \\land p_{i} \\]\n\\[ \\begin{aligned} c_{1} \u0026amp; = g_{0} \\lor c_{0}p_{0} \\\\ c_{2} \u0026amp; = g_{1} \\lor (g_{0} \\lor c_{0}p_{0})p_{1} = g_{1} \\lor g_{0}p_{1} \\lor c_{0}p_{0})p_{1} \\\\ c_{3} \u0026amp; = g_{2} \\lor c_{2}p_{2} = g_{2} \\lor (g_{1} \\lor g_{0}p_{1} \\lor c_{0}p_{0}p_{1})p_{2} \\\\ \u0026amp; = g_{2} \\lor g_{1}p_{2} \\lor g_{0}p_{1}p_{2} \\lor c_{0}p_{0}p_{1}p_{2} \\\\ c_{4} \u0026amp; = g_{3} \\lor c_{3}p_{3} = g_{3} \\lor (g_{2} \\lor g_{1}p_{2} \\lor g_{0}p_{1}p_{2} \\lor c_{0}p_{0}p_{1}p_{2})p_{3} \\\\ \u0026amp; = g_{3} \\lor g_{2}p_{3} \\lor g_{1}p_{2}p_{3} \\lor g_{0}p_{1}p_{2}p_{3} \\lor c_{0}p_{0}p_{1}p_{2}p_{3} \\\\ \\end{aligned} \\]\nCarry-Lookahead Adder circuit\nAs can be seen the circuit complexity increases with the significance. The table below shows the total view of these different adder implementations. Of course the topic of adders is much broader as displayed here, we only introduced the concepts.\nRipple-Carry Adder\nCarry-Lookahead Adder\nIn the next blog post we will see, how to extend the range of numbers to the negative space.\n"},{"id":42,"href":"/docs/digital_logic/02_xor/","title":"02_XOR","section":"Digital Logic","content":" XOR As there are a lot of important applications for the exclusive-or (XOR) operation it is dedicated an own blog post. Two of the most important are:\nXOR operations are often used in a Linear Feedback Shift Registers (LFSR). LFSR are a crucial step in scrambler / descrambler respectively, which are used in transmitters / receivers\nPart of an encryption algorithmus\nLast but not least an important part of a halfadder.\nThe exclusive-or operation xor which is also termed as antivalence is denoted as A ⊕ B = Q. Its truth table is shown below\nA\nB\nQ\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n0\nCMOS XOR\nSome Applications Linear Feedback Shift Register (LSFR) As described above XOR gates are used in Linear Feedback Shift Registers (LFSR). LFSR are often used for test pattern generation. The author selected a simple example of a 3-bit LFSR found in a white paper from Texas Instruments.\nFor this example we need to take a big leap and enter the area of sequential circuits. These are circuits which make use of feedback. The chosen example generates pseudo-random test patterns according to the table below. The registers are feed with the seed value 111, after 8 clock cycles the patterns repeat again. Of course real test pattern generators have a much higher bit width.\nCLK\nFF1\nFF2\nFF3\n0\n1\n1\n1\n1\n0\n1\n1\n2\n0\n0\n1\n3\n1\n0\n0\n4\n1\n0\n0\n5\n0\n1\n0\n6\n1\n0\n0\n7\n1\n1\n0\n8\n1\n1\n1\nHalfadder In the next blogpost we dive deeper into the halfadder application. The halfadder essentialy consists of the two following particular equations for sum (making use of the XOR ) and carry (using a simple AND).\n\\[ \\begin{array}{c} c = x \\land y \\\\ s = x \\oplus y \\end{array} \\]\n"},{"id":43,"href":"/pages/prequel-short-introduction-to-electronics/","title":"Prequel: Introduction to electronics","section":"Pages","content":" While I was about to write the implementation part of the boolean algebra post, the basic logic gates, the writing process got quickly out of hand and I caught myself to write more about less connected topics like explaining basic electronic components and their implementation on silicon than the actual content, here shall be the place for those excursions. This is not meant to be a complete reference more a supplement to existing literature. \u0026#39;\u0026#39;\u0026#39;\nFree electrons and electric current What is electricity? Broadly speaken it is the flow of electrons in a conductor. In laymans term you can say, electrons on the outer shell - also called as valence band - of an atom are hopping from the valenece band of an atom to the adjacent one. So essentialy electricity constitutes the movement of electrons through matter. In practical application this matter is an electrical circuit, but also for example the lightning discharge occurs, in this case the ionised air can be considered as the (short) circuit.\nGoing atomic: Conductors…​ The first group of elements (or compounds) we will introduce here are the conductors. Some important representants of this group are the elements aluminium and copper which both are indispensible for electric transmission lines and power grids. As the table below depicts, both elements have free electrons available on it’s valence shell, which as described above, are needed to allow the hopping of electrons from one atom to another and thus allow movement of electrons, making the element (in its pure form) a conductor.\nOf course in real world there are multiple factors counteracting to the idealized properties proposed here. E.g. we have to consider among others that metals oxide when coming in contact with oxygen, which builds up a thin but effectively isolating layer on the surface of the metal, preventing a good contact. We might discuss such effects later. For now just let’s continue on the topic…​\nconductor\natomic model of aluminium (13)\natomic model of copper (28)\nvalence shell / free electron(s): 3 (3)\nvalence shell / free electron(s): 1 (1)\n\\large \\[Q = N \\cdot (\\pm e)\\]\n\\large \\[I = \\frac{\\Delta Q }{\\Delta t}\\]\n…​and not so conductors The second group of elements we want to introduce here are elements which conductivity is (highly) dependent on its purity degree and environment factors like temperature. Representants of this group are called semiconductors. Carbon and silicon are examples showing up on the periodic table. The author picked those two elements as they have very exciting properties in regards to - but not limited to - conductivity. This is due to the number of valence electrons on the outer shell.\nsemiconductor\natomic model of carbon (6)\natomic model of silicon (14)\nvalence shell / free electron(s): 4 (0)\nvalence shell / free electron(s): 4 (0)\nSo why does carbon and silicon have so poor conductivity properties compared to copper despite their four electrons on the valence shell electrons?\nThe answer lies in the simple fact, that both carbon as well as silicon form a lattice, using up all electrons of the valence shell.\ncovalent bonding of carbon\ncovalent bonding of silicon\nsemiconductor\nVoltage and potential The table below shows the common symbols for voltage sources. On the left side an ideal voltage source is shown, while on the right side a real voltage source is shown. As you can see the real source resembles a battery cell. Of course the voltage source can differ from an actual battery cell, and also most often is not displayed implicit.\nideal voltage source\nreal voltage source\nAn ideal voltage source provides a voltage of a certain level.\nAs we can see in below shown circuit schematics a voltage is just the difference between two potentials. In the first example (left) the junction at the bottom is choosen as reference point, as it is signaled as ground. So the voltage amounts to 1.5V for U_B0 respectively to 3V for U_A0. Whereas in the example on the right the junction between the battery cells is choosen as reference point and ground. The potential differences we measure here are: U_A0 = 1.5V and U_B0 =-1.5V. As a remark dual power supplies like that with - however with a voltage range of 12…​15V - are often used for applications with op-amps.\nSingle power supply\nDual power supply\n\\large \\[U = \\phi_{1} - \\phi_{0}\\]\nThe next image shows the simplest possible circuit: A voltage source with a resistor in series. Physically seen every resistor is just a converter from electrical energy to thermically energy, thus heat.\nResistors are generally used in circuits to drop the voltage to the desired level, respectively limit the current flowing between certail paths of a circuits. We will learn about it in the next section.\nOhm’s law and lead resistance Exercise: Measure Resistance To execute the following exercise you need one voltagemeter and one amperemeter (or just two multimeters), a variable voltage source and some sample wires of different materials but same in length and diameter. If you do not have the equipment, in theory you could also simulate this exercise in Qucs or LTspice.\nBut as we need to upfront define the parameters of sample wires we want to measure, this approach kinda torpedoes the purpose of the exercise, of learning how to do an indirect measurement of electrical resistance.\nConnect the equipment according to the figure shown below, with the sample wire as the resistor Rx.\nNow, for every wire measure the voltage and the current and plot a graph of it with voltage on x-axis and current on y-axis. You will see that for different materials, you get a linear graph but with a different slope. So you have find a relation between voltage current and resistance. In addition after measuring the different wires you can also use pen \u0026amp; paper: draw a line with a pencil or scribble a small area. Now connect these with the probes of the measurement assembly. You will see, that also the graphit trace work as a conductor - not an optimal one but a conductor.\nThis observance leads us to the most important formula you will encounter in an electrical engineering 101 course, Ohm’s law.\n\\large \\[ R [\\Omega] = \\frac{U [V]}{I [A]}\\]\nWhen we rearrange this equation to its simpler interpretable form, U = R·I, we recognize, that the voltage drop (U) on the Resistor corresponds to the resistance value ( R) times the current flowing thru (I). We did not speak about the current yet and we will postpone this to a later section. As indicated in the brakets the unit of Resistance is Ω.\nIn the image below the rules for series and parallel connection of resistors are shown.\nFor the series connection the values simply adds up like we have seen it for the voltage sources, while for the parallel connection see same applies, however for the conductance G which is the reciproce of the resistance R and measured in S(iemens).\nSo we discovered that the materials differ in their electrical conductivity - which is the reciprocal of the electrical resistance - some are good (conductor) some are pretty bad and unusable (non-conductor) but nevertheless useful as dielectric, as we will see in the next section and some in between. We also need to note, of course that the conductivity is not only dependent on the material itself but also its geometries (further it is also dependent on the temperature, but I will not go into this here), you know we handle with physics, so another useful formula / equation in this context is the following.\n\\large \\[ R = \\frac{\\rho L}{A}\\]\nFor the most common rectangle form - like a strip conductor on a PCB - area A resolves to width times height\n\\large \\[ R = \\frac{\\rho L}{A} = \\frac{\\rho L}{w \\cdot h}\\]\nSo the total resistance of a wire or a strip conductor on a PCB is dependent upon the specific resistivity ρ, the length of the conductor and the area used to transfer the current. Logically the specific resistivity as well as the length of the conductor increases the resistance while the area counteracts it.\nWhy do we need to know this?\nAt this point you may ask why it is important to know this if we can just pull a schematic of our DIY project and realize it with discrete components on a breakout board- the answer is simple scale - it might work for this simple hobbyist example but lack scalibility,costs and / or reliability.\nThe further we get down on scale the more important parasitic effects become - we will learn about it in the subsequent sections.\nResistance measurement\nBelow figure shows the principal of resistance measurement applied within a digital multimeter - leaving aside the range switch. On the left side we have a constant current source, in the middle the resistor - or wire under measurement and on the left a voltmeter measuring the voltage. As with the constant current source the overall current in the circuit is known, the resistance can be scaled from that with the voltage measured.\nThe Resistor The electrical component itself comes in all shapes and sizes dependent on the area of application. the miniature ones for surface mounted devices technique, used in all higher integrated electronic devices, the average 1/4 Watt resistor based on coal with 5 percent tolerance ( in the picture below shown central) and the more precise metal film resistors with 1 percent tolerance (blue, shown right in the picture). There are resistors with mechanically adjustable resistance called potentiometer (like the ones shown left in the picture ) Other types are varistor where the resistance is dependent upon the voltage applied, some other types like NTC / PTC depending on the temperature.\n////Explain structure and costruction of smd resistors////\n"},{"id":44,"href":"/docs/digital_logic/01_boolean_algebra/","title":"01_boolean_algebra","section":"Digital Logic","content":" Boolean Algebra and Basic Logic Gates We are starting (the journey) with three very basic logic functions (or operations), which despite their simplicity already are valid instructions of a regular CPU:\nNOT, AND and OR\nLogical functions - also called operations, the author will use both terms interchangebly here - can be described in various ways, most often it is described implicit as boolean equation, but it can also be explained explicit in a truth table.\nA truth table is a table with the a column for every input and a column for every output. So it shows the output respective the outputs of the function for all possible combinations of inputs. Also they can contain columns with intermediate values.\nThe truth tables shown in this lesson are in general very small and show only combinations of two inputs, although all the functions joining inputs can be expanded to a arbitrary number of inputs.\nBoolean equations can be transformed to truth tables and vice versa. Later, we will also introduce Karnaugh maps, a way to optimize boolean logic in a graphical way.\nNOT The not operation also termed as inversion, is denoted as \\[\\overline{A} = \\neg A = Q\\]\nA\nQ\n0\n1\n1\n0\nThe not operation is the only one with only one input, it can not be expanded.\nAccordingly the gate-level implementation is also known by the name inverter. Despite its seemingly simple functionality there is a lot to say about the inverter for both the logical as well the implementation, so the author will dedicate it an own post in the mid-feature.\nAND The and operation also termed as conjunction is denoted as \\[A \\land B = Q\\]\nA\nB\nQ\n0\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n1\nOR The or operation also termed as disjunction is denoted as \\[A \\lor B = Q\\]\nA\nB\nQ\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n1\nAlthough boolean algebra on itself is an interesting field, we will only skim the subject briefly here, just enough to get a feeling and understanding how to work with boolean formulas.\nNote If you are interested in a more profound view, providing induction and proof, I refer you to accordingly literature (sources listed at the end). The laws of the boolean algebra are shown in the following table:\nLaw ∧ (conjunction, AND operator) ∨ (disjunction, OR operator) commutative law\n\\[p \\land q = q \\land p\\]\n\\[p \\lor q = q \\lor p\\]\nassociative law\n\\[p \\land (q \\land r) = (p \\land q) \\land r = pqr\\]\n\\[p \\lor (q \\lor r) = (p \\lor q) \\lor r = p \\lor q \\lor r\\]\nabsorptions law\n\\[p \\land (p \\lor q) = p\\]\n\\[p \\lor (p \\land q) = p\\]\ndistributive law\n\\[p \\lor (q \\lor r) = (p \\land q) \\lor (p \\land r) = pq \\lor pr\\]\n\\[p \\lor (q \\lor r) = (p \\lor q) \\lor (p \\lor r) = (p \\lor q)(p \\lor r)\\]\nneutral elements\n\\[p \\land 1 = p\\]\n\\[p \\lor 0 = p\\]\ncomplem. element\n\\[p \\land \\neg p = 0\\]\n\\[p \\lor \\neg p = 1\\]\nReference\nHans-Jochen Bartsch\nTaschenbuch Mathematischer Formeln, 20. Auflage, p. 27- 28\nYou probably know intuitively - or from school- the first two laws mentioned in the table, the commutative law and the associative laws. As you can see, every law can be applied to conjunctions as well as disjunctions without any exceptions.\nThe commutative law implies that the order of the variables is neutral for the operation and can be swapped without changing the result of the operation.\nThe associative law implies, that parenthesis are swappable. Conjunctions can be condensed without operator.\nThe absorptions law is probably not known to you from school, as it is only used in logic and has no counterpart in at least school mathmatics.\nThe distributive law, again, is known from school. It implies that variables / operations outside of paranthesis needs to be applied to all variables in the parenthesis.\nThe law of neutral elements, again is something special to boolean algebra. The logic one is the correspondent to \u0026#39;true\u0026#39;, and so p and true equals \u0026#39;true\u0026#39;, so as the logic zero is \u0026#39;false\u0026#39; and so p or false equals p.\nThe complementary law implies, that to every element (variable) p there is a complementary element (variable) p, so that the conjunction results in a logical zero while disjunction results in a logical one.\nAt this point the author has to leap ahead a bit as some practical issues on the electrical level need some thought on their logic level: On the implementation level (for an electrical implementation) it is rather uncommon to use AND,OR and NOT directly, instead the inverse functions NAND and NOR are used.\nNAND and NOR The NAND operation is denoted as \\[\\overline{A \\land B} = Q\\] while the NOR operation is denoted as \\[\\overline{A \\lor B} = Q\\]\nNAND\nNOR\nAs you can see, for those two functions the results are exactly the inverse of their respective complement (NAND ⇐⇒ AND,NOR ⇐⇒ OR), in that sense the author recommends the construction of the respective truth tables as an exercise to the reader.\nThe De Morgan theorem In addition to those merely basic axioms introduced above, there is the De Morgan theorem, which we need to easily convert between NAND and NOR. For the sake of simplicity we only show for two elements however the theorem is independent from any number of elements / inputs.\n\\[\\overline{p_1 \\land p_2} = \\overline{p_1} \\lor \\overline{p_2}\\]\nA\nB\n\\[\\overline{A}\\]\n\\[\\overline{B}\\]\n\\[\\overline{AB}\\]\n\\[\\overline{A} \\lor \\overline{B}\\]\n0\n0\n1\n1\n1\n1\n0\n1\n1\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n1\n0\n0\n0\n0\n\\[\\overline{p_1 \\lor p_2} = \\overline{p_1} \\land \\overline{p_2}\\]\nA\nB\n\\[\\overline{A}\\]\n\\[\\overline{B}\\]\n\\[\\overline{AB}\\]\n\\[\\overline{A} \\lor \\overline{B}\\]\n0\n0\n1\n1\n1\n1\n0\n1\n1\n0\n0\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n0\n0\n0\nNow we are finally equipped to continue with the electrical part / description.\nImplementation on electrical level First we are introducing some common electronic components and their symbols used in electric circuit schematics.\nThe diode We are beginning the journey with a simplificated circuit design for \u0026#39;and\u0026#39; and \u0026#39;or\u0026#39; called wired logic. This circuit design is so simple it is even not possible to implement an inverter in it.\nwired and\nwired or\nAs you can see, this circuit is not to complicate - even laymans in electronc should be able to identify the essential parts of - the inputs are connected to a diode, each. A diode is a simple semiconductor which acts as a one-way for electric current. Semiconductors are a group of materials (only silicon and germanium are useful here, due to their chemical properties), not really conductor but also no insulator. In fact the conductiviy of the material is dependent on the deliberated pollution of their crystall lattice structure with elements of the fifth main group, for an n(egative)-dotted material respectively of the third main group for a p(ositive) dotted material. This process is called dotting. For the interested reader here is a link to all the physical background the author was to lazy to repeat since it is often and better explained on the internet already ;-) .\nAll we need to know right know is that a diode consist of one substrate (in most cases today silicon) which becomes n-dotted on one side and p-dotted on the other, forming a pn-junction in between acting as said one-way barrier: It is possible for electrons to rush from n-side to the p-side but not the other way round.\nThe second component of the circuits shown above is a resistor, its solely purpose is to reduce the current flowing. For wire-and it is wired as pull-up resistor while for wire-or it is wired as pull down resistor. The wire-and only reaches a sufficient high-level if all inputs go high-level. Similar the wire-or only goes low-level if neither of the inputs goes high level.To prevent current flowing from pull-up resistor to the output of the previous circuit (wire and) respectively current flowing from one input back to the other input (wire-or), the diodes are in place.\nA problem of this setup which we will definitely encounter at some point, is that the signal is weakend when flowing from input to the output and there is no ability provided to recover the signal, so at the output the signal level might not be distinguished correctly by the subsequent circuit. Allow the author a remark in a subtle detail in the terminology at this point: Although it is often described as amplifying we want holding on here, that we want a somewhat \u0026#39;intelligent\u0026#39; signal amplifier here recognizing the signal level of the input signal and recovering, complementary to a \u0026#39;stupid\u0026#39; amplifier just amp-ing the input signal.\nSo the diodes are a fine component, e.g. useful when protecting parts of the circuit from electrostatic discharge (ESD), but for our logic it is not sufficient.\nWhat if we had a component capable to amplify the signal, so we could design circuits also recovering the signal levels with it? Luckily such a component exists and is introduced in the next section.\nThe MOSFET transistor The type of transistor we want to introduce and use here is a MOSFET (Metal Oxid Semiconductor Field Effect Transistor) - as opposed to classical bipolar transistor. As the name suggests a MOSFET is a transistor (or semiconductor) where the load currrent can be controlled by the strength of the electrical field, created on the gate input\nThe image above sketches the principal structure of a mosfet on the silicon. Source and drain are both connected to an own n-well, in the p dotted substrate, while the gate in between is isolated by a thin silicon dioxide layer. There is a forth connector \u0026#39;bulk\u0026#39;, leading to the substrate, in discrete MOSFETs connected to the source, but for now this one is not relevant. There is a lot of complex physics behind the workings of a MOSFET all we want to know for now, is that when a voltage is applied to the gate, an electrical field is induced, which creates a chanel between source and drain and allows electrons to flow from source to drain. The higher the gate voltage the bigger (wider) the channel, the more electrons flowing (until a certain boundary of course). And if the gate voltage is zero, also the channel is non-existent.\nCommon used symbols for MOSFET used in electrical schematics as well as some other we need due to course are shown below, some has more then only one, especially the MOSFET has a number of sligthly various symbols reflecting the differences in the physical component.\nWith the MOSFET element introduced and a single resistor,an element which reduces the current flow, added, we can straight-forward implement an inverter circuit as shown in the image above. Source is connected to the ground and Drain is connected to the inverter output and also to the voltage source via a high-impedance resitor. Gate is the input of the inverter. When the voltage is set to low on the gate, the MOSFET does not conduct and so the potential available on the output is sufficient for a logic one. Whene a voltage is set to the gate,the drain-source path of the MOSFET becomes conductive, the potential available on the output breaks down an drains away via the drain-source path.\nOn the electrical level inverter has two different tasks to fullfill\nRefreshing the signal (level) the inverters gets from the preceeding circuit\nActually, inverting the signal\nThere are also integrated circuits, called buffer or driver, solely dedicated to the first task mentioned, we will discuss that in a later blog post / lesson. Here we want to focus only on the logical part of inverting the signal, although for that both functions are equal important, thats why they are combined in one circuit. Of course, the logic signals have to be refreshed also in other logical circuits - like and and or - but in most cases this task is solely handeled by those inverter stages, afterwards or before.\nIn the symbol the first task, the refreshing of the signal (level), is indicated by the triangle, while the little circle denotes the actual inverting function.\nNMOS NAND\nNMOS NOR\nNow it becomes clear, why the inverse function of AND and OR on the gate level is simpler than the original function. Because you have to add an inverter circuit afterwards, increasing the transistor count.\nOne big drawback of the implementation is the high power consumption caused by the pull-up resistor. Let us see if there is a way to solve that issue. What if there is transistor labeled PMOS with a complementary structure - p-wells on an n dotted substrate - to our up-to-now used NMOS circuit?\nWhen we use those instead the resistor for the pull-up path we can drastically reduce power dissipation. As you guess this technique, both types of transistor combined, exists and is named CMOS ( Complementary Metal Oxid Semiconductor).\nCMOS NAND\nCMOS NOR\nIt becomes apparent now where the CMOS technology has its name from: As we can see in the implementation of NAND and NOR in CMOS technology, the P circuit above is exactly the complementary of the N circuit below. For the inverter this property was just not recognizable due to the symmetry. But we can also see the drawback of the CMOS technology: The number of transistors doubles, increasing the effort and complexity of the manuacturing process (complexer masks and layouts, more processing steps due to different types of transistors, nmos and pmos both on one wafer) and the integrated circuit as the end product.\nHowever the toolchain, the CMOS process and its related technologies are evolved and matured already since decades, so today it does not matter anymore, in fact recently Google even published the SkyWater Open Source PDK 130, a so-called Process Design Kit offering electrical engineers a tool(chain) to produce designs for Application Specific Integrated Circuits which then can directly be manufactured using a 130nm process. You can read more about it here on Hackaday.\nThat was a first slight look into boolean logic and its implementation on silicon, of course there is a lot more to it than only one reference design, also we did not had a look yet for ESD measurements and protection circuits for the inputs and output.\nIn the next post we have a look on the exclusive-or (XOR) operation.\n"},{"id":45,"href":"/pages/overview/","title":"How does a CPU work? Overview","section":"Pages","content":" How does a CPU work - Table of contents Introduction and overview Introduction and overview\nEvery topic of this course is broken up into two parts: A part about the mathematical side of digital logic, ideally almost independent from implementation details and a more concrete part handling this very details. In the concrete part we will mostly discuss the implementation on an electrical layer, though there are still other solutions possible based on fluid dynamics, or optical gates, most computers and logic gates are still based on electronics and semiconductor technology and this will not change with quantum computing, which is mostly tied to / adjunct to probability theory. However with quantum computing the fundamentals behind which the author describes here will completly change.\nCombinatorial Logic Introduction to Combinatorial Logic\nShort introduction to combinatorial logic,and its various description models.\nA first look at digital logic Boolean Algebra, basic logic gates and their implementation\nIn this lesson we will discover truth tables, boolean notation and learn about De Morgan’s laws. Also we have a look at the most basic logic gates and why their are usually are not implemented as such in electronics, having a look at NAND and NOR instead.\nYou have to choose! A complex gate: XOR\nAnother CPU instrucion and as a side-note and preparation for the next topic, we have a look at the XOR gate. As in the first lesson we’ll see first the logic part and then its translation into an electrical implementation.\n01+01 = 10 Binary systems (Part I) and Combinatorial Logic (Part I)\nHere we explain the basic concept of how to count with only two different states at hand. Also we will learn how to sum up two positive integer values in the binary system, derivate the logic needed for a full-adder, to dive into the topic of combinatorial logic.\nThere is plenty room in the negative space Binary Systems (Part II) signed integer\nSecond part about the binary system. In this post we learn about one- and two- complement and subtraction.\nAdding is not all Combinatorial Logic (Part II), a simple ALU\nWe want close the first series by this second chapter about combinatorial logic. We will extend the adder to a simple ALU\nOutline, what comes next From combinatorial to sequential\nIn this first course we learned some basics about digital logic. But all these examples use only static logic, we are still lacking a concept of how to store computed values. We need to learn the concept of registers and sequential logic. This will be the main topic of the second post series.\nExtra Let me look that up First look into Memory and Look-Up-Tables (LUTs)\nIn this lesson we learn, that - in principal - every form of combinatorial logic can be transformed into \u0026#39;software\u0026#39; by putting it into memory. In a practical example we will show how a DDS sine wave generator use a Look-Up-Table (LUT) to replicate the sine.\n"},{"id":46,"href":"/about/","title":"About","section":"Agenda","content":" A simple static blog meant for writing about topics like electronics \u0026amp; computation and - maybe - philosophy.\nDear reader of my humble blog , I am Sven Wehrend, a scanner personality born 1987, interested in a wide range of different topics reaching from technology over psychology to spirituality.\nI studied Computer Engineering at the HTW Berlin (Bachelor) and TU Berlin (Master).\nlegal notice and address: Sven Wehrend Eythstrasse 20 12105 Berlin\nemail: sven.wehrend[at]gmail.com\n"},{"id":47,"href":"/posts/web/00_setting_up_nikola/","title":"Setting up a static blog with Nikola","section":"Web","content":" I picked up Nikola some months ago as I was searching for a simple static-site-generator to setup a blog with minimal effort.\nTo make things a bit more interesting and at the same time easier we will use Nikola in a Docker container. So I require an almost basic understanding for Docker here.\nFirst create a directory on our host system, where you want the files stored, e.g. \u0026#39;blog\u0026#39; in your home directory.\nYou can pull unoffical images with the most recent version via:\ndocker pull dragas/nikola and run the image getting a (bash) shell via:\ndocker run -it --network=\u0026#34;host\u0026#34; -v ~/blog:/nikola dragas/nikola here the option flag -it stands for interactive - which, in fact, it does not but it is easy to memorize so, so let it be so. Furthermore we need to add our volume, a storage resource which is shared between the host system and the docker container. So we add -v ~/blog for our blog located in our home directory (for linux, on windows systems the paths differ). Also we need to add the option --network=\u0026#34;host\u0026#34; otherwise we won’t be able to access the webpage from our host system, and thus from our browser. If you are interested, check Docker run\nHere you can execute the common bash commands like cd, ls, ps and so on, feel free to test and explore Basic bash commands :-)\nNow that you have explored the system a bit, you can initiate a basic nikola project via:\nnikola init You will be led through some questions regarding your blog, for destination simply set .\nWe create a first post with:\nnikola new_page -t \u0026#34;Hello World\u0026#34; Write the post on your host system on an editor of your choice it is located in blog/posts/hello-world.rst and then build via:\nnikola build To test the website, start the test server with:\nnikola serve and head your browser to http://localhost:8080 .\nThis is cool, but surely we want do a bit of styling and customization now, as the current look is pretty standard. The author’s preference is a plain and simple style without much unnecessary payload.So I searched for such theme, but they were not to my liking. Then I found the Nikola port of Hyde\nThe theme can be installed with:\nnikola theme -i hyde After installation the theme needed some tweaking of the about section in the sidebar. So the version shown here diverges from the original look. Adjustments were made to the file assets/css/hyde.css in the directory of the freshly installed theme. Ideally the changes should be made in an additional file custom.css\nMuch better now!\nIf we are satified with the result, we can deploy our new static site to web space of our choice. For this we adjust the deploy setting in th conf.py file. This can look like the following.\nDEPLOY_COMMANDS = { \u0026#39;default\u0026#39;: [ \u0026#39;rsync -rav --delete output/ user@server:/var/www/virtual/user/html\u0026#39;, \u0026#39;rdiff-backup output ~/blog-backup\u0026#39;, ] } Now, we can simply execute this command by typing\nnikola deploy and the new site is part of the www.\n"},{"id":48,"href":"/posts/web/01_writing-about-math-with-asciidoc/","title":"Writing about math with Asciidoc","section":"Web","content":" While drafting a blog post, part of a series of posts intended to be published in the future, I discovered a lack of my tooling in Nikola. When adding mathematical formulas, I realized that there is no default-way of rendering images from those math formulas, and inserting them as image-tags into the html. Instead math formulas are handled via JS, which I try to reduce to an absolute minimum on my site. So I started to implement a rather quick-and-dirty plugin to do exactly this transformation, using latex and dvipng or dvisvgm. Then I come across this blog post where reading about asciidoc written in python and its successor asciidoctor written in ruby supporting different display formats. Ideal for the content I had in mind. So I installed the Nikola plugin asciidoc (which is mostly a wrapper to the asciidoc binary called as a subprocess), via\nnikola plugin -i asciidoc in my local environment and converted my blogpost(s) first semi-automatically which is, due to the metadata-section from Nikola, not the very best idea and continued manually. After some frustrations with the paths for the latex filter inside asciidoc it was working.\nSo as a sample of one of the future blogposts here one or rather two math-equations rendered this way:\n\\[ \\begin{array}{c} c = x \\land y \\\\ s = x \\oplus y \\end{array} \\]\nJust as side-note: It describes a halfadder.\nEdit Improved grammar.\n"},{"id":49,"href":"/docs/digital_logic/agenda2/","title":"Agenda2","section":"Digital Logic","content":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN\" \"http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd\"\u003e- no title specified Combinatorial Logic\nSequential Logic\n00_combinatorial_logic\n10_sequential_logic\n01_boolean_algebra\n11_clocks,flipflops_and_registers\n02_XOR\n12_automata\n03_binary_system\n13_cpu_control 04_Signs\n14_programmable Logic\n05_ALU\n15_test_logic\n06_Memory\n16_ HDLs (VHDL+Verilog)\n17_Register-Transfer-Level\nComputer Architecture / Processor design\n20_RISC_V 21_ISA, Assembler + Linker\n22_RISC_V_implementation\nExcursions\nX0_Multiplication\nX1_Division X2_Trigonometric functions (CORDIC)\nX3_Sigmoid functions\nOther topics\nO00_Consciousness "},{"id":50,"href":"/docs/digital_logic/agenda3/","title":"Agenda3","section":"Digital Logic","content":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN\" \"http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd\"\u003e - no title specified Combinatorial Logic\nSequential Logic\n00_combinatorial_logic\n10_sequential_logic\n01_boolean_algebra\n11_clocks,flipflops_and_registers\n02_XOR 12_automata\n03_binary_system 13_cpu_control 04_Signs\n14_programmable Logic\n05_ALU 15_test_logic\n06_Memory 16_ HDLs (VHDL+Verilog)\n17_Register-Transfer-Level\nComputer Architecture / Processor design\n20_RISC_V 21_ISA, Assembler + Linker\n22_RISC_V_implementation\nExcursions\nX0_Multiplication\nX1_Division X2_Trigonometric functions (CORDIC)\nX3_Sigmoid functions\nOther topics\nO00_Consciousness "},{"id":51,"href":"/drafts/alu2/","title":"Alu2","section":"Drafts","content":" title: How does a CPU work? The swiss knife (Part II)\nslug: how-does-a-cpu-work-alu-2\ndate: 2022-02-09\ncategory:\nlink:\ndescription:\ntype: text\nALU (Arithmetic Logic Unit) Instruction table logic operations description implementation data type / size and\nbasic boolean Op\n-\nbit\nor\nbasic boolean Op\n-\nbit\nnot\nbasic boolean Op\n-\nbit\nxor\ncomplex boolean Op\n-\nbit\nshl\nshift left\n-\nvarious\nshr\nshift right\n-\nvarious\ncontrol instructions description data type / size ld\nload\nvarious\nst\nstore\nvarious\njx\njump (x= gt,eq, lt )\nvarious\narithmetic operations description implementation data type / size ashl\narithmetic shift left\n-\nvarious\nashr\narithmetic shift right\n-\nvarious\ninc\nincrement\n-\nvarious\ndec\ndecrement\n-\nvarious\nadd\naddition\n-\n(u) integer\nsub\nsubtraction\n-\n(u) integer\nmul\nmultiplication\nsoftware-routine or HW\n(u)integer\ndiv\ndivision\nsoftware-routine or HW\n(u)integer\nsin\nsine\nsoftware-routine (Cordic)\n(u) integer\ncos\ncosine\nsoftware-routine (Cordic)\n(u) integer\ntan\ntangens\nsoftware-routine (Cordic)\n(u) integer\nCompare operations The first type of instructions we have nor called not even discussed are compare instructions. We first show a comparator for a single bit, and then derive an comparator for arithmetic operations.This whole section is just a quotation, the original source is found here.\nA B \u0026gt; (G) = (E) \u0026lt; (L) 0\n0\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n1\n0\n0\n1\n1\n0\n1\n0\nThis leads us to three simple boolean equations (greater than, equal, less than):\n\\[ G = A\\overline{B} \\]\n\\[ E = \\overline {A \\oplus B} \\]\n\\[ L = \\overline{A}B \\]\nWe extend this scheme to a 4 bit width comparator as follows:\n\\[ A = A_{1}A_{2}A_{3}A_{4} \\quad and \\quad B=B_{1}B_{2}B_{3}B_{4} \\]\nGreater than \\huge \\[ \\begin{array}{l} (1) \\quad A_{1} \u0026gt; B_{1} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\\\ (2) \\quad A_{1} = B_{1};A_{2} \u0026gt; B_{2} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\\\ (3) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} \u0026gt; B_{3} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\\\ (4) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} = B_{3};A_{4} \u0026gt; B_{4} ⇒ A \u0026gt; B \\quad or \\quad G=1 \\end{array} \\]\n\\huge \\[ \\begin{array}{l} For \\quad (1) \\quad G = A_{1}\\overline{B}_{1} \\\\ For \\quad (2) \\quad G= \\overline {A_{1} \\oplus B_{1}} (A_{2}\\overline{B_{2}}) \\\\ For \\quad (3) \\quad G= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (A_{3}\\overline{B_{3}}) \\\\ For \\quad (4) \\quad G= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (A_{4}\\overline{B_{4}}) \\end{array} \\]\nFrom this follows, that G=1 when either of the above equations holds…​\n\\huge \\[ \\begin{array}{l} G= A_{1}\\overline{B}_{1} + \\overline {A_{1} \\oplus B_{1}} (A_{2}\\overline{B_{2}}) \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (A_{3}\\overline{B_{3}}) + \\\\ \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (A_{4}\\overline{B_{4}}) \\end{array} \\]\nLess than \\huge \\[ \\begin{array}{l} (5) \\quad A_{1} \u0026lt; B_{1} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\\\ (6) \\quad A_{1} = B_{1};A_{2} \u0026lt; B_{2} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\\\ (7) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} \u0026lt; B_{3} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\\\ (8) \\quad A_{1} = B_{1};A_{2} = B_{2};A_{3} = B_{3};A_{4} \u0026lt; B_{4} ⇒ A \u0026lt; B \\quad or \\quad L=1 \\end{array} \\]\n\\huge \\[ \\begin{array}{l} For \\quad (5) \\quad L= \\overline{A}_{1}B_{1} \\\\ For \\quad (6) \\quad L= \\overline {A_{1} \\oplus B_{1}} (\\overline{A_{2}}B_{2}) \\\\ For \\quad (7) \\quad L= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (\\overline{A_{3}}B_{3}) \\\\ For \\quad (8) \\quad L= \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (A_{4}\\overline{B_{4}}) \\end{array} \\]\nFrom this follows, that L=1 when either of the above equations holds…​\n\\huge \\[ \\begin{array}{l} L= \\overline{A}_{1}B_{1} + \\overline {A_{1} \\oplus B_{1}} (\\overline{A_{2}}B_{2}) \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} (\\overline{A_{3}B_{3}}) + \\\\ \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} (\\overline{A_{4}}B_{4}) \\end{array} \\]\nEqual Last but not least for equal holds:\n\\huge \\[ \\begin{array}{l} A_{1}=B_{1}; A_{2}=B_{2};A_{3}=B_{3};A_{4}=B_{4} ⇒ E=1 \\\\ E = \\overline {A_{1} \\oplus B_{1}} \\quad \\overline {A_{2} \\oplus B_{2}} \\quad \\overline {A_{3} \\oplus B_{3}} \\quad \\overline {A_{4} \\oplus B_{4}} \\end{array} \\]\nThus, the logical circuit is designed as follows:\nComparator circuit The 4063 cmos IC is a 4 bit comparator IC. It can be cascaded to cover wider bit ranges.\nShift operations The next important set of operations are the shift operations. Those can be divided in logical as well as arithmetic shift operations.\nAs you may have noticed, in the last posts we have not even mentioned the two more advanced fundamental arithmetic operations multiplication and divison of integers. mul and div are very elaborate operations compared to addition and subtraction.\nSimple CPUs and microprocessors do not even have multiplier units or division units. The instructions have to be programmed as a software routine, we go into this in more details in another blogpost. (And then there is of course also floating point arithmetic, even more complex than our currently discussed integers).\nThe now introduced arithmetic shift operations solves multiplication and division operations at least for a subset of powers of two:\nAn arithmetic left shift of a two’s complement value by n bits equals a multiplication by 2n. (Given no overflow is produced)\nAn arithmetic right shift equals the floor of a division by 2n.\nA simple Shifter The gate-level implementation of a simple shifter is shown below.\nNext we see the truth table for the decoder logic, the derivation of the netlist is left as excercise for the reader.\nSel1 Sel0 R nop L 0\n0\n0\n1\n0\n0\n1\n0\n0\n1\n1\n0\n1\n0\n0\nWe see the gate-level implementation of such a shifter- is shown for the operations is realised in pass-transistor-logic (Reference: VLSI Design by K.Lal Kishore and V.S.V Prabhakar).\nBarrel Shifter A more sophisticated shifter implementation is the so known barrel shifter. The barrel shifter allows a shift over multiple bits in one go.\nAn implementation in pass-transistor-logic is shown below.\n"}]